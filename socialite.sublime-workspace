{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"dazmiller",
				"dazmiller@gmail"
			],
			[
				"padding",
				"padding-left"
			],
			[
				"att",
				"attr(\"data"
			],
			[
				"in",
				"intro"
			],
			[
				"drill",
				"drill_down"
			],
			[
				"vi",
				"vizTypes	visualization.js"
			],
			[
				"h",
				"height"
			],
			[
				"veh",
				"veh_type"
			],
			[
				"b_",
				"b_time"
			]
		]
	},
	"buffers":
	[
		{
			"file": "client/views/dashboard/dashboard_header.html",
			"settings":
			{
				"buffer_size": 1830,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/C/autoform/books.js",
			"settings":
			{
				"buffer_size": 720,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/C/autoform/.meteor/local/build/programs/server/packages/materialize_materialize.js",
			"settings":
			{
				"buffer_size": 234,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/C/autoform/.meteor/local/build/programs/server/packages/gildaspk_autoform-materialize.js",
			"settings":
			{
				"buffer_size": 374,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/C/autoform/.meteor/local/build/programs/server/app/autoform-materialize.js",
			"settings":
			{
				"buffer_size": 90,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/C/autoform/.meteor/local/build/programs/server/app/books.js",
			"settings":
			{
				"buffer_size": 739,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/C/autoform/.meteor/local/build/programs/web.browser/packages/materialize_materialize.js",
			"settings":
			{
				"buffer_size": 122007,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/C/autoform/.meteor/local/build/programs/web.browser/packages/materialize_materialize.js.map",
			"settings":
			{
				"buffer_size": 123532,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/C/autoform/.meteor/local/build/programs/web.browser/packages/gildaspk_autoform-materialize.js",
			"settings":
			{
				"buffer_size": 124877,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/C/autoform/autoform-materialize.html",
			"settings":
			{
				"buffer_size": 158,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/C/autoform/autoform-materialize.js",
			"settings":
			{
				"buffer_size": 71,
				"line_ending": "Unix"
			}
		},
		{
			"file": "client/views/dashboard/dashboard_header.coffee",
			"settings":
			{
				"buffer_size": 663,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "Searching 558 files for \"sockjs\"\n\nC:\\socialite\\.meteor\\local\\build\\programs\\server\\packages\\ddp.js:\n   17  \n   18  /* Package-scope variables */\n   19: var DDP, DDPServer, LivedataTest, toSockjsUrl, toWebsocketUrl, StreamServer, Heartbeat, Server, SUPPORTED_DDP_VERSIONS, MethodInvocation, parseDDP, stringifyDDP, RandomStream, makeRpcSeed, allConnections;\n   20  \n   21  (function () {\n   ..\n   53  // @param endpoint {String} URL to Meteor app                                                                          // 1\n   54  //   \"http://subdomain.meteor.com/\" or \"/\" or                                                                          // 2\n   55: //   \"ddp+sockjs://foo-**.meteor.com/sockjs\"                                                                           // 3\n   56  //                                                                                                                     // 4\n   57  // We do some rewriting of the URL to eventually make it \"ws://\" or \"wss://\",                                          // 5\n   ..\n   59  // us should work.                                                                                                     // 7\n   60  //                                                                                                                     // 8\n   61: // We don't do any heartbeating. (The logic that did this in sockjs was removed,                                       // 9\n   62: // because it used a built-in sockjs mechanism. We could do it with WebSocket                                          // 10\n   63  // ping frames or with DDP-level messages.)                                                                            // 11\n   64  LivedataTest.ClientStream = function (endpoint, options) {                                                             // 12\n   ..\n  193      // We would like to specify 'ddp' as the subprotocol here. The npm module we                                       // 141\n  194      // used to use as a client would fail the handshake if we ask for a                                                // 142\n  195:     // subprotocol and the server doesn't send one back (and sockjs doesn't).                                          // 143\n  196      // Faye doesn't have that behavior; it's unclear from reading RFC 6455 if                                          // 144\n  197      // Faye is erroneous or not.  So for now, we don't specify protocols.                                              // 145\n  ...\n  278  // @param url {String} URL to Meteor app, eg:                                                                          // 11\n  279  //   \"/\" or \"madewith.meteor.com\" or \"https://foo.meteor.com\"                                                          // 12\n  280: //   or \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"                                                                 // 13\n  281  // @returns {String} URL to the endpoint with the specific scheme and subPath, e.g.                                    // 14\n  282: // for scheme \"http\" and subPath \"sockjs\"                                                                              // 15\n  283: //   \"http://subdomain.meteor.com/sockjs\" or \"/sockjs\"                                                                 // 16\n  284: //   or \"https://ddp--1234-foo.meteor.com/sockjs\"                                                                      // 17\n  285  var translateUrl =  function(url, newSchemeBase, subPath) {                                                            // 18\n  286    if (! newSchemeBase) {                                                                                               // 19\n  ...\n  288    }                                                                                                                    // 21\n  289                                                                                                                         // 22\n  290:   var ddpUrlMatch = url.match(/^ddp(i?)\\+sockjs:\\/\\//);                                                                // 23\n  291    var httpUrlMatch = url.match(/^http(s?):\\/\\//);                                                                      // 24\n  292    var newScheme;                                                                                                       // 25\n  ...\n  337  };                                                                                                                     // 70\n  338                                                                                                                         // 71\n  339: toSockjsUrl = function (url) {                                                                                         // 72\n  340:   return translateUrl(url, \"http\", \"sockjs\");                                                                          // 73\n  341  };                                                                                                                     // 74\n  342                                                                                                                         // 75\n  ...\n  346  };                                                                                                                     // 79\n  347                                                                                                                         // 80\n  348: LivedataTest.toSockjsUrl = toSockjsUrl;                                                                                // 81\n  349                                                                                                                         // 82\n  350                                                                                                                         // 83\n  ...\n  407      }                                                                                                                  // 140\n  408                                                                                                                         // 141\n  409:     if (options._sockjsOptions) {                                                                                      // 142\n  410:       self.options._sockjsOptions = options._sockjsOptions;                                                            // 143\n  411      }                                                                                                                  // 144\n  412                                                                                                                         // 145\n  ...\n  561    // Because we are installing directly onto WebApp.httpServer instead of using                                        // 10\n  562    // WebApp.app, we have to process the path prefix ourselves.                                                         // 11\n  563:   self.prefix = pathPrefix + '/sockjs';                                                                                // 12\n  564    // routepolicy is only a weak dependency, because we don't need it if we're                                          // 13\n  565    // just doing server-to-server DDP as a client.                                                                      // 14\n  ...\n  568    }                                                                                                                    // 17\n  569                                                                                                                         // 18\n  570:   // set up sockjs                                                                                                     // 19\n  571:   var sockjs = Npm.require('sockjs');                                                                                  // 20\n  572    var serverOptions = {                                                                                                // 21\n  573      prefix: self.prefix,                                                                                               // 22\n  ...\n  577      heartbeat_delay: 45000,                                                                                            // 26\n  578      // The default disconnect_delay is 5 seconds, but if the server ends up CPU                                        // 27\n  579:     // bound for that much time, SockJS might not notice that the user has                                             // 28\n  580      // reconnected because the timer (of disconnect_delay ms) can fire before                                          // 29\n  581:     // SockJS processes the new connection. Eventually we'll fix this by not                                           // 30\n  582:     // combining CPU-heavy processing with SockJS termination (eg a proxy which                                        // 31\n  583      // converts to Unix sockets) but for now, raise the delay.                                                         // 32\n  584      disconnect_delay: 60 * 1000,                                                                                       // 33\n  ...\n  590                                                                                                                         // 39\n  591    // If you know your server environment (eg, proxies) will prevent websockets                                         // 40\n  592:   // from ever working, set $DISABLE_WEBSOCKETS and SockJS clients (ie,                                                // 41\n  593    // browsers) will not waste time attempting to use them.                                                             // 42\n  594    // (Your server will still have a /websocket endpoint.)                                                              // 43\n  ...\n  596      serverOptions.websocket = false;                                                                                   // 45\n  597                                                                                                                         // 46\n  598:   self.server = sockjs.createServer(serverOptions);                                                                    // 47\n  599    if (!Package.webapp) {                                                                                               // 48\n  600      throw new Error(\"Cannot create a DDP server without the webapp package\");                                          // 49\n  601    }                                                                                                                    // 50\n  602:   // Install the sockjs handlers, but we want to keep around our own particular                                        // 51\n  603    // request handler that adjusts idle timeouts while we have an outstanding                                           // 52\n  604:   // request.  This compensates for the fact that sockjs removes all listeners                                         // 53\n  605    // for \"request\" to add its own.                                                                                     // 54\n  606    Package.webapp.WebApp.httpServer.removeListener('request', Package.webapp.WebApp._timeoutAdjustmentRequestCallback); // 55\n  ...\n  653    },                                                                                                                   // 102\n  654                                                                                                                         // 103\n  655:   // Redirect /websocket to /sockjs/websocket in order to not expose                                                   // 104\n  656:   // sockjs to clients that want to use raw websockets                                                                 // 105\n  657    _redirectWebsocketEndpoint: function() {                                                                             // 106\n  658      var self = this;                                                                                                   // 107\n  659      // Unfortunately we can't use a connect middleware here since                                                      // 108\n  660:     // sockjs installs itself prior to all existing listeners                                                          // 109\n  661      // (meaning prior to any connect middlewares) so we need to take                                                   // 110\n  662      // an approach similar to overshadowListeners in                                                                   // 111\n  663:     // https://github.com/sockjs/sockjs-node/blob/cf820c55af6a9953e16558555a31decea554f70e/src/utils.coffee            // 112\n  664      _.each(['request', 'upgrade'], function(event) {                                                                   // 113\n  665        var httpServer = Package.webapp.WebApp.httpServer;                                                               // 114\n  ...\n  673          var args = arguments;                                                                                          // 122\n  674                                                                                                                         // 123\n  675:         // Rewrite /websocket and /websocket/ urls to /sockjs/websocket while                                          // 124\n  676          // preserving query string.                                                                                    // 125\n  677          var parsedUrl = url.parse(request.url);                                                                        // 126\n  ...\n 1092                                                                                                                         // 264\n 1093                                                                                                                         // 265\n 1094:   // XXX HACK: If a sockjs connection, save off the URL. This is                                                       // 266\n 1095    // temporary and will go away in the near future.                                                                    // 267\n 1096    self._socketUrl = socket.url;                                                                                        // 268\n ....\n 2077                                                                                                                         // 1249\n 2078    self.stream_server.register(function (socket) {                                                                      // 1250\n 2079:     // socket implements the SockJSConnection interface                                                                // 1251\n 2080      socket._meteorSession = null;                                                                                      // 1252\n 2081                                                                                                                         // 1253\n ....\n 3074  //   headers: extra headers to send on the websockets connection, for                                                  // 11\n 3075  //     server-to-server DDP only                                                                                       // 12\n 3076: //   _sockjsOptions: Specifies options to pass through to the sockjs client                                            // 13\n 3077  //   onDDPNegotiationVersionFailure: callback when version negotiation fails.                                          // 14\n 3078  //                                                                                                                     // 15\n ....\n 3116        retry: options.retry,                                                                                            // 53\n 3117        headers: options.headers,                                                                                        // 54\n 3118:       _sockjsOptions: options._sockjsOptions,                                                                          // 55\n 3119        // Used to keep some tests quiet, or for other cases in which                                                    // 56\n 3120        // the right thing to do with connection errors is to silently                                                   // 57\n ....\n 4673  //     \"http://subdomain.meteor.com\",                                                                                  // 1610\n 4674  //     \"/\",                                                                                                            // 1611\n 4675: //     \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"                                                                  // 1612\n 4676                                                                                                                         // 1613\n 4677  /**                                                                                                                    // 1614\n\nC:\\socialite\\.meteor\\local\\build\\programs\\server\\packages\\ddp.js.map:\n    1: {\"version\":3,\"sources\":[\"ddp/common.js\",\"ddp/stream_client_nodejs.js\",\"ddp/stream_client_common.js\",\"ddp/stream_server.js\",\"ddp/heartbeat.js\",\"ddp/livedata_server.js\",\"ddp/writefence.js\",\"ddp/crossbar.js\",\"ddp/livedata_common.js\",\"ddp/random_stream.js\",\"ddp/livedata_connection.js\",\"ddp/server_convenience.js\"],\"names\":[],\"mappings\":\";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,G;AACA,iB;AACA,kD;AACA,G;AACA,S;AACA,kB;;;;;;;;;;;;;;;;;;;ACLA,6C;AACA,6C;AACA,4C;AACA,E;AACA,6E;AACA,gF;AACA,kB;AACA,E;AACA,gF;AACA,6E;AACA,2C;AACA,0D;AACA,kB;AACA,0B;;AAEA,2B;AACA,e;AACA,c;;AAEA,sD;AACA,2B;;AAEA,4C;;AAEA,iC;;AAEA,e;AACA,2B;AACA,E;;AAEA,+C;;AAEA,uE;AACA,oE;AACA,wB;AACA,yB;AACA,oB;AACA,uC;AACA,6B;AACA,K;AACA,I;;AAEA,yC;AACA,8B;AACA,oB;AACA,wB;AACA,I;;AAEA,iC;AACA,oB;;AAEA,iC;AACA,wE;AACA,gF;AACA,0E;AACA,sB;AACA,wE;AACA,K;;AAEA,mC;AACA,8E;AACA,qE;AACA,0B;AACA,yB;AACA,a;AACA,K;;AAEA,uC;AACA,yE;AACA,uE;AACA,gF;AACA,gF;AACA,sC;AACA,mD;AACA,K;;AAEA,iC;;AAEA,oB;AACA,4C;AACA,wC;AACA,sC;AACA,yB;;AAEA,sE;AACA,kD;AACA,2E;AACA,I;;AAEA,mC;AACA,oB;;AAEA,iC;AACA,sB;AACA,+B;AACA,yB;AACA,qB;;AAEA,kE;AACA,6B;AACA,S;AACA,K;AACA,I;;AAEA,sC;AACA,oB;;AAEA,+B;AACA,yC;AACA,kC;AACA,K;AACA,I;;AAEA,sC;AACA,oB;AACA,gD;AACA,yE;AACA,8E;AACA,mC;AACA,0E;AACA,K;AACA,iB;AACA,I;;AAEA,kC;AACA,oB;AACA,iE;;AAEA,2E;AACA,kE;AACA,kB;AACA,sD;;AAEA,kD;AACA,gD;AACA,gD;AACA,mB;AACA,+C;AACA,M;;AAEA,gF;AACA,uE;AACA,6E;AACA,6E;AACA,yE;AACA,0B;;AAEA,wD;AACA,4C;;AAEA,iC;AACA,6C;AACA,mB;AACA,6B;AACA,+D;AACA,Q;AACA,4B;;AAEA,+D;AACA,qC;AACA,mC;;AAEA,8D;AACA,gE;AACA,sE;AACA,mC;AACA,iB;AACA,iC;AACA,uB;AACA,M;;AAEA,0E;AACA,yC;AACA,qD;;AAEA,yE;AACA,oD;AACA,mE;AACA,O;;;AAGA,qE;AACA,6B;AACA,O;;;AAGA,gF;AACA,6D;AACA,2C;AACA,e;;AAEA,+D;AACA,+B;AACA,S;AACA,O;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACpMA,0E;AACA,wC;AACA,uC;AACA,+C;AACA,E;AACA,oC;AACA,qC;AACA,qD;AACA,E;;AAEA,6C;AACA,6D;AACA,sD;AACA,mF;AACA,yC;AACA,sD;AACA,iD;AACA,2D;AACA,wB;AACA,2B;AACA,G;;AAEA,uD;AACA,iD;AACA,gB;AACA,oB;AACA,4C;AACA,wD;AACA,6E;AACA,4C;AACA,c;AACA,0E;AACA,mE;;AAEA,0E;AACA,4E;AACA,wD;AACA,4C;AACA,8C;AACA,O;;AAEA,2C;AACA,4B;AACA,uE;AACA,0D;AACA,2C;AACA,G;;AAEA,uC;AACA,2D;AACA,sC;AACA,G;;AAEA,8D;AACA,sE;AACA,kE;AACA,sE;AACA,+B;AACA,I;AACA,kE;AACA,sE;AACA,iE;AACA,uE;AACA,2C;;AAEA,yB;AACA,yB;AACA,M;AACA,+B;AACA,E;;AAEA,8B;AACA,6C;AACA,E;;AAEA,iC;AACA,iD;AACA,a;AACA,E;;AAEA,uC;;;AAGA,+C;;AAEA,4B;AACA,iC;AACA,oB;;AAEA,wE;AACA,qD;;AAEA,mC;AACA,qC;AACA,6C;AACA,I;;;AAGA,mC;AACA,oB;AACA,4B;;AAEA,kB;;AAEA,+D;AACA,c;AACA,6D;;AAEA,mD;;AAEA,qC;;AAEA,wB;AACA,0B;AACA,2B;AACA,uB;AACA,mB;AACA,M;;;AAGA,oF;AACA,sC;AACA,+B;AACA,uC;AACA,M;;AAEA,oB;AACA,4B;AACA,gC;;AAEA,I;;AAEA,yB;AACA,iC;AACA,oB;AACA,4B;;AAEA,sB;AACA,mC;AACA,K;;AAEA,iC;AACA,2D;AACA,K;;AAEA,uC;AACA,0C;AACA,2B;AACA,2D;AACA,sB;AACA,a;AACA,K;;AAEA,wC;AACA,qD;AACA,oC;AACA,6B;AACA,K;;AAEA,wB;AACA,qE;AACA,qB;AACA,I;;AAEA,kC;AACA,oB;AACA,4B;;AAEA,qE;AACA,uD;AACA,iC;AACA,a;;AAEA,2E;AACA,mE;AACA,mE;AACA,6B;AACA,6B;AACA,sC;AACA,K;;AAEA,oB;AACA,wB;;AAEA,0B;AACA,0D;AACA,uB;AACA,mB;AACA,M;;AAEA,6C;AACA,iD;;AAEA,yB;AACA,I;;AAEA,gE;AACA,0C;AACA,oB;;AAEA,8B;AACA,wE;AACA,I;;AAEA,kE;AACA,iB;AACA,wB;AACA,0E;AACA,+C;AACA,uB;AACA,I;;AAEA,sC;AACA,oB;;AAEA,oB;AACA,6B;AACA,8E;AACA,uC;AACA,sC;AACA,oC;AACA,Q;AACA,4C;AACA,sE;AACA,Y;AACA,2C;AACA,0C;AACA,K;;AAEA,yC;AACA,yB;AACA,I;;AAEA,0B;AACA,oB;;AAEA,iC;AACA,a;;AAEA,uC;AACA,6C;AACA,yC;AACA,wC;AACA,yB;;AAEA,6B;AACA,I;;;AAGA,kC;AACA,uB;AACA,oB;AACA,6B;AACA,oC;AACA,8B;AACA,G;AACA,G;;AAEA,2C;AACA,6C;AACA,oB;AACA,2B;AACA,G;;AAEA,gD;AACA,8C;;;;;;;;;;;;;;;;;;;ACzQA,6B;;AAEA,uE;;AAEA,4B;AACA,kB;AACA,mC;AACA,yB;;AAEA,+E;AACA,8D;AACA,uC;AACA,6E;AACA,iD;AACA,4B;AACA,0E;AACA,G;;AAEA,kB;AACA,qC;AACA,uB;AACA,wB;AACA,uB;AACA,uE;AACA,+C;AACA,2B;AACA,+E;AACA,0E;AACA,6E;AACA,4E;AACA,+E;AACA,8D;AACA,gC;AACA,wE;AACA,oE;AACA,wB;AACA,4C;AACA,I;;AAEA,8E;AACA,uE;AACA,0D;AACA,yD;AACA,qC;AACA,oC;;AAEA,mD;AACA,wB;AACA,6E;AACA,G;AACA,+E;AACA,4E;AACA,8E;AACA,kC;AACA,sH;AACA,gE;AACA,mH;;AAEA,oC;AACA,oC;;AAEA,kD;AACA,mC;AACA,yB;AACA,M;AACA,oC;AACA,+D;AACA,O;AACA,mC;;AAEA,uE;AACA,mE;AACA,uE;AACA,uE;AACA,+B;AACA,kD;;AAEA,wE;AACA,kE;AACA,6D;AACA,uB;AACA,O;AACA,K;;AAEA,E;;AAEA,kC;AACA,iD;AACA,8C;AACA,iC;AACA,oB;AACA,+C;AACA,kD;AACA,uB;AACA,O;AACA,I;;AAEA,8B;AACA,4B;AACA,oB;AACA,uC;AACA,I;;AAEA,oE;AACA,sD;AACA,0C;AACA,oB;AACA,iE;AACA,6D;AACA,oE;AACA,oD;AACA,2G;AACA,oD;AACA,wD;AACA,wE;AACA,2C;;AAEA,gE;AACA,iE;AACA,gE;AACA,2D;AACA,6B;;AAEA,6E;AACA,mC;AACA,+C;AACA,+D;AACA,gE;AACA,0D;AACA,8C;AACA,S;AACA,8D;AACA,8C;AACA,W;AACA,Q;AACA,iD;AACA,O;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;AC1IA,qB;AACA,gE;AACA,uE;AACA,iC;AACA,iE;AACA,yD;;AAEA,gC;AACA,kB;;AAEA,qD;AACA,mD;AACA,oC;AACA,sC;;AAEA,uC;AACA,sC;AACA,E;;AAEA,+B;AACA,qB;AACA,oB;AACA,wC;AACA,uC;AACA,I;;AAEA,sB;AACA,oB;AACA,gB;AACA,wC;AACA,I;;AAEA,6C;AACA,oB;AACA,sD;AACA,iD;AACA,4B;AACA,M;AACA,I;;AAEA,4C;AACA,oB;AACA,qD;AACA,gD;AACA,2B;AACA,M;AACA,I;;AAEA,6C;AACA,oB;AACA,wC;AACA,yD;AACA,2C;AACA,K;AACA,I;;AAEA,4C;AACA,oB;AACA,uC;AACA,wD;AACA,0C;AACA,K;AACA,I;;AAEA,sE;AACA,wC;AACA,oB;AACA,yC;AACA,qB;AACA,uB;AACA,uC;AACA,I;;AAEA,qE;AACA,oC;AACA,uC;AACA,oB;AACA,wC;AACA,sB;AACA,I;;AAEA,6B;AACA,oB;AACA,kE;AACA,sE;AACA,wC;AACA,0C;AACA,0C;AACA,K;AACA,I;;AAEA,6B;AACA,oB;;AAEA,oE;AACA,0C;AACA,uC;AACA,yC;AACA,0C;AACA,K;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACrGA,e;;AAEA,kC;;AAEA,8B;AACA,6D;AACA,6D;AACA,2E;AACA,E;AACA,oE;AACA,qE;AACA,a;;AAEA,0D;AACA,uC;AACA,kB;AACA,kD;AACA,4E;AACA,E;;AAEA,yC;;AAEA,0B;AACA,oB;AACA,iB;AACA,2D;AACA,yC;AACA,O;AACA,e;AACA,I;;AAEA,mE;AACA,oB;AACA,mD;AACA,sB;AACA,a;AACA,6C;;AAEA,oE;AACA,gB;AACA,wB;AACA,a;;AAEA,iC;AACA,qD;AACA,yC;AACA,iE;AACA,gF;AACA,mC;AACA,oB;AACA,0C;AACA,oC;AACA,c;AACA,O;AACA,K;AACA,oC;AACA,iC;AACA,uC;AACA,4C;AACA,sE;AACA,qD;AACA,K;AACA,I;;AAEA,wD;AACA,kD;AACA,oB;AACA,mD;AACA,sB;AACA,a;;AAEA,6D;AACA,+B;;AAEA,sC;AACA,qE;AACA,6C;AACA,mC;AACA,a;AACA,K;AACA,6C;AACA,Y;AACA,iB;AACA,0D;AACA,oE;AACA,S;AACA,K;;AAEA,c;AACA,yE;AACA,iE;AACA,qC;AACA,O;AACA,wB;AACA,Y;AACA,2D;AACA,kF;AACA,K;;AAEA,G;AACA,G;;AAEA,G;AACA,oD;AACA,sE;AACA,gG;AACA,+B;AACA,G;AACA,yE;AACA,kB;AACA,uC;AACA,sB;AACA,oC;AACA,E;;AAEA,2D;;;AAGA,2C;;AAEA,wB;AACA,oB;AACA,qC;AACA,I;;AAEA,6B;AACA,oB;AACA,sE;AACA,4C;;AAEA,uC;AACA,yE;AACA,Q;;AAEA,uC;AACA,wD;AACA,O;AACA,O;AACA,I;;AAEA,8C;AACA,oB;AACA,oB;AACA,yE;AACA,uC;AACA,qC;AACA,4B;AACA,Q;AACA,sC;AACA,0B;AACA,Q;AACA,qC;AACA,gC;AACA,O;AACA,O;AACA,4D;AACA,I;;AAEA,oD;AACA,oB;AACA,qC;AACA,sB;AACA,mB;AACA,mB;AACA,0C;AACA,mC;AACA,K;AACA,gD;AACA,6B;AACA,0C;AACA,0B;AACA,+D;AACA,O;AACA,c;AACA,qE;AACA,Q;AACA,uE;AACA,I;;AAEA,uD;AACA,oB;AACA,2B;AACA,qC;AACA,iB;AACA,6E;AACA,2C;AACA,8B;AACA,mE;AACA,U;AACA,2E;AACA,O;AACA,mE;AACA,I;;AAEA,8C;AACA,oB;AACA,qC;AACA,mB;AACA,gE;AACA,gB;AACA,K;AACA,gD;AACA,sC;AACA,iC;AACA,sD;AACA,gC;AACA,Y;AACA,uB;AACA,4D;AACA,+B;AACA,gE;AACA,6D;AACA,S;;AAEA,+D;AACA,K;AACA,G;AACA,G;;AAEA,gF;AACA,gF;AACA,gF;;AAEA,2D;AACA,kB;AACA,wB;;AAEA,uB;AACA,yB;;AAEA,2B;AACA,uB;;AAEA,qE;AACA,0D;AACA,gD;;AAEA,uB;AACA,6B;;AAEA,yC;AACA,uB;AACA,2B;;AAEA,qB;;AAEA,4B;;AAEA,oE;AACA,gF;AACA,uC;AACA,yB;;AAEA,6E;AACA,yE;AACA,0C;;AAEA,4D;AACA,sE;AACA,0B;;AAEA,8D;AACA,4B;;;AAGA,gE;AACA,mD;AACA,+B;;AAEA,gD;AACA,gD;;AAEA,sE;AACA,sE;AACA,6C;AACA,2B;AACA,gB;AACA,wB;AACA,mB;AACA,M;AACA,4B;AACA,yE;AACA,yB;AACA,sC;AACA,c;AACA,sD;AACA,yB;AACA,O;AACA,M;AACA,yC;AACA,oC;AACA,I;;AAEA,6C;AACA,gD;AACA,8D;AACA,qB;AACA,8B;AACA,W;;AAEA,8D;AACA,oC;AACA,mD;AACA,iD;AACA,8B;AACA,qB;AACA,Q;AACA,6B;AACA,iC;AACA,O;AACA,O;AACA,2B;AACA,G;;AAEA,2D;AACA,+B;AACA,E;;AAEA,6B;;AAEA,yC;AACA,oB;AACA,wB;AACA,uD;AACA,U;AACA,yD;AACA,gD;AACA,S;AACA,K;AACA,I;;AAEA,oD;AACA,oB;AACA,wB;AACA,oF;AACA,I;;AAEA,sD;AACA,oB;AACA,0B;AACA,a;;AAEA,0B;AACA,iB;AACA,uB;AACA,mC;AACA,e;AACA,sB;AACA,S;AACA,K;AACA,I;;AAEA,8C;AACA,oB;AACA,wB;AACA,sE;AACA,I;;AAEA,iC;AACA,oB;AACA,Y;AACA,0C;AACA,8C;AACA,6C;AACA,M;AACA,I;;AAEA,gD;AACA,oB;AACA,sD;AACA,kD;AACA,K;AACA,uD;AACA,iE;AACA,+C;AACA,e;AACA,I;;AAEA,oE;AACA,oB;AACA,sD;AACA,+C;AACA,I;;AAEA,8D;AACA,oB;AACA,sD;AACA,yC;AACA,yB;AACA,kD;AACA,K;AACA,I;;AAEA,sE;AACA,oB;AACA,sD;AACA,iD;AACA,I;;AAEA,mC;AACA,oB;AACA,8E;AACA,6E;AACA,qE;AACA,mE;AACA,yC;AACA,uC;AACA,O;AACA,I;;AAEA,0D;AACA,sB;AACA,oB;;AAEA,+D;AACA,wE;AACA,8B;;AAEA,yB;AACA,uB;AACA,a;;AAEA,2C;AACA,wB;AACA,8B;;AAEA,yB;AACA,4B;AACA,4B;AACA,K;;AAEA,sB;AACA,0B;AACA,wC;AACA,K;;AAEA,6D;AACA,kC;;AAEA,8B;AACA,6D;AACA,qE;AACA,gF;AACA,yC;;AAEA,sE;AACA,qE;AACA,wD;AACA,mB;AACA,S;AACA,O;;AAEA,8B;AACA,qC;AACA,I;;AAEA,wE;AACA,yD;AACA,wB;AACA,oB;AACA,sB;AACA,+B;AACA,qD;AACA,0C;AACA,K;AACA,I;;AAEA,6B;AACA,kD;AACA,oB;AACA,6C;AACA,yB;AACA,8C;AACA,mB;AACA,I;;AAEA,kE;AACA,+D;AACA,qD;AACA,I;AACA,oE;AACA,qE;AACA,oE;AACA,sE;AACA,mE;AACA,qB;AACA,I;AACA,oE;AACA,oE;AACA,oE;AACA,Y;AACA,qC;AACA,oB;AACA,iD;AACA,a;;AAEA,qE;AACA,mE;AACA,oE;AACA,yC;AACA,M;AACA,wE;AACA,wE;AACA,qE;AACA,gD;AACA,2D;AACA,+B;AACA,gD;AACA,yB;AACA,2B;AACA,wC;AACA,iB;AACA,a;AACA,K;AACA,2D;AACA,yB;AACA,2B;AACA,wC;AACA,iB;AACA,a;AACA,K;;AAEA,8B;AACA,2B;AACA,a;AACA,8B;;AAEA,mC;AACA,qD;AACA,iB;AACA,mC;AACA,e;AACA,O;;AAEA,yB;AACA,2B;;AAEA,mC;AACA,uB;AACA,iC;AACA,0B;AACA,wB;AACA,U;;AAEA,mD;AACA,mE;AACA,Y;AACA,6C;AACA,8D;AACA,e;AACA,M;;AAEA,kB;AACA,I;;AAEA,sB;AACA,yB;AACA,sB;;AAEA,kC;AACA,yC;AACA,2C;AACA,kE;AACA,sD;AACA,e;AACA,O;;AAEA,oD;AACA,mB;AACA,mC;AACA,mE;AACA,e;AACA,O;;AAEA,yC;AACA,oE;AACA,gE;AACA,qB;AACA,e;;AAEA,2D;AACA,qE;;AAEA,M;;AAEA,2B;AACA,sB;;AAEA,qC;AACA,M;;AAEA,qC;AACA,sB;;AAEA,kC;AACA,wD;AACA,oC;AACA,yC;AACA,6C;AACA,kE;AACA,4E;AACA,2D;AACA,e;AACA,O;;AAEA,8C;;AAEA,kE;AACA,iE;AACA,c;AACA,4C;AACA,wC;AACA,8D;AACA,gE;AACA,6D;AACA,4D;AACA,gD;AACA,uB;AACA,mB;AACA,8C;AACA,S;;AAEA,yB;AACA,4D;AACA,qB;AACA,mB;AACA,oC;AACA,6D;AACA,oB;AACA,e;AACA,O;;AAEA,wC;AACA,gC;AACA,Q;;AAEA,6C;AACA,4B;AACA,4B;AACA,6B;AACA,yB;AACA,0C;AACA,8B;AACA,S;AACA,W;AACA,gF;AACA,2E;AACA,4C;AACA,+E;AACA,a;AACA,W;AACA,mB;AACA,0B;AACA,O;;AAEA,2D;AACA,iE;;AAEA,wC;AACA,iE;;AAEA,uC;AACA,mB;AACA,gE;AACA,iE;AACA,gE;AACA,K;AACA,I;;AAEA,0B;AACA,oB;AACA,+B;AACA,mC;AACA,I;;AAEA,8C;AACA,oB;AACA,mE;AACA,8D;AACA,mC;AACA,Q;AACA,wD;AACA,6D;AACA,kE;AACA,W;AACA,Q;AACA,sD;AACA,wD;AACA,+C;AACA,W;AACA,O;AACA,O;AACA,I;;AAEA,oE;AACA,sB;AACA,gC;AACA,oB;;AAEA,sD;AACA,0E;AACA,qC;;AAEA,4E;AACA,yE;AACA,M;AACA,6E;AACA,0E;AACA,8E;AACA,+E;AACA,+B;AACA,2C;;AAEA,4E;AACA,sC;AACA,kC;AACA,wB;AACA,O;;AAEA,+E;AACA,+E;AACA,yB;AACA,4B;AACA,yC;AACA,8B;AACA,yB;;AAEA,qE;AACA,uC;AACA,yB;AACA,6B;;AAEA,yD;AACA,wD;AACA,yE;AACA,0D;AACA,oD;AACA,O;;AAEA,4E;AACA,2E;AACA,Y;AACA,4C;AACA,8B;;AAEA,8E;AACA,4E;AACA,0D;AACA,yC;AACA,6B;AACA,2C;AACA,2C;AACA,2C;AACA,gC;AACA,O;AACA,O;AACA,I;;AAEA,+D;AACA,oB;;AAEA,+B;AACA,0C;AACA,c;AACA,mC;AACA,Q;AACA,oC;;AAEA,sB;AACA,I;;AAEA,qC;AACA,8C;AACA,oB;;AAEA,uB;;AAEA,0C;AACA,6C;AACA,mD;AACA,2C;AACA,oC;AACA,K;;AAEA,6C;;AAEA,gB;AACA,6C;AACA,c;AACA,0D;AACA,sC;AACA,K;;AAEA,wB;AACA,I;;AAEA,+E;AACA,kD;AACA,4C;AACA,oB;;AAEA,gD;AACA,wB;AACA,O;AACA,yB;;AAEA,gD;AACA,wB;AACA,O;AACA,6B;AACA,I;;AAEA,2D;AACA,oE;AACA,kC;AACA,+B;AACA,oB;;AAEA,sE;AACA,kE;AACA,kE;AACA,sE;AACA,kC;AACA,M;AACA,oE;AACA,gF;;AAEA,iC;AACA,uC;;AAEA,8D;AACA,mC;AACA,kB;AACA,wD;;AAEA,mE;AACA,oE;AACA,oE;AACA,qE;AACA,kE;AACA,qE;AACA,kE;AACA,qC;;AAEA,2E;AACA,kB;;AAEA,kE;AACA,G;AACA,G;;AAEA,gF;AACA,gF;AACA,gF;;AAEA,4D;;AAEA,0E;AACA,U;AACA,G;AACA,+C;AACA,sB;AACA,qB;AACA,G;AACA,6B;AACA,qD;AACA,kB;AACA,6C;;AAEA,K;AACA,wH;AACA,kB;AACA,sB;AACA,2B;AACA,c;AACA,K;AACA,kE;;AAEA,0B;;AAEA,4E;AACA,wC;AACA,iC;AACA,oB;;AAEA,8B;;AAEA,uE;AACA,yD;AACA,mE;AACA,6B;AACA,0D;AACA,U;AACA,iD;AACA,G;;AAEA,iC;AACA,4B;;AAEA,+D;AACA,2B;;AAEA,mE;AACA,qB;AACA,uB;;AAEA,8B;AACA,sB;;AAEA,kD;;AAEA,K;AACA,kH;AACA,kB;AACA,2B;AACA,kB;AACA,c;AACA,K;AACA,+B;;AAEA,kD;AACA,mD;AACA,sD;;AAEA,kD;AACA,sD;AACA,wD;AACA,wC;;AAEA,oB;AACA,8C;AACA,qC;AACA,I;;AAEA,2D;AACA,oC;AACA,E;;AAEA,kC;AACA,4B;AACA,sE;AACA,kD;AACA,M;AACA,uE;AACA,wE;AACA,iE;;AAEA,oB;AACA,S;AACA,yC;AACA,uD;AACA,0E;AACA,kE;AACA,yC;AACA,0C;AACA,iB;AACA,oB;AACA,a;AACA,K;;AAEA,oD;AACA,8B;AACA,a;;AAEA,uE;AACA,0E;AACA,0E;AACA,gF;AACA,+D;AACA,M;AACA,0E;AACA,8E;AACA,8E;AACA,6C;AACA,iE;AACA,6C;AACA,4C;AACA,wC;AACA,c;AACA,W;AACA,iC;AACA,mC;AACA,M;AACA,wB;AACA,W;AACA,iC;AACA,mB;AACA,sB;AACA,e;AACA,O;AACA,gF;AACA,oC;AACA,mB;AACA,gC;AACA,2C;AACA,mC;AACA,mF;AACA,e;AACA,O;AACA,wC;AACA,8E;AACA,yD;AACA,+B;AACA,4C;AACA,yD;AACA,qD;AACA,+B;AACA,0E;AACA,+B;AACA,iB;AACA,S;AACA,+C;AACA,Q;;AAEA,W;AACA,oC;AACA,mC;AACA,W;AACA,mB;AACA,sB;AACA,e;AACA,O;AACA,mB;AACA,qB;AACA,kE;AACA,oE;AACA,2B;AACA,0E;AACA,qD;AACA,K;AACA,I;;AAEA,6E;AACA,4E;AACA,yE;AACA,2E;AACA,+B;AACA,2B;AACA,oB;AACA,0B;AACA,a;AACA,6B;AACA,8B;AACA,6D;AACA,uC;AACA,I;;AAEA,mC;AACA,oB;AACA,2C;AACA,wC;AACA,6B;AACA,2C;AACA,iB;AACA,O;AACA,I;;AAEA,6C;AACA,oC;AACA,oB;AACA,yC;AACA,wE;AACA,+E;AACA,uB;AACA,yD;AACA,sE;AACA,W;AACA,S;AACA,O;AACA,I;;AAEA,kE;AACA,qE;AACA,sE;AACA,gE;AACA,mC;AACA,0B;AACA,oB;AACA,4B;AACA,uE;AACA,kB;AACA,I;;AAEA,K;AACA,kS;AACA,kB;AACA,0D;AACA,c;AACA,2B;AACA,K;AACA,2B;AACA,oB;AACA,8B;AACA,a;AACA,iE;AACA,I;;AAEA,gF;AACA,+E;AACA,6E;AACA,oC;;AAEA,K;AACA,2I;AACA,kB;AACA,c;AACA,2B;AACA,K;AACA,qB;AACA,oB;AACA,8B;AACA,a;AACA,0D;AACA,I;;AAEA,K;AACA,uH;AACA,kB;AACA,2B;AACA,c;AACA,iD;AACA,K;AACA,+B;AACA,oB;AACA,8B;AACA,iB;AACA,Q;AACA,yC;AACA,I;;AAEA,+E;AACA,0E;AACA,kB;AACA,+B;AACA,oB;AACA,+D;AACA,I;;AAEA,K;AACA,yH;AACA,kB;AACA,2B;AACA,c;AACA,0F;AACA,8C;AACA,+F;AACA,K;AACA,gD;AACA,oB;AACA,8B;AACA,a;AACA,wC;AACA,+D;AACA,8E;AACA,I;;AAEA,K;AACA,4H;AACA,kB;AACA,2B;AACA,c;AACA,8F;AACA,kD;AACA,yS;AACA,K;AACA,kD;AACA,oB;AACA,8B;AACA,a;AACA,wC;AACA,gF;AACA,I;;AAEA,K;AACA,6H;AACA,kB;AACA,2B;AACA,c;AACA,mG;AACA,qE;AACA,K;AACA,0C;AACA,oB;AACA,8B;AACA,a;AACA,wC;AACA,sE;AACA,gE;AACA,+C;AACA,wE;AACA,I;;AAEA,K;AACA,yQ;AACA,kB;AACA,2B;AACA,c;AACA,K;AACA,sB;AACA,oB;AACA,8B;AACA,a;AACA,8B;AACA,2D;AACA,uB;AACA,sD;AACA,yB;AACA,K;AACA,G;AACA,G;;AAEA,gF;AACA,gF;AACA,gF;;AAEA,6B;AACA,kB;;AAEA,sE;AACA,oE;AACA,iE;AACA,+C;AACA,I;AACA,uD;AACA,2E;AACA,4C;AACA,6B;AACA,4B;AACA,6D;AACA,wB;AACA,K;;AAEA,mE;AACA,wE;AACA,gE;AACA,uB;AACA,oC;AACA,iD;AACA,K;;AAEA,6B;AACA,uC;;AAEA,4B;;AAEA,+C;;AAEA,wC;;AAEA,iD;AACA,uD;AACA,iC;;AAEA,yD;AACA,+C;AACA,2B;AACA,gD;AACA,qC;AACA,M;;AAEA,0C;AACA,qC;AACA,+C;AACA,O;AACA,W;AACA,a;AACA,sC;AACA,uB;AACA,mC;AACA,iB;AACA,S;AACA,uC;AACA,wC;AACA,iB;AACA,S;;AAEA,oC;AACA,sC;AACA,gD;AACA,mB;AACA,W;AACA,6B;AACA,6C;AACA,mB;AACA,iB;AACA,S;;AAEA,qC;AACA,+C;AACA,iB;AACA,S;AACA,kD;AACA,mB;AACA,iC;AACA,yE;AACA,0C;AACA,O;AACA,O;;AAEA,oC;AACA,kC;AACA,2B;AACA,wC;AACA,iB;AACA,O;AACA,O;AACA,K;AACA,E;;AAEA,4B;;AAEA,K;AACA,+F;AACA,kB;AACA,8F;AACA,qB;AACA,K;AACA,+B;AACA,oB;AACA,8C;AACA,I;;AAEA,0C;AACA,oB;;AAEA,2E;AACA,mE;AACA,8C;AACA,mC;AACA,2C;AACA,kD;AACA,8C;AACA,sE;AACA,qB;AACA,a;AACA,K;;AAEA,gE;AACA,0D;AACA,wE;;AAEA,kC;AACA,+E;AACA,+E;AACA,wB;AACA,mE;AACA,qB;AACA,a;AACA,K;;AAEA,kD;AACA,yD;AACA,6E;AACA,6E;AACA,oE;AACA,oD;AACA,gC;AACA,yD;AACA,kB;AACA,O;AACA,I;AACA,K;AACA,yC;AACA,I;AACA,8C;AACA,8C;AACA,4B;AACA,I;AACA,gE;AACA,0E;AACA,8C;AACA,I;AACA,yD;AACA,mE;AACA,oE;AACA,sB;AACA,I;AACA,wB;AACA,kE;AACA,oE;AACA,mE;AACA,uC;AACA,K;;AAEA,K;AACA,mC;AACA,qB;AACA,kB;AACA,qJ;AACA,qQ;AACA,K;AACA,8C;AACA,oB;;AAEA,4B;;AAEA,gD;AACA,uE;AACA,a;AACA,K;;AAEA,kD;AACA,iE;AACA,gE;AACA,kE;AACA,+D;AACA,kE;AACA,kE;AACA,6C;AACA,2C;AACA,6C;AACA,sB;AACA,yE;AACA,2E;AACA,yE;AACA,2C;AACA,Q;AACA,kE;AACA,Q;AACA,sC;AACA,Q;AACA,gF;AACA,0D;AACA,O;AACA,K;;AAEA,a;AACA,4C;AACA,U;AACA,oD;AACA,wE;AACA,6E;AACA,+D;AACA,gD;AACA,kD;AACA,4B;AACA,gD;AACA,mB;AACA,S;AACA,S;AACA,K;AACA,I;;AAEA,sC;AACA,oB;AACA,oC;AACA,uC;AACA,K;AACA,I;;AAEA,K;AACA,gF;AACA,oB;AACA,6F;AACA,qB;AACA,K;AACA,+B;AACA,oB;AACA,2C;AACA,qC;AACA,4E;AACA,wC;AACA,O;AACA,I;;AAEA,0C;AACA,oE;AACA,4C;AACA,wD;AACA,mE;AACA,gC;AACA,4C;AACA,I;;AAEA,qC;AACA,wC;AACA,mD;AACA,oB;;AAEA,2E;AACA,gC;AACA,qD;AACA,yB;AACA,mB;AACA,K;AACA,4B;;AAEA,iB;AACA,mE;AACA,sE;AACA,+B;AACA,yD;AACA,wC;AACA,iB;AACA,sD;AACA,Q;;AAEA,sB;AACA,6C;AACA,kB;AACA,mB;AACA,4D;AACA,Y;AACA,qE;AACA,gE;AACA,+B;AACA,wB;AACA,kC;AACA,kF;AACA,Q;AACA,4B;AACA,2D;AACA,8B;AACA,0C;AACA,sC;AACA,8C;AACA,U;AACA,kD;AACA,O;;AAEA,6C;AACA,4B;AACA,uB;AACA,6B;AACA,+B;AACA,wD;AACA,S;AACA,W;AACA,+E;AACA,0C;AACA,0E;AACA,0B;AACA,W;AACA,qC;AACA,mB;AACA,sB;AACA,O;AACA,K;;AAEA,+E;AACA,4E;AACA,gF;AACA,6E;AACA,mD;AACA,mB;AACA,kC;AACA,uB;AACA,K;AACA,kB;AACA,sB;AACA,kB;AACA,I;;AAEA,wC;AACA,oB;AACA,2C;AACA,gB;AACA,gC;AACA,Q;AACA,kB;AACA,G;AACA,G;;AAEA,yD;AACA,2D;AACA,2E;AACA,wD;AACA,K;AACA,wB;AACA,gD;AACA,G;AACA,wB;AACA,E;;AAEA,iD;;;AAGA,8E;AACA,uB;AACA,2D;AACA,sD;AACA,qB;;AAEA,4E;AACA,e;AACA,4B;AACA,2D;AACA,mC;AACA,kG;AACA,sB;AACA,K;AACA,G;;AAEA,gF;AACA,yE;AACA,8E;AACA,qB;AACA,iC;AACA,yD;AACA,sC;AACA,+E;AACA,qD;AACA,G;;AAEA,wD;AACA,E;;;AAGA,8E;AACA,oC;AACA,yE;AACA,oB;AACA,yC;AACA,kD;AACA,qC;AACA,G;AACA,gC;AACA,E;;;;;;;;;;;;;;;;;;;ACjlDA,+B;AACA,wD;;AAEA,oE;AACA,iE;AACA,kE;AACA,E;AACA,qC;AACA,kB;;AAEA,qB;AACA,qB;AACA,uB;AACA,8B;AACA,iC;AACA,E;;AAEA,qE;AACA,sE;AACA,gB;AACA,E;AACA,8D;;AAEA,2C;AACA,sE;AACA,mE;AACA,qE;AACA,sE;AACA,6D;AACA,2B;AACA,oB;;AAEA,qB;AACA,2C;;AAEA,mB;AACA,+E;;AAEA,8B;AACA,0B;AACA,Y;AACA,8B;AACA,sB;AACA,sE;AACA,yB;AACA,kC;AACA,0B;AACA,O;AACA,M;AACA,I;;AAEA,kE;AACA,0C;AACA,oB;AACA,oB;AACA,oD;AACA,iD;AACA,sB;AACA,sB;AACA,I;;AAEA,2D;AACA,mC;AACA,oB;AACA,mB;AACA,qE;AACA,wC;AACA,yC;AACA,I;;AAEA,sE;AACA,2B;AACA,oB;AACA,4B;AACA,qC;AACA,yB;AACA,O;AACA,e;AACA,kB;AACA,I;;AAEA,2B;AACA,oB;AACA,mB;AACA,wD;AACA,iD;AACA,wB;AACA,iE;AACA,qC;AACA,K;AACA,I;;AAEA,oE;AACA,uC;AACA,uB;AACA,oB;AACA,qB;AACA,iE;AACA,wB;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACpGA,8E;AACA,yE;AACA,4E;;AAEA,0C;AACA,kB;AACA,0B;;AAEA,kB;AACA,gF;AACA,gC;AACA,kC;AACA,uD;AACA,2C;AACA,E;;AAEA,yC;AACA,iE;AACA,0D;AACA,kE;AACA,6B;AACA,I;AACA,8D;AACA,2C;AACA,I;AACA,iE;AACA,c;AACA,wC;AACA,oB;AACA,2B;;AAEA,kD;AACA,+C;AACA,K;;AAEA,4E;AACA,qE;AACA,0D;AACA,kD;AACA,K;AACA,wD;;AAEA,yC;AACA,8C;AACA,4C;AACA,K;;AAEA,Y;AACA,yB;AACA,6C;AACA,kD;AACA,iD;AACA,S;AACA,0D;AACA,gE;AACA,wD;AACA,S;AACA,O;AACA,M;AACA,I;;AAEA,gE;AACA,sE;AACA,gC;AACA,I;AACA,+D;AACA,sE;AACA,I;AACA,oE;AACA,iC;AACA,oB;;AAEA,uD;AACA,oD;AACA,K;;AAEA,qE;AACA,a;;AAEA,gC;AACA,8D;AACA,yB;AACA,qD;AACA,mD;AACA,6B;AACA,O;AACA,O;;AAEA,+E;AACA,+E;AACA,sE;AACA,2E;AACA,4C;AACA,oE;AACA,+E;AACA,8E;AACA,wC;AACA,uC;AACA,8C;AACA,0D;AACA,O;AACA,O;AACA,I;;AAEA,+E;AACA,I;AACA,c;AACA,qD;AACA,uD;AACA,4B;AACA,8D;AACA,uE;AACA,8D;AACA,uD;AACA,wB;AACA,uE;AACA,2E;AACA,8B;AACA,8E;AACA,yE;AACA,0C;AACA,8C;AACA,8E;AACA,4E;AACA,6E;AACA,sE;AACA,6E;AACA,+C;AACA,0C;AACA,yC;AACA,mB;AACA,K;AACA,+D;AACA,0D;AACA,+C;AACA,mB;AACA,K;;AAEA,wD;AACA,yC;AACA,sD;AACA,O;AACA,G;AACA,G;;AAEA,+E;AACA,2E;AACA,gF;AACA,6E;AACA,4B;AACA,2D;AACA,6C;AACA,G;;;;;;;;;;;;;;;;;;;ACxJA,8D;AACA,2D;AACA,iD;;AAEA,6D;;AAEA,2E;AACA,oB;AACA,G;AACA,6E;AACA,8B;AACA,0B;AACA,qB;AACA,G;AACA,uC;AACA,kB;;AAEA,sE;AACA,qE;AACA,iE;AACA,gE;AACA,wE;AACA,sE;AACA,yC;;AAEA,K;AACA,mG;AACA,oB;AACA,wB;AACA,+B;AACA,c;AACA,oB;AACA,K;AACA,2C;;AAEA,mE;AACA,qE;AACA,c;AACA,oD;AACA,8B;;AAEA,oB;;AAEA,K;AACA,gG;AACA,oB;AACA,kB;AACA,+B;AACA,c;AACA,K;AACA,+B;;AAEA,gE;AACA,yB;AACA,wD;;AAEA,+D;;AAEA,K;AACA,uN;AACA,kB;AACA,sB;AACA,+B;AACA,c;AACA,K;AACA,uC;;AAEA,+C;AACA,uC;;AAEA,uE;AACA,2B;AACA,E;;AAEA,sC;AACA,K;AACA,yH;AACA,kB;AACA,+B;AACA,c;AACA,K;AACA,wB;AACA,oB;AACA,+B;AACA,oB;AACA,I;;AAEA,K;AACA,qC;AACA,kB;AACA,+B;AACA,c;AACA,oG;AACA,K;AACA,+B;AACA,oB;AACA,4B;AACA,gF;AACA,yB;AACA,4B;AACA,G;AACA,G;;AAEA,qC;AACA,O;AACA,wC;AACA,e;AACA,yE;AACA,gB;AACA,G;AACA,kC;AACA,gD;AACA,sE;AACA,gB;AACA,G;;AAEA,6E;;AAEA,qE;AACA,gB;AACA,8B;AACA,8B;AACA,sB;AACA,6C;AACA,uC;AACA,O;AACA,uB;AACA,G;;AAEA,2D;AACA,0B;AACA,+D;AACA,K;;AAEA,a;AACA,E;;AAEA,+B;AACA,8B;AACA,sE;AACA,qB;AACA,6B;AACA,qB;AACA,8C;AACA,gC;AACA,0B;AACA,gC;AACA,O;AACA,O;AACA,4B;AACA,6B;AACA,+B;AACA,yB;AACA,G;AACA,0B;AACA,2D;AACA,2B;AACA,+D;AACA,K;AACA,6C;AACA,kD;AACA,G;AACA,8B;AACA,E;;AAEA,oE;AACA,qE;AACA,gE;AACA,wD;AACA,wD;;;;;;;;;;;;;;;;;;;ACzKA,2E;AACA,E;AACA,4E;AACA,6E;AACA,mE;AACA,E;AACA,4E;AACA,+E;AACA,0E;AACA,+E;AACA,4E;AACA,6E;AACA,E;AACA,+D;AACA,6D;AACA,gE;AACA,8C;AACA,E;AACA,mC;AACA,4D;AACA,2D;AACA,iF;AACA,gF;AACA,mC;AACA,kB;;AAEA,uD;;AAEA,sB;AACA,E;;AAEA,kE;AACA,gE;AACA,wE;AACA,yC;AACA,wB;AACA,8B;AACA,E;;AAEA,6E;AACA,6E;AACA,oE;AACA,mC;AACA,wE;AACA,6E;AACA,0D;AACA,2C;AACA,c;AACA,qB;AACA,G;AACA,e;AACA,oC;AACA,mD;AACA,kB;AACA,G;AACA,wC;AACA,sB;AACA,0D;AACA,4B;AACA,O;AACA,G;AACA,sC;AACA,E;;AAEA,sD;AACA,6E;AACA,+D;AACA,oC;AACA,2C;AACA,uC;AACA,E;;AAEA,qD;AACA,8C;AACA,yD;AACA,uE;AACA,oD;AACA,yE;AACA,gD;AACA,iE;AACA,8B;AACA,E;;AAEA,kC;AACA,kF;AACA,uE;AACA,qE;AACA,8B;AACA,oB;;AAEA,gD;AACA,4B;AACA,gD;AACA,qD;AACA,4C;AACA,8C;AACA,S;AACA,O;AACA,yF;AACA,K;AACA,oB;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACtGA,sB;AACA,iC;AACA,oC;AACA,0D;AACA,C;;AAEA,gD;AACA,2C;AACA,W;AACA,gF;AACA,qE;AACA,gC;AACA,2E;AACA,6E;AACA,E;AACA,qE;AACA,oC;AACA,E;AACA,oE;AACA,iE;AACA,qE;AACA,8D;AACA,8D;AACA,mE;AACA,oE;AACA,+B;AACA,0C;AACA,kB;AACA,sB;AACA,gC;AACA,4D;AACA,iC;AACA,M;AACA,6B;AACA,4B;AACA,0C;AACA,iC;AACA,iD;AACA,gB;AACA,wB;AACA,c;;AAEA,wE;AACA,gF;AACA,gB;AACA,0B;;AAEA,6D;AACA,gC;AACA,uB;AACA,U;AACA,uD;AACA,2B;AACA,+B;AACA,6C;AACA,mE;AACA,oE;AACA,kE;AACA,gE;AACA,gB;AACA,iD;AACA,gD;AACA,O;AACA,G;;AAEA,6B;AACA,oE;AACA,4E;AACA,mD;AACA,4C;AACA,yB;AACA,4D;;AAEA,sD;AACA,oD;;AAEA,2E;AACA,gF;AACA,6E;AACA,0B;AACA,4B;;AAEA,gF;AACA,iB;AACA,I;AACA,0E;AACA,+E;AACA,4E;AACA,+E;AACA,mB;AACA,I;AACA,uD;AACA,+C;AACA,4E;AACA,8B;AACA,I;AACA,gF;AACA,+D;AACA,I;AACA,oE;AACA,+E;AACA,+E;AACA,gF;AACA,6E;AACA,+C;AACA,I;AACA,a;AACA,kC;AACA,mC;AACA,6D;AACA,0D;AACA,4D;AACA,8E;AACA,uE;AACA,6E;AACA,+E;AACA,+E;AACA,0D;AACA,qC;;AAEA,2E;AACA,yE;AACA,gF;AACA,+B;AACA,oC;AACA,8E;AACA,4D;AACA,8E;AACA,gC;AACA,8D;AACA,8E;AACA,6D;AACA,6B;;AAEA,uE;AACA,qB;AACA,uE;AACA,qC;AACA,yE;AACA,gF;AACA,4E;AACA,gB;AACA,kC;;AAEA,gF;AACA,oC;AACA,8E;AACA,8E;AACA,6D;AACA,6E;AACA,gF;AACA,uE;AACA,mD;AACA,I;AACA,iE;;AAEA,+D;AACA,6C;AACA,yE;AACA,yE;AACA,W;AACA,uC;AACA,yE;AACA,wE;AACA,0D;AACA,uE;AACA,gB;AACA,4B;;AAEA,iE;AACA,qC;AACA,kD;AACA,4B;;AAEA,sE;AACA,W;AACA,a;AACA,e;AACA,uE;AACA,uD;AACA,gE;AACA,+E;AACA,0D;AACA,2E;AACA,+E;AACA,2B;;AAEA,qB;AACA,sB;AACA,4C;;AAEA,gE;AACA,4E;AACA,uD;AACA,oC;AACA,+B;AACA,yD;AACA,mC;AACA,qB;AACA,c;AACA,sB;AACA,O;AACA,O;AACA,G;;AAEA,sC;AACA,S;AACA,kC;AACA,iB;AACA,sD;AACA,a;AACA,K;;AAEA,mC;AACA,uE;AACA,wE;AACA,qC;AACA,mC;AACA,kE;AACA,a;AACA,K;;AAEA,kC;AACA,8C;AACA,oC;AACA,4B;AACA,K;AACA,mC;AACA,gE;AACA,8C;AACA,+C;AACA,c;AACA,yB;AACA,wF;AACA,yE;AACA,4D;AACA,O;AACA,K;AACA,kC;AACA,iC;AACA,8C;AACA,0B;AACA,uC;AACA,K;AACA,kC;AACA,4B;AACA,uC;AACA,O;AACA,K;AACA,qF;AACA,+B;AACA,iC;AACA,gC;AACA,kC;AACA,iC;AACA,iC;AACA,gC;AACA,Q;AACA,qE;AACA,I;;AAEA,6B;AACA,6D;AACA,qE;AACA,2C;AACA,+B;AACA,4B;AACA,wC;AACA,2E;AACA,0C;AACA,6C;AACA,oB;;AAEA,oE;AACA,qE;AACA,oE;AACA,4D;AACA,qE;AACA,kE;AACA,0B;;AAEA,gF;AACA,wD;AACA,qD;AACA,8D;AACA,4C;AACA,K;;AAEA,uE;AACA,kB;AACA,+C;AACA,4B;AACA,O;;AAEA,oE;AACA,oE;AACA,oE;AACA,oE;AACA,oB;AACA,yB;AACA,kE;AACA,Q;AACA,qC;;AAEA,wE;AACA,6C;AACA,oD;AACA,kB;AACA,mB;AACA,e;AACA,uB;AACA,0B;AACA,S;AACA,O;AACA,I;;AAEA,kC;AACA,0B;AACA,6B;AACA,6B;AACA,K;AACA,I;;AAEA,wB;AACA,iF;AACA,6E;AACA,uF;AACA,U;AACA,0C;AACA,sC;AACA,gD;AACA,G;AACA,E;;AAEA,gF;AACA,sE;AACA,+E;AACA,2E;AACA,+C;AACA,wC;AACA,kB;;AAEA,sC;AACA,mC;AACA,2B;;AAEA,oC;AACA,wC;AACA,kC;AACA,sE;AACA,4B;AACA,4B;AACA,4B;;AAEA,kC;AACA,yD;AACA,E;AACA,mC;AACA,8E;AACA,oE;AACA,4B;AACA,oB;AACA,8E;AACA,gF;AACA,c;AACA,yB;AACA,uE;;AAEA,8E;AACA,Y;AACA,8B;;AAEA,4B;;AAEA,+E;AACA,Y;AACA,mB;AACA,wE;;AAEA,iC;AACA,0C;AACA,I;AACA,6E;AACA,qC;AACA,qC;AACA,oB;AACA,kD;AACA,4E;AACA,0B;AACA,mE;;AAEA,kC;AACA,6D;;AAEA,+E;AACA,8C;AACA,oD;AACA,K;AACA,I;AACA,2E;AACA,oE;AACA,4E;AACA,2D;AACA,yC;AACA,oB;AACA,yB;AACA,kE;AACA,uC;AACA,wC;AACA,gC;AACA,I;AACA,8E;AACA,uE;AACA,4E;AACA,sE;AACA,4B;AACA,oB;AACA,6B;AACA,gC;AACA,I;AACA,2C;AACA,0B;AACA,oB;AACA,gC;AACA,G;AACA,G;;AAEA,gC;AACA,qE;AACA,gF;AACA,gF;AACA,gD;AACA,oB;;AAEA,6B;AACA,mB;;AAEA,0E;AACA,2C;AACA,mB;AACA,kE;AACA,qD;AACA,2C;AACA,4C;AACA,6E;AACA,qC;AACA,gB;AACA,e;;AAEA,+B;;AAEA,qD;AACA,iB;AACA,8C;AACA,qC;AACA,0B;AACA,S;AACA,wB;AACA,iD;AACA,K;;AAEA,gB;AACA,I;;AAEA,K;AACA,qB;AACA,wE;AACA,oC;AACA,kB;AACA,4E;AACA,+B;AACA,uE;AACA,wB;AACA,wE;AACA,sE;AACA,2E;AACA,6C;AACA,K;AACA,2E;AACA,oB;;AAEA,0D;AACA,uB;AACA,wB;AACA,gD;AACA,oC;AACA,yC;AACA,6B;AACA,wE;AACA,iD;AACA,uE;AACA,0B;AACA,iC;AACA,O;AACA,K;;AAEA,uE;AACA,uE;AACA,4B;AACA,M;AACA,wC;AACA,M;AACA,wC;AACA,yD;AACA,yD;AACA,c;AACA,M;AACA,sE;AACA,oE;AACA,sD;AACA,M;AACA,8E;AACA,4E;AACA,uB;AACA,+D;AACA,iD;AACA,yC;AACA,O;;AAEA,W;AACA,mB;AACA,uB;AACA,8C;;AAEA,8B;AACA,+E;AACA,+E;AACA,6E;AACA,yE;AACA,8C;AACA,4B;AACA,qD;AACA,O;;AAEA,wE;AACA,+C;AACA,8B;AACA,kE;AACA,2B;AACA,mD;AACA,O;;AAEA,6B;AACA,iD;AACA,O;AACA,Y;AACA,oE;AACA,uB;AACA,iC;AACA,e;AACA,mB;AACA,oC;AACA,wB;AACA,qB;AACA,0C;AACA,yC;AACA,iD;AACA,yC;AACA,uC;AACA,yB;AACA,4B;AACA,yD;AACA,iD;AACA,U;AACA,0B;AACA,wD;AACA,wB;;AAEA,iC;AACA,+B;AACA,W;AACA,S;AACA,Q;AACA,mE;AACA,K;;AAEA,0C;AACA,kB;AACA,yB;AACA,4C;AACA,iB;;AAEA,uC;AACA,Q;AACA,0B;AACA,8C;AACA,4C;AACA,uB;AACA,6C;AACA,kC;AACA,4B;AACA,Q;AACA,wB;AACA,M;;AAEA,yB;AACA,8E;AACA,8E;AACA,6E;AACA,uE;AACA,wE;AACA,uB;AACA,yC;AACA,2C;AACA,kD;;AAEA,wC;AACA,+C;AACA,+C;AACA,0B;AACA,W;AACA,S;AACA,K;;AAEA,kB;AACA,I;;AAEA,a;AACA,2F;AACA,mE;AACA,qD;AACA,oB;AACA,yB;AACA,sB;AACA,e;AACA,sB;AACA,e;AACA,4B;AACA,qB;AACA,sB;AACA,Q;AACA,6B;AACA,mB;AACA,wB;AACA,Y;AACA,mE;AACA,O;AACA,O;;AAEA,6D;AACA,a;AACA,kB;AACA,I;;AAEA,+B;AACA,oB;AACA,2C;AACA,qC;AACA,4E;AACA,wC;AACA,O;AACA,I;;AAEA,K;AACA,qB;AACA,+D;AACA,oB;AACA,kD;AACA,gE;AACA,uN;AACA,K;AACA,0D;AACA,oE;AACA,4C;AACA,wD;AACA,mE;AACA,gC;AACA,4C;AACA,I;;AAEA,qC;AACA,4E;AACA,4E;AACA,2D;AACA,+E;AACA,4E;AACA,2E;AACA,2E;AACA,2E;AACA,6E;AACA,6E;AACA,2E;AACA,yE;AACA,4E;AACA,8E;AACA,6E;AACA,6E;AACA,2E;AACA,6D;AACA,wC;;AAEA,K;AACA,qB;AACA,4D;AACA,oB;AACA,kD;AACA,+C;AACA,8B;AACA,wM;AACA,8Q;AACA,6G;AACA,K;AACA,mD;AACA,oB;;AAEA,2E;AACA,gC;AACA,qD;AACA,yB;AACA,mB;AACA,K;AACA,4B;;AAEA,mB;AACA,oE;AACA,oC;AACA,yD;AACA,wC;AACA,iB;AACA,sD;AACA,Q;AACA,K;;AAEA,8E;AACA,uC;AACA,6B;;AAEA,mE;AACA,iC;AACA,a;AACA,0B;AACA,6B;AACA,2C;AACA,kB;AACA,Q;AACA,S;;AAEA,iD;AACA,kE;;AAEA,yE;AACA,8E;AACA,yE;AACA,8D;AACA,+E;AACA,6E;AACA,6E;AACA,wE;AACA,4E;AACA,iD;AACA,0B;AACA,2C;AACA,gC;AACA,kD;AACA,O;AACA,wB;AACA,M;;AAEA,sE;AACA,4E;AACA,0E;AACA,8E;AACA,iD;AACA,M;AACA,yE;AACA,yE;AACA,4E;AACA,wE;AACA,a;;AAEA,0C;AACA,e;AACA,wC;AACA,+B;AACA,Q;;AAEA,6C;AACA,2B;AACA,8B;AACA,6B;AACA,iE;AACA,S;;AAEA,+B;AACA,8B;;AAEA,W;AACA,4E;AACA,8C;AACA,wF;AACA,gC;AACA,4E;AACA,0C;AACA,wD;AACA,4E;AACA,+D;AACA,e;AACA,kB;AACA,6D;AACA,W;AACA,W;AACA,O;AACA,iB;AACA,0B;AACA,O;;AAEA,+B;AACA,oD;AACA,K;;AAEA,oE;AACA,+D;AACA,wC;AACA,8B;AACA,qB;AACA,6C;AACA,yB;AACA,O;AACA,oB;AACA,wB;AACA,6B;AACA,K;;AAEA,gE;AACA,iE;AACA,sD;AACA,M;AACA,oE;AACA,iB;AACA,2C;AACA,2E;AACA,4D;AACA,K;;;AAGA,sE;AACA,iD;;AAEA,+D;AACA,oB;AACA,4B;AACA,sE;AACA,sE;AACA,uE;AACA,0B;AACA,mC;AACA,uE;AACA,4C;AACA,U;AACA,c;AACA,iE;AACA,qC;AACA,gC;AACA,qC;AACA,O;AACA,K;AACA,sE;AACA,yE;AACA,+D;AACA,mB;AACA,oB;AACA,mB;AACA,mB;AACA,oB;AACA,M;;AAEA,6C;AACA,8B;AACA,sC;AACA,K;;AAEA,2C;AACA,2B;AACA,yB;AACA,uB;AACA,iD;AACA,2B;AACA,sB;AACA,O;;AAEA,uB;AACA,gE;AACA,yC;AACA,gD;AACA,Y;AACA,8E;AACA,wD;AACA,qD;AACA,qD;AACA,uE;AACA,wE;AACA,K;;AAEA,0D;AACA,mD;AACA,kC;;AAEA,yD;AACA,oC;AACA,iB;AACA,2B;AACA,K;AACA,iE;AACA,I;;AAEA,gF;AACA,uE;AACA,e;AACA,+B;AACA,oB;AACA,uC;AACA,wB;AACA,O;AACA,I;AACA,8E;AACA,gF;AACA,mE;AACA,mD;AACA,oB;AACA,+C;AACA,0E;;AAEA,yB;AACA,mD;AACA,4C;AACA,gD;AACA,qB;AACA,e;AACA,4C;AACA,2D;AACA,sD;AACA,yE;AACA,6E;AACA,uC;AACA,+E;AACA,2B;AACA,oD;AACA,gB;AACA,mE;AACA,mC;AACA,wC;AACA,wC;AACA,oD;AACA,S;AACA,S;AACA,O;AACA,kC;AACA,2D;AACA,K;AACA,I;;AAEA,kE;AACA,wD;AACA,gC;AACA,oB;AACA,6D;AACA,qE;AACA,sD;AACA,Q;AACA,mE;AACA,mE;AACA,oD;AACA,4D;AACA,uC;AACA,O;AACA,O;AACA,I;;AAEA,8D;AACA,yB;AACA,oB;AACA,yC;AACA,I;;AAEA,6D;AACA,mE;AACA,mC;AACA,qC;AACA,oB;AACA,wC;AACA,I;;AAEA,K;AACA,wE;AACA,kB;AACA,qB;AACA,K;AACA,2C;AACA,oB;AACA,8D;AACA,I;;AAEA,K;AACA,mG;;AAEA,8D;AACA,kB;AACA,qB;AACA,K;AACA,8C;AACA,oB;AACA,iE;AACA,I;;AAEA,K;AACA,oD;AACA,kB;AACA,qB;AACA,K;AACA,+C;AACA,oB;AACA,kE;AACA,I;;AAEA,sB;AACA,oB;AACA,uD;AACA,I;;AAEA,K;AACA,0B;AACA,K;AACA,uB;AACA,oB;AACA,yB;AACA,gC;AACA,wB;AACA,I;;AAEA,gC;AACA,oB;AACA,+E;AACA,gC;AACA,a;AACA,0B;AACA,yB;AACA,iC;AACA,I;;AAEA,gF;AACA,2E;AACA,6B;AACA,sC;AACA,oB;AACA,kD;AACA,0D;AACA,I;;AAEA,6E;AACA,uC;AACA,0C;AACA,oB;AACA,+D;AACA,I;;AAEA,uC;AACA,oB;;AAEA,oE;AACA,uC;AACA,mD;AACA,iD;AACA,gC;AACA,+B;AACA,gE;AACA,U;AACA,+B;AACA,oC;AACA,S;AACA,S;AACA,8B;AACA,K;;AAEA,8D;AACA,4B;AACA,+B;;AAEA,4C;AACA,+E;AACA,wC;AACA,K;;AAEA,uC;AACA,+E;AACA,4E;AACA,gF;AACA,+E;AACA,0E;AACA,a;AACA,K;;AAEA,oE;;AAEA,+E;AACA,mC;AACA,uC;;AAEA,4B;AACA,8E;AACA,gB;AACA,wC;AACA,iC;AACA,K;;AAEA,mC;AACA,oC;;AAEA,8E;AACA,gD;AACA,gF;AACA,qE;AACA,gC;AACA,oD;AACA,oB;AACA,0C;AACA,O;;AAEA,2E;AACA,uE;AACA,uC;AACA,M;AACA,wE;AACA,gF;AACA,4D;AACA,yC;AACA,4B;AACA,uD;AACA,kC;AACA,gF;AACA,0E;AACA,4E;AACA,0E;AACA,gF;AACA,yC;AACA,4E;AACA,8E;AACA,8D;AACA,Y;AACA,6E;AACA,uE;AACA,+E;AACA,2E;AACA,+B;AACA,mE;AACA,S;AACA,S;AACA,K;;AAEA,+C;;AAEA,+E;AACA,sC;AACA,wC;AACA,8B;AACA,2C;AACA,iC;AACA,wB;AACA,W;AACA,kC;AACA,O;AACA,sC;AACA,K;AACA,I;;;AAGA,mD;AACA,oB;AACA,6D;AACA,8C;AACA,I;;;AAGA,kC;AACA,oB;;AAEA,2C;AACA,qB;;AAEA,uC;AACA,sD;;AAEA,8B;AACA,8C;;AAEA,+C;AACA,6C;AACA,S;AACA,qD;AACA,yD;AACA,S;;AAEA,uC;AACA,e;;AAEA,oD;AACA,8E;AACA,oC;AACA,4E;AACA,0D;AACA,S;AACA,iD;AACA,Y;AACA,gD;AACA,K;;AAEA,mD;AACA,oD;AACA,oD;AACA,gF;AACA,yC;AACA,S;AACA,gC;;AAEA,4D;AACA,4C;AACA,oB;AACA,2D;AACA,wC;AACA,a;AACA,gB;AACA,gE;AACA,8B;AACA,oE;AACA,qE;AACA,gD;AACA,+D;AACA,0D;AACA,8E;AACA,qD;AACA,S;AACA,S;;AAEA,gC;AACA,4D;AACA,K;;AAEA,oC;AACA,I;;AAEA,2E;AACA,yE;AACA,+B;AACA,yC;AACA,oB;AACA,+C;AACA,oC;AACA,oC;AACA,U;AACA,O;AACA,I;;AAEA,oD;AACA,oB;AACA,sC;AACA,+B;AACA,K;AACA,kC;AACA,I;;AAEA,4C;AACA,oB;AACA,kD;AACA,kB;AACA,oE;AACA,mD;AACA,I;;AAEA,2C;AACA,oB;AACA,8C;AACA,2D;AACA,oB;AACA,0C;AACA,2C;AACA,sE;AACA,4C;AACA,kC;AACA,Y;AACA,qD;AACA,K;AACA,I;;AAEA,6C;AACA,oB;AACA,uC;AACA,wD;AACA,oB;AACA,2C;AACA,6E;AACA,oE;AACA,Y;AACA,qD;AACA,K;AACA,I;;AAEA,6C;AACA,oB;AACA,uC;AACA,wD;AACA,oB;AACA,0C;AACA,2C;AACA,4E;AACA,qC;AACA,Y;AACA,iD;AACA,uB;AACA,mC;AACA,kB;AACA,S;AACA,K;AACA,I;;AAEA,6C;AACA,oB;AACA,sC;AACA,6C;AACA,yE;AACA,2E;AACA,uB;AACA,2E;AACA,gD;AACA,4D;AACA,iE;AACA,kD;AACA,kD;AACA,6E;AACA,8E;AACA,+E;AACA,wC;;AAEA,yE;AACA,+E;AACA,uE;AACA,yD;AACA,2B;AACA,yD;AACA,uC;AACA,a;AACA,sC;AACA,yD;AACA,gB;AACA,a;;AAEA,2E;AACA,6E;AACA,gE;AACA,uE;AACA,S;AACA,S;AACA,oD;;AAEA,gF;AACA,iD;AACA,2D;AACA,2B;AACA,sE;AACA,2C;AACA,8D;AACA,O;AACA,I;;AAEA,2C;AACA,oB;AACA,2E;AACA,wE;AACA,4D;AACA,uC;AACA,wD;AACA,mD;AACA,sC;AACA,uB;AACA,iB;AACA,0D;AACA,4B;AACA,iB;AACA,6D;AACA,+B;AACA,sC;AACA,S;AACA,O;AACA,I;;AAEA,qE;AACA,gF;AACA,2C;AACA,iD;AACA,oB;AACA,wC;AACA,yC;AACA,M;AACA,oC;AACA,wC;AACA,gC;AACA,0C;AACA,6E;AACA,6B;AACA,2B;AACA,O;AACA,M;AACA,6D;AACA,mD;AACA,2D;AACA,gE;AACA,yD;AACA,kD;AACA,a;AACA,qD;AACA,oC;AACA,0D;AACA,S;AACA,S;AACA,O;AACA,wC;AACA,gF;AACA,qC;AACA,yB;AACA,K;AACA,I;;AAEA,mC;AACA,oB;;AAEA,2E;AACA,0B;AACA,6B;;AAEA,yD;AACA,kC;;AAEA,2D;AACA,4C;AACA,a;;AAEA,6C;AACA,kE;AACA,gE;;AAEA,yC;;AAEA,gD;AACA,wD;AACA,uE;AACA,K;;AAEA,6C;AACA,qC;AACA,6C;AACA,K;;AAEA,uB;AACA,4C;AACA,K;AACA,I;;AAEA,+B;AACA,2E;AACA,4E;AACA,sE;AACA,yE;AACA,e;AACA,I;;AAEA,oC;AACA,mE;;AAEA,oB;;AAEA,mC;AACA,uD;AACA,mD;AACA,yE;AACA,a;AACA,K;AACA,sE;AACA,U;AACA,yD;AACA,gC;AACA,gC;AACA,c;AACA,K;;AAEA,a;AACA,gF;AACA,a;AACA,K;;AAEA,+E;AACA,gF;AACA,kC;AACA,oC;;AAEA,8B;AACA,uC;AACA,0C;AACA,4B;AACA,Y;AACA,kE;AACA,c;AACA,6C;AACA,K;AACA,I;;AAEA,+E;AACA,8E;AACA,mE;AACA,2C;AACA,oB;AACA,yC;AACA,a;;AAEA,2E;AACA,0E;AACA,kD;AACA,qD;AACA,6D;AACA,0C;AACA,uE;AACA,oD;;AAEA,6D;AACA,oD;AACA,uC;AACA,K;;AAEA,oC;AACA,yB;AACA,I;;AAEA,6D;AACA,8B;AACA,uC;AACA,oB;AACA,iD;AACA,a;AACA,mE;AACA,sB;AACA,O;AACA,I;;AAEA,mC;AACA,8D;AACA,6B;AACA,mD;AACA,I;;AAEA,oE;AACA,oB;AACA,mE;AACA,uC;;AAEA,uB;;AAEA,8C;AACA,a;;AAEA,yE;AACA,4E;AACA,+D;AACA,mD;AACA,iE;AACA,qC;AACA,a;AACA,K;;AAEA,gF;AACA,6E;AACA,yC;AACA,sD;AACA,8C;AACA,kE;AACA,8D;;AAEA,0E;AACA,uD;AACA,0B;AACA,S;;AAEA,yC;AACA,K;;AAEA,kD;AACA,yD;AACA,gD;AACA,O;AACA,I;;AAEA,qE;AACA,+B;AACA,oB;AACA,2C;AACA,I;;AAEA,2E;AACA,kE;AACA,8B;AACA,oB;AACA,uD;AACA,2B;AACA,gC;AACA,K;AACA,G;AACA,G;;AAEA,qC;;AAEA,yC;AACA,Y;AACA,8B;AACA,qC;AACA,W;AACA,qD;;AAEA,G;AACA,oI;AACA,kB;AACA,6D;AACA,G;AACA,uC;AACA,yC;AACA,+C;AACA,a;AACA,E;;AAEA,kE;AACA,iC;AACA,E;AACA,oB;AACA,0C;AACA,gD;AACA,sD;AACA,uB;AACA,O;AACA,K;AACA,E;;;;;;;;;;;;;;;;;;;AClmDA,sE;AACA,4C;AACA,E;AACA,gF;AACA,8E;AACA,mD;AACA,E;AACA,6E;AACA,gF;AACA,6E;AACA,2E;AACA,mB;AACA,qB;AACA,+C;AACA,0D;AACA,6C;AACA,G;;AAEA,6B;;AAEA,4C;AACA,uD;AACA,I;;AAEA,0D;AACA,kC;AACA,iE;AACA,0B;AACA,qE;AACA,Y;AACA,Q;AACA,wC;AACA,uB;AACA,4C;AACA,I;;AAEA,mE;AACA,qD;AACA,gD;AACA,uB;AACA,uC;AACA,S;AACA,C;;AAEA,iE;AACA,gE;AACA,wB;AACA,sC\",\"file\":\"/packages/ddp.js\",\"sourcesContent\":[\"/**\\n * @namespace DDP\\n * @summary The namespace for DDP-related methods.\\n */\\nDDP = {};\\nLivedataTest = {};\\n\",\"// @param endpoint {String} URL to Meteor app\\n//   \\\"http://subdomain.meteor.com/\\\" or \\\"/\\\" or\\n//   \\\"ddp+sockjs://foo-**.meteor.com/sockjs\\\"\\n//\\n// We do some rewriting of the URL to eventually make it \\\"ws://\\\" or \\\"wss://\\\",\\n// whatever was passed in.  At the very least, what Meteor.absoluteUrl() returns\\n// us should work.\\n//\\n// We don't do any heartbeating. (The logic that did this in sockjs was removed,\\n// because it used a built-in sockjs mechanism. We could do it with WebSocket\\n// ping frames or with DDP-level messages.)\\nLivedataTest.ClientStream = function (endpoint, options) {\\n  var self = this;\\n  options = options || {};\\n\\n  self.options = _.extend({\\n    retry: true\\n  }, options);\\n\\n  self.client = null;  // created in _launchConnection\\n  self.endpoint = endpoint;\\n\\n  self.headers = self.options.headers || {};\\n\\n  self._initCommon(self.options);\\n\\n  //// Kickoff!\\n  self._launchConnection();\\n};\\n\\n_.extend(LivedataTest.ClientStream.prototype, {\\n\\n  // data is a utf8 string. Data sent while not connected is dropped on\\n  // the floor, and it is up the user of this API to retransmit lost\\n  // messages on 'reset'\\n  send: function (data) {\\n    var self = this;\\n    if (self.currentStatus.connected) {\\n      self.client.send(data);\\n    }\\n  },\\n\\n  // Changes where this connection points\\n  _changeUrl: function (url) {\\n    var self = this;\\n    self.endpoint = url;\\n  },\\n\\n  _onConnect: function (client) {\\n    var self = this;\\n\\n    if (client !== self.client) {\\n      // This connection is not from the last call to _launchConnection.\\n      // But _launchConnection calls _cleanup which closes previous connections.\\n      // It's our belief that this stifles future 'open' events, but maybe\\n      // we are wrong?\\n      throw new Error(\\\"Got open from inactive client \\\" + !!self.client);\\n    }\\n\\n    if (self._forcedToDisconnect) {\\n      // We were asked to disconnect between trying to open the connection and\\n      // actually opening it. Let's just pretend this never happened.\\n      self.client.close();\\n      self.client = null;\\n      return;\\n    }\\n\\n    if (self.currentStatus.connected) {\\n      // We already have a connection. It must have been the case that we\\n      // started two parallel connection attempts (because we wanted to\\n      // 'reconnect now' on a hanging connection and we had no way to cancel the\\n      // connection attempt.) But this shouldn't happen (similarly to the client\\n      // !== self.client check above).\\n      throw new Error(\\\"Two parallel connections?\\\");\\n    }\\n\\n    self._clearConnectionTimer();\\n\\n    // update status\\n    self.currentStatus.status = \\\"connected\\\";\\n    self.currentStatus.connected = true;\\n    self.currentStatus.retryCount = 0;\\n    self.statusChanged();\\n\\n    // fire resets. This must come after status change so that clients\\n    // can call send from within a reset callback.\\n    _.each(self.eventCallbacks.reset, function (callback) { callback(); });\\n  },\\n\\n  _cleanup: function (maybeError) {\\n    var self = this;\\n\\n    self._clearConnectionTimer();\\n    if (self.client) {\\n      var client = self.client;\\n      self.client = null;\\n      client.close();\\n\\n      _.each(self.eventCallbacks.disconnect, function (callback) {\\n        callback(maybeError);\\n      });\\n    }\\n  },\\n\\n  _clearConnectionTimer: function () {\\n    var self = this;\\n\\n    if (self.connectionTimer) {\\n      clearTimeout(self.connectionTimer);\\n      self.connectionTimer = null;\\n    }\\n  },\\n\\n  _getProxyUrl: function (targetUrl) {\\n    var self = this;\\n    // Similar to code in tools/http-helpers.js.\\n    var proxy = process.env.HTTP_PROXY || process.env.http_proxy || null;\\n    // if we're going to a secure url, try the https_proxy env variable first.\\n    if (targetUrl.match(/^wss:/)) {\\n      proxy = process.env.HTTPS_PROXY || process.env.https_proxy || proxy;\\n    }\\n    return proxy;\\n  },\\n\\n  _launchConnection: function () {\\n    var self = this;\\n    self._cleanup(); // cleanup the old socket, if there was one.\\n\\n    // Since server-to-server DDP is still an experimental feature, we only\\n    // require the module if we actually create a server-to-server\\n    // connection.\\n    var FayeWebSocket = Npm.require('faye-websocket');\\n\\n    var targetUrl = toWebsocketUrl(self.endpoint);\\n    var fayeOptions = { headers: self.headers };\\n    var proxyUrl = self._getProxyUrl(targetUrl);\\n    if (proxyUrl) {\\n      fayeOptions.proxy = { origin: proxyUrl };\\n    };\\n\\n    // We would like to specify 'ddp' as the subprotocol here. The npm module we\\n    // used to use as a client would fail the handshake if we ask for a\\n    // subprotocol and the server doesn't send one back (and sockjs doesn't).\\n    // Faye doesn't have that behavior; it's unclear from reading RFC 6455 if\\n    // Faye is erroneous or not.  So for now, we don't specify protocols.\\n    var subprotocols = [];\\n\\n    var client = self.client = new FayeWebSocket.Client(\\n      targetUrl, subprotocols, fayeOptions);\\n\\n    self._clearConnectionTimer();\\n    self.connectionTimer = Meteor.setTimeout(\\n      function () {\\n        self._lostConnection(\\n          new DDP.ConnectionError(\\\"DDP connection timed out\\\"));\\n      },\\n      self.CONNECT_TIMEOUT);\\n\\n    self.client.on('open', Meteor.bindEnvironment(function () {\\n      return self._onConnect(client);\\n    }, \\\"stream connect callback\\\"));\\n\\n    var clientOnIfCurrent = function (event, description, f) {\\n      self.client.on(event, Meteor.bindEnvironment(function () {\\n        // Ignore events from any connection we've already cleaned up.\\n        if (client !== self.client)\\n          return;\\n        f.apply(this, arguments);\\n      }, description));\\n    };\\n\\n    clientOnIfCurrent('error', 'stream error callback', function (error) {\\n      if (!self.options._dontPrintErrors)\\n        Meteor._debug(\\\"stream error\\\", error.message);\\n\\n      // Faye's 'error' object is not a JS error (and among other things,\\n      // doesn't stringify well). Convert it to one.\\n      self._lostConnection(new DDP.ConnectionError(error.message));\\n    });\\n\\n\\n    clientOnIfCurrent('close', 'stream close callback', function () {\\n      self._lostConnection();\\n    });\\n\\n\\n    clientOnIfCurrent('message', 'stream message callback', function (message) {\\n      // Ignore binary frames, where message.data is a Buffer\\n      if (typeof message.data !== \\\"string\\\")\\n        return;\\n\\n      _.each(self.eventCallbacks.message, function (callback) {\\n        callback(message.data);\\n      });\\n    });\\n  }\\n});\\n\",\"// XXX from Underscore.String (http://epeli.github.com/underscore.string/)\\nvar startsWith = function(str, starts) {\\n  return str.length >= starts.length &&\\n    str.substring(0, starts.length) === starts;\\n};\\nvar endsWith = function(str, ends) {\\n  return str.length >= ends.length &&\\n    str.substring(str.length - ends.length) === ends;\\n};\\n\\n// @param url {String} URL to Meteor app, eg:\\n//   \\\"/\\\" or \\\"madewith.meteor.com\\\" or \\\"https://foo.meteor.com\\\"\\n//   or \\\"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\\\"\\n// @returns {String} URL to the endpoint with the specific scheme and subPath, e.g.\\n// for scheme \\\"http\\\" and subPath \\\"sockjs\\\"\\n//   \\\"http://subdomain.meteor.com/sockjs\\\" or \\\"/sockjs\\\"\\n//   or \\\"https://ddp--1234-foo.meteor.com/sockjs\\\"\\nvar translateUrl =  function(url, newSchemeBase, subPath) {\\n  if (! newSchemeBase) {\\n    newSchemeBase = \\\"http\\\";\\n  }\\n\\n  var ddpUrlMatch = url.match(/^ddp(i?)\\\\+sockjs:\\\\/\\\\//);\\n  var httpUrlMatch = url.match(/^http(s?):\\\\/\\\\//);\\n  var newScheme;\\n  if (ddpUrlMatch) {\\n    // Remove scheme and split off the host.\\n    var urlAfterDDP = url.substr(ddpUrlMatch[0].length);\\n    newScheme = ddpUrlMatch[1] === \\\"i\\\" ? newSchemeBase : newSchemeBase + \\\"s\\\";\\n    var slashPos = urlAfterDDP.indexOf('/');\\n    var host =\\n          slashPos === -1 ? urlAfterDDP : urlAfterDDP.substr(0, slashPos);\\n    var rest = slashPos === -1 ? '' : urlAfterDDP.substr(slashPos);\\n\\n    // In the host (ONLY!), change '*' characters into random digits. This\\n    // allows different stream connections to connect to different hostnames\\n    // and avoid browser per-hostname connection limits.\\n    host = host.replace(/\\\\*/g, function () {\\n      return Math.floor(Random.fraction()*10);\\n    });\\n\\n    return newScheme + '://' + host + rest;\\n  } else if (httpUrlMatch) {\\n    newScheme = !httpUrlMatch[1] ? newSchemeBase : newSchemeBase + \\\"s\\\";\\n    var urlAfterHttp = url.substr(httpUrlMatch[0].length);\\n    url = newScheme + \\\"://\\\" + urlAfterHttp;\\n  }\\n\\n  // Prefix FQDNs but not relative URLs\\n  if (url.indexOf(\\\"://\\\") === -1 && !startsWith(url, \\\"/\\\")) {\\n    url = newSchemeBase + \\\"://\\\" + url;\\n  }\\n\\n  // XXX This is not what we should be doing: if I have a site\\n  // deployed at \\\"/foo\\\", then DDP.connect(\\\"/\\\") should actually connect\\n  // to \\\"/\\\", not to \\\"/foo\\\". \\\"/\\\" is an absolute path. (Contrast: if\\n  // deployed at \\\"/foo\\\", it would be reasonable for DDP.connect(\\\"bar\\\")\\n  // to connect to \\\"/foo/bar\\\").\\n  //\\n  // We should make this properly honor absolute paths rather than\\n  // forcing the path to be relative to the site root. Simultaneously,\\n  // we should set DDP_DEFAULT_CONNECTION_URL to include the site\\n  // root. See also client_convenience.js #RationalizingRelativeDDPURLs\\n  url = Meteor._relativeToSiteRootUrl(url);\\n\\n  if (endsWith(url, \\\"/\\\"))\\n    return url + subPath;\\n  else\\n    return url + \\\"/\\\" + subPath;\\n};\\n\\ntoSockjsUrl = function (url) {\\n  return translateUrl(url, \\\"http\\\", \\\"sockjs\\\");\\n};\\n\\ntoWebsocketUrl = function (url) {\\n  var ret = translateUrl(url, \\\"ws\\\", \\\"websocket\\\");\\n  return ret;\\n};\\n\\nLivedataTest.toSockjsUrl = toSockjsUrl;\\n\\n\\n_.extend(LivedataTest.ClientStream.prototype, {\\n\\n  // Register for callbacks.\\n  on: function (name, callback) {\\n    var self = this;\\n\\n    if (name !== 'message' && name !== 'reset' && name !== 'disconnect')\\n      throw new Error(\\\"unknown event type: \\\" + name);\\n\\n    if (!self.eventCallbacks[name])\\n      self.eventCallbacks[name] = [];\\n    self.eventCallbacks[name].push(callback);\\n  },\\n\\n\\n  _initCommon: function (options) {\\n    var self = this;\\n    options = options || {};\\n\\n    //// Constants\\n\\n    // how long to wait until we declare the connection attempt\\n    // failed.\\n    self.CONNECT_TIMEOUT = options.connectTimeoutMs || 10000;\\n\\n    self.eventCallbacks = {}; // name -> [callback]\\n\\n    self._forcedToDisconnect = false;\\n\\n    //// Reactive status\\n    self.currentStatus = {\\n      status: \\\"connecting\\\",\\n      connected: false,\\n      retryCount: 0\\n    };\\n\\n\\n    self.statusListeners = typeof Tracker !== 'undefined' && new Tracker.Dependency;\\n    self.statusChanged = function () {\\n      if (self.statusListeners)\\n        self.statusListeners.changed();\\n    };\\n\\n    //// Retry logic\\n    self._retry = new Retry;\\n    self.connectionTimer = null;\\n\\n  },\\n\\n  // Trigger a reconnect.\\n  reconnect: function (options) {\\n    var self = this;\\n    options = options || {};\\n\\n    if (options.url) {\\n      self._changeUrl(options.url);\\n    }\\n\\n    if (options._sockjsOptions) {\\n      self.options._sockjsOptions = options._sockjsOptions;\\n    }\\n\\n    if (self.currentStatus.connected) {\\n      if (options._force || options.url) {\\n        // force reconnect.\\n        self._lostConnection(new DDP.ForcedReconnectError);\\n      } // else, noop.\\n      return;\\n    }\\n\\n    // if we're mid-connection, stop it.\\n    if (self.currentStatus.status === \\\"connecting\\\") {\\n      // Pretend it's a clean close.\\n      self._lostConnection();\\n    }\\n\\n    self._retry.clear();\\n    self.currentStatus.retryCount -= 1; // don't count manual retries\\n    self._retryNow();\\n  },\\n\\n  disconnect: function (options) {\\n    var self = this;\\n    options = options || {};\\n\\n    // Failed is permanent. If we're failed, don't let people go back\\n    // online by calling 'disconnect' then 'reconnect'.\\n    if (self._forcedToDisconnect)\\n      return;\\n\\n    // If _permanent is set, permanently disconnect a stream. Once a stream\\n    // is forced to disconnect, it can never reconnect. This is for\\n    // error cases such as ddp version mismatch, where trying again\\n    // won't fix the problem.\\n    if (options._permanent) {\\n      self._forcedToDisconnect = true;\\n    }\\n\\n    self._cleanup();\\n    self._retry.clear();\\n\\n    self.currentStatus = {\\n      status: (options._permanent ? \\\"failed\\\" : \\\"offline\\\"),\\n      connected: false,\\n      retryCount: 0\\n    };\\n\\n    if (options._permanent && options._error)\\n      self.currentStatus.reason = options._error;\\n\\n    self.statusChanged();\\n  },\\n\\n  // maybeError is set unless it's a clean protocol-level close.\\n  _lostConnection: function (maybeError) {\\n    var self = this;\\n\\n    self._cleanup(maybeError);\\n    self._retryLater(maybeError); // sets status. no need to do it here.\\n  },\\n\\n  // fired when we detect that we've gone online. try to reconnect\\n  // immediately.\\n  _online: function () {\\n    // if we've requested to be offline by disconnecting, don't reconnect.\\n    if (this.currentStatus.status != \\\"offline\\\")\\n      this.reconnect();\\n  },\\n\\n  _retryLater: function (maybeError) {\\n    var self = this;\\n\\n    var timeout = 0;\\n    if (self.options.retry ||\\n        (maybeError && maybeError.errorType === \\\"DDP.ForcedReconnectError\\\")) {\\n      timeout = self._retry.retryLater(\\n        self.currentStatus.retryCount,\\n        _.bind(self._retryNow, self)\\n      );\\n      self.currentStatus.status = \\\"waiting\\\";\\n      self.currentStatus.retryTime = (new Date()).getTime() + timeout;\\n    } else {\\n      self.currentStatus.status = \\\"failed\\\";\\n      delete self.currentStatus.retryTime;\\n    }\\n\\n    self.currentStatus.connected = false;\\n    self.statusChanged();\\n  },\\n\\n  _retryNow: function () {\\n    var self = this;\\n\\n    if (self._forcedToDisconnect)\\n      return;\\n\\n    self.currentStatus.retryCount += 1;\\n    self.currentStatus.status = \\\"connecting\\\";\\n    self.currentStatus.connected = false;\\n    delete self.currentStatus.retryTime;\\n    self.statusChanged();\\n\\n    self._launchConnection();\\n  },\\n\\n\\n  // Get current status. Reactive.\\n  status: function () {\\n    var self = this;\\n    if (self.statusListeners)\\n      self.statusListeners.depend();\\n    return self.currentStatus;\\n  }\\n});\\n\\nDDP.ConnectionError = Meteor.makeErrorType(\\n  \\\"DDP.ConnectionError\\\", function (message) {\\n    var self = this;\\n    self.message = message;\\n});\\n\\nDDP.ForcedReconnectError = Meteor.makeErrorType(\\n  \\\"DDP.ForcedReconnectError\\\", function () {});\\n\",\"var url = Npm.require('url');\\n\\nvar pathPrefix = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX ||  \\\"\\\";\\n\\nStreamServer = function () {\\n  var self = this;\\n  self.registration_callbacks = [];\\n  self.open_sockets = [];\\n\\n  // Because we are installing directly onto WebApp.httpServer instead of using\\n  // WebApp.app, we have to process the path prefix ourselves.\\n  self.prefix = pathPrefix + '/sockjs';\\n  // routepolicy is only a weak dependency, because we don't need it if we're\\n  // just doing server-to-server DDP as a client.\\n  if (Package.routepolicy) {\\n    Package.routepolicy.RoutePolicy.declare(self.prefix + '/', 'network');\\n  }\\n\\n  // set up sockjs\\n  var sockjs = Npm.require('sockjs');\\n  var serverOptions = {\\n    prefix: self.prefix,\\n    log: function() {},\\n    // this is the default, but we code it explicitly because we depend\\n    // on it in stream_client:HEARTBEAT_TIMEOUT\\n    heartbeat_delay: 45000,\\n    // The default disconnect_delay is 5 seconds, but if the server ends up CPU\\n    // bound for that much time, SockJS might not notice that the user has\\n    // reconnected because the timer (of disconnect_delay ms) can fire before\\n    // SockJS processes the new connection. Eventually we'll fix this by not\\n    // combining CPU-heavy processing with SockJS termination (eg a proxy which\\n    // converts to Unix sockets) but for now, raise the delay.\\n    disconnect_delay: 60 * 1000,\\n    // Set the USE_JSESSIONID environment variable to enable setting the\\n    // JSESSIONID cookie. This is useful for setting up proxies with\\n    // session affinity.\\n    jsessionid: !!process.env.USE_JSESSIONID\\n  };\\n\\n  // If you know your server environment (eg, proxies) will prevent websockets\\n  // from ever working, set $DISABLE_WEBSOCKETS and SockJS clients (ie,\\n  // browsers) will not waste time attempting to use them.\\n  // (Your server will still have a /websocket endpoint.)\\n  if (process.env.DISABLE_WEBSOCKETS)\\n    serverOptions.websocket = false;\\n\\n  self.server = sockjs.createServer(serverOptions);\\n  if (!Package.webapp) {\\n    throw new Error(\\\"Cannot create a DDP server without the webapp package\\\");\\n  }\\n  // Install the sockjs handlers, but we want to keep around our own particular\\n  // request handler that adjusts idle timeouts while we have an outstanding\\n  // request.  This compensates for the fact that sockjs removes all listeners\\n  // for \\\"request\\\" to add its own.\\n  Package.webapp.WebApp.httpServer.removeListener('request', Package.webapp.WebApp._timeoutAdjustmentRequestCallback);\\n  self.server.installHandlers(Package.webapp.WebApp.httpServer);\\n  Package.webapp.WebApp.httpServer.addListener('request', Package.webapp.WebApp._timeoutAdjustmentRequestCallback);\\n\\n  // Support the /websocket endpoint\\n  self._redirectWebsocketEndpoint();\\n\\n  self.server.on('connection', function (socket) {\\n    socket.send = function (data) {\\n      socket.write(data);\\n    };\\n    socket.on('close', function () {\\n      self.open_sockets = _.without(self.open_sockets, socket);\\n    });\\n    self.open_sockets.push(socket);\\n\\n    // XXX COMPAT WITH 0.6.6. Send the old style welcome message, which\\n    // will force old clients to reload. Remove this once we're not\\n    // concerned about people upgrading from a pre-0.7.0 release. Also,\\n    // remove the clause in the client that ignores the welcome message\\n    // (livedata_connection.js)\\n    socket.send(JSON.stringify({server_id: \\\"0\\\"}));\\n\\n    // call all our callbacks when we get a new socket. they will do the\\n    // work of setting up handlers and such for specific messages.\\n    _.each(self.registration_callbacks, function (callback) {\\n      callback(socket);\\n    });\\n  });\\n\\n};\\n\\n_.extend(StreamServer.prototype, {\\n  // call my callback when a new socket connects.\\n  // also call it for all current connections.\\n  register: function (callback) {\\n    var self = this;\\n    self.registration_callbacks.push(callback);\\n    _.each(self.all_sockets(), function (socket) {\\n      callback(socket);\\n    });\\n  },\\n\\n  // get a list of all sockets\\n  all_sockets: function () {\\n    var self = this;\\n    return _.values(self.open_sockets);\\n  },\\n\\n  // Redirect /websocket to /sockjs/websocket in order to not expose\\n  // sockjs to clients that want to use raw websockets\\n  _redirectWebsocketEndpoint: function() {\\n    var self = this;\\n    // Unfortunately we can't use a connect middleware here since\\n    // sockjs installs itself prior to all existing listeners\\n    // (meaning prior to any connect middlewares) so we need to take\\n    // an approach similar to overshadowListeners in\\n    // https://github.com/sockjs/sockjs-node/blob/cf820c55af6a9953e16558555a31decea554f70e/src/utils.coffee\\n    _.each(['request', 'upgrade'], function(event) {\\n      var httpServer = Package.webapp.WebApp.httpServer;\\n      var oldHttpServerListeners = httpServer.listeners(event).slice(0);\\n      httpServer.removeAllListeners(event);\\n\\n      // request and upgrade have different arguments passed but\\n      // we only care about the first one which is always request\\n      var newListener = function(request /*, moreArguments */) {\\n        // Store arguments for use within the closure below\\n        var args = arguments;\\n\\n        // Rewrite /websocket and /websocket/ urls to /sockjs/websocket while\\n        // preserving query string.\\n        var parsedUrl = url.parse(request.url);\\n        if (parsedUrl.pathname === pathPrefix + '/websocket' ||\\n            parsedUrl.pathname === pathPrefix + '/websocket/') {\\n          parsedUrl.pathname = self.prefix + '/websocket';\\n          request.url = url.format(parsedUrl);\\n        }\\n        _.each(oldHttpServerListeners, function(oldListener) {\\n          oldListener.apply(httpServer, args);\\n        });\\n      };\\n      httpServer.addListener(event, newListener);\\n    });\\n  }\\n});\\n\",\"// Heartbeat options:\\n//   heartbeatInterval: interval to send pings, in milliseconds.\\n//   heartbeatTimeout: timeout to close the connection if a reply isn't\\n//     received, in milliseconds.\\n//   sendPing: function to call to send a ping on the connection.\\n//   onTimeout: function to call to close the connection.\\n\\nHeartbeat = function (options) {\\n  var self = this;\\n\\n  self.heartbeatInterval = options.heartbeatInterval;\\n  self.heartbeatTimeout = options.heartbeatTimeout;\\n  self._sendPing = options.sendPing;\\n  self._onTimeout = options.onTimeout;\\n\\n  self._heartbeatIntervalHandle = null;\\n  self._heartbeatTimeoutHandle = null;\\n};\\n\\n_.extend(Heartbeat.prototype, {\\n  stop: function () {\\n    var self = this;\\n    self._clearHeartbeatIntervalTimer();\\n    self._clearHeartbeatTimeoutTimer();\\n  },\\n\\n  start: function () {\\n    var self = this;\\n    self.stop();\\n    self._startHeartbeatIntervalTimer();\\n  },\\n\\n  _startHeartbeatIntervalTimer: function () {\\n    var self = this;\\n    self._heartbeatIntervalHandle = Meteor.setTimeout(\\n      _.bind(self._heartbeatIntervalFired, self),\\n      self.heartbeatInterval\\n    );\\n  },\\n\\n  _startHeartbeatTimeoutTimer: function () {\\n    var self = this;\\n    self._heartbeatTimeoutHandle = Meteor.setTimeout(\\n      _.bind(self._heartbeatTimeoutFired, self),\\n      self.heartbeatTimeout\\n    );\\n  },\\n\\n  _clearHeartbeatIntervalTimer: function () {\\n    var self = this;\\n    if (self._heartbeatIntervalHandle) {\\n      Meteor.clearTimeout(self._heartbeatIntervalHandle);\\n      self._heartbeatIntervalHandle = null;\\n    }\\n  },\\n\\n  _clearHeartbeatTimeoutTimer: function () {\\n    var self = this;\\n    if (self._heartbeatTimeoutHandle) {\\n      Meteor.clearTimeout(self._heartbeatTimeoutHandle);\\n      self._heartbeatTimeoutHandle = null;\\n    }\\n  },\\n\\n  // The heartbeat interval timer is fired when we should send a ping.\\n  _heartbeatIntervalFired: function () {\\n    var self = this;\\n    self._heartbeatIntervalHandle = null;\\n    self._sendPing();\\n    // Wait for a pong.\\n    self._startHeartbeatTimeoutTimer();\\n  },\\n\\n  // The heartbeat timeout timer is fired when we sent a ping, but we\\n  // timed out waiting for the pong.\\n  _heartbeatTimeoutFired: function () {\\n    var self = this;\\n    self._heartbeatTimeoutHandle = null;\\n    self._onTimeout();\\n  },\\n\\n  pingReceived: function () {\\n    var self = this;\\n    // We know the connection is alive if we receive a ping, so we\\n    // don't need to send a ping ourselves.  Reset the interval timer.\\n    if (self._heartbeatIntervalHandle) {\\n      self._clearHeartbeatIntervalTimer();\\n      self._startHeartbeatIntervalTimer();\\n    }\\n  },\\n\\n  pongReceived: function () {\\n    var self = this;\\n\\n    // Receiving a pong means we won't timeout, so clear the timeout\\n    // timer and start the interval again.\\n    if (self._heartbeatTimeoutHandle) {\\n      self._clearHeartbeatTimeoutTimer();\\n      self._startHeartbeatIntervalTimer();\\n    }\\n  }\\n});\\n\",\"DDPServer = {};\\n\\nvar Fiber = Npm.require('fibers');\\n\\n// This file contains classes:\\n// * Session - The server's connection to a single DDP client\\n// * Subscription - A single subscription for a single client\\n// * Server - An entire server that may talk to > 1 client. A DDP endpoint.\\n//\\n// Session and Subscription are file scope. For now, until we freeze\\n// the interface, Server is package scope (in the future it should be\\n// exported.)\\n\\n// Represents a single document in a SessionCollectionView\\nvar SessionDocumentView = function () {\\n  var self = this;\\n  self.existsIn = {}; // set of subscriptionHandle\\n  self.dataByKey = {}; // key-> [ {subscriptionHandle, value} by precedence]\\n};\\n\\n_.extend(SessionDocumentView.prototype, {\\n\\n  getFields: function () {\\n    var self = this;\\n    var ret = {};\\n    _.each(self.dataByKey, function (precedenceList, key) {\\n      ret[key] = precedenceList[0].value;\\n    });\\n    return ret;\\n  },\\n\\n  clearField: function (subscriptionHandle, key, changeCollector) {\\n    var self = this;\\n    // Publish API ignores _id if present in fields\\n    if (key === \\\"_id\\\")\\n      return;\\n    var precedenceList = self.dataByKey[key];\\n\\n    // It's okay to clear fields that didn't exist. No need to throw\\n    // an error.\\n    if (!precedenceList)\\n      return;\\n\\n    var removedValue = undefined;\\n    for (var i = 0; i < precedenceList.length; i++) {\\n      var precedence = precedenceList[i];\\n      if (precedence.subscriptionHandle === subscriptionHandle) {\\n        // The view's value can only change if this subscription is the one that\\n        // used to have precedence.\\n        if (i === 0)\\n          removedValue = precedence.value;\\n        precedenceList.splice(i, 1);\\n        break;\\n      }\\n    }\\n    if (_.isEmpty(precedenceList)) {\\n      delete self.dataByKey[key];\\n      changeCollector[key] = undefined;\\n    } else if (removedValue !== undefined &&\\n               !EJSON.equals(removedValue, precedenceList[0].value)) {\\n      changeCollector[key] = precedenceList[0].value;\\n    }\\n  },\\n\\n  changeField: function (subscriptionHandle, key, value,\\n                         changeCollector, isAdd) {\\n    var self = this;\\n    // Publish API ignores _id if present in fields\\n    if (key === \\\"_id\\\")\\n      return;\\n\\n    // Don't share state with the data passed in by the user.\\n    value = EJSON.clone(value);\\n\\n    if (!_.has(self.dataByKey, key)) {\\n      self.dataByKey[key] = [{subscriptionHandle: subscriptionHandle,\\n                              value: value}];\\n      changeCollector[key] = value;\\n      return;\\n    }\\n    var precedenceList = self.dataByKey[key];\\n    var elt;\\n    if (!isAdd) {\\n      elt = _.find(precedenceList, function (precedence) {\\n        return precedence.subscriptionHandle === subscriptionHandle;\\n      });\\n    }\\n\\n    if (elt) {\\n      if (elt === precedenceList[0] && !EJSON.equals(value, elt.value)) {\\n        // this subscription is changing the value of this field.\\n        changeCollector[key] = value;\\n      }\\n      elt.value = value;\\n    } else {\\n      // this subscription is newly caring about this field\\n      precedenceList.push({subscriptionHandle: subscriptionHandle, value: value});\\n    }\\n\\n  }\\n});\\n\\n/**\\n * Represents a client's view of a single collection\\n * @param {String} collectionName Name of the collection it represents\\n * @param {Object.<String, Function>} sessionCallbacks The callbacks for added, changed, removed\\n * @class SessionCollectionView\\n */\\nvar SessionCollectionView = function (collectionName, sessionCallbacks) {\\n  var self = this;\\n  self.collectionName = collectionName;\\n  self.documents = {};\\n  self.callbacks = sessionCallbacks;\\n};\\n\\nLivedataTest.SessionCollectionView = SessionCollectionView;\\n\\n\\n_.extend(SessionCollectionView.prototype, {\\n\\n  isEmpty: function () {\\n    var self = this;\\n    return _.isEmpty(self.documents);\\n  },\\n\\n  diff: function (previous) {\\n    var self = this;\\n    LocalCollection._diffObjects(previous.documents, self.documents, {\\n      both: _.bind(self.diffDocument, self),\\n\\n      rightOnly: function (id, nowDV) {\\n        self.callbacks.added(self.collectionName, id, nowDV.getFields());\\n      },\\n\\n      leftOnly: function (id, prevDV) {\\n        self.callbacks.removed(self.collectionName, id);\\n      }\\n    });\\n  },\\n\\n  diffDocument: function (id, prevDV, nowDV) {\\n    var self = this;\\n    var fields = {};\\n    LocalCollection._diffObjects(prevDV.getFields(), nowDV.getFields(), {\\n      both: function (key, prev, now) {\\n        if (!EJSON.equals(prev, now))\\n          fields[key] = now;\\n      },\\n      rightOnly: function (key, now) {\\n        fields[key] = now;\\n      },\\n      leftOnly: function(key, prev) {\\n        fields[key] = undefined;\\n      }\\n    });\\n    self.callbacks.changed(self.collectionName, id, fields);\\n  },\\n\\n  added: function (subscriptionHandle, id, fields) {\\n    var self = this;\\n    var docView = self.documents[id];\\n    var added = false;\\n    if (!docView) {\\n      added = true;\\n      docView = new SessionDocumentView();\\n      self.documents[id] = docView;\\n    }\\n    docView.existsIn[subscriptionHandle] = true;\\n    var changeCollector = {};\\n    _.each(fields, function (value, key) {\\n      docView.changeField(\\n        subscriptionHandle, key, value, changeCollector, true);\\n    });\\n    if (added)\\n      self.callbacks.added(self.collectionName, id, changeCollector);\\n    else\\n      self.callbacks.changed(self.collectionName, id, changeCollector);\\n  },\\n\\n  changed: function (subscriptionHandle, id, changed) {\\n    var self = this;\\n    var changedResult = {};\\n    var docView = self.documents[id];\\n    if (!docView)\\n      throw new Error(\\\"Could not find element with id \\\" + id + \\\" to change\\\");\\n    _.each(changed, function (value, key) {\\n      if (value === undefined)\\n        docView.clearField(subscriptionHandle, key, changedResult);\\n      else\\n        docView.changeField(subscriptionHandle, key, value, changedResult);\\n    });\\n    self.callbacks.changed(self.collectionName, id, changedResult);\\n  },\\n\\n  removed: function (subscriptionHandle, id) {\\n    var self = this;\\n    var docView = self.documents[id];\\n    if (!docView) {\\n      var err = new Error(\\\"Removed nonexistent document \\\" + id);\\n      throw err;\\n    }\\n    delete docView.existsIn[subscriptionHandle];\\n    if (_.isEmpty(docView.existsIn)) {\\n      // it is gone from everyone\\n      self.callbacks.removed(self.collectionName, id);\\n      delete self.documents[id];\\n    } else {\\n      var changed = {};\\n      // remove this subscription from every precedence list\\n      // and record the changes\\n      _.each(docView.dataByKey, function (precedenceList, key) {\\n        docView.clearField(subscriptionHandle, key, changed);\\n      });\\n\\n      self.callbacks.changed(self.collectionName, id, changed);\\n    }\\n  }\\n});\\n\\n/******************************************************************************/\\n/* Session                                                                    */\\n/******************************************************************************/\\n\\nvar Session = function (server, version, socket, options) {\\n  var self = this;\\n  self.id = Random.id();\\n\\n  self.server = server;\\n  self.version = version;\\n\\n  self.initialized = false;\\n  self.socket = socket;\\n\\n  // set to null when the session is destroyed. multiple places below\\n  // use this to determine if the session is alive or not.\\n  self.inQueue = new Meteor._DoubleEndedQueue();\\n\\n  self.blocked = false;\\n  self.workerRunning = false;\\n\\n  // Sub objects for active subscriptions\\n  self._namedSubs = {};\\n  self._universalSubs = [];\\n\\n  self.userId = null;\\n\\n  self.collectionViews = {};\\n\\n  // Set this to false to not send messages when collectionViews are\\n  // modified. This is done when rerunning subs in _setUserId and those messages\\n  // are calculated via a diff instead.\\n  self._isSending = true;\\n\\n  // If this is true, don't start a newly-created universal publisher on this\\n  // session. The session will take care of starting it when appropriate.\\n  self._dontStartNewUniversalSubs = false;\\n\\n  // when we are rerunning subscriptions, any ready messages\\n  // we want to buffer up for when we are done rerunning subscriptions\\n  self._pendingReady = [];\\n\\n  // List of callbacks to call when this connection is closed.\\n  self._closeCallbacks = [];\\n\\n\\n  // XXX HACK: If a sockjs connection, save off the URL. This is\\n  // temporary and will go away in the near future.\\n  self._socketUrl = socket.url;\\n\\n  // Allow tests to disable responding to pings.\\n  self._respondToPings = options.respondToPings;\\n\\n  // This object is the public interface to the session. In the public\\n  // API, it is called the `connection` object.  Internally we call it\\n  // a `connectionHandle` to avoid ambiguity.\\n  self.connectionHandle = {\\n    id: self.id,\\n    close: function () {\\n      self.close();\\n    },\\n    onClose: function (fn) {\\n      var cb = Meteor.bindEnvironment(fn, \\\"connection onClose callback\\\");\\n      if (self.inQueue) {\\n        self._closeCallbacks.push(cb);\\n      } else {\\n        // if we're already closed, call the callback.\\n        Meteor.defer(cb);\\n      }\\n    },\\n    clientAddress: self._clientAddress(),\\n    httpHeaders: self.socket.headers\\n  };\\n\\n  socket.send(stringifyDDP({msg: 'connected',\\n                            session: self.id}));\\n  // On initial connect, spin up all the universal publishers.\\n  Fiber(function () {\\n    self.startUniversalSubs();\\n  }).run();\\n\\n  if (version !== 'pre1' && options.heartbeatInterval !== 0) {\\n    self.heartbeat = new Heartbeat({\\n      heartbeatInterval: options.heartbeatInterval,\\n      heartbeatTimeout: options.heartbeatTimeout,\\n      onTimeout: function () {\\n        self.close();\\n      },\\n      sendPing: function () {\\n        self.send({msg: 'ping'});\\n      }\\n    });\\n    self.heartbeat.start();\\n  }\\n\\n  Package.facts && Package.facts.Facts.incrementServerFact(\\n    \\\"livedata\\\", \\\"sessions\\\", 1);\\n};\\n\\n_.extend(Session.prototype, {\\n\\n  sendReady: function (subscriptionIds) {\\n    var self = this;\\n    if (self._isSending)\\n      self.send({msg: \\\"ready\\\", subs: subscriptionIds});\\n    else {\\n      _.each(subscriptionIds, function (subscriptionId) {\\n        self._pendingReady.push(subscriptionId);\\n      });\\n    }\\n  },\\n\\n  sendAdded: function (collectionName, id, fields) {\\n    var self = this;\\n    if (self._isSending)\\n      self.send({msg: \\\"added\\\", collection: collectionName, id: id, fields: fields});\\n  },\\n\\n  sendChanged: function (collectionName, id, fields) {\\n    var self = this;\\n    if (_.isEmpty(fields))\\n      return;\\n\\n    if (self._isSending) {\\n      self.send({\\n        msg: \\\"changed\\\",\\n        collection: collectionName,\\n        id: id,\\n        fields: fields\\n      });\\n    }\\n  },\\n\\n  sendRemoved: function (collectionName, id) {\\n    var self = this;\\n    if (self._isSending)\\n      self.send({msg: \\\"removed\\\", collection: collectionName, id: id});\\n  },\\n\\n  getSendCallbacks: function () {\\n    var self = this;\\n    return {\\n      added: _.bind(self.sendAdded, self),\\n      changed: _.bind(self.sendChanged, self),\\n      removed: _.bind(self.sendRemoved, self)\\n    };\\n  },\\n\\n  getCollectionView: function (collectionName) {\\n    var self = this;\\n    if (_.has(self.collectionViews, collectionName)) {\\n      return self.collectionViews[collectionName];\\n    }\\n    var ret = new SessionCollectionView(collectionName,\\n                                        self.getSendCallbacks());\\n    self.collectionViews[collectionName] = ret;\\n    return ret;\\n  },\\n\\n  added: function (subscriptionHandle, collectionName, id, fields) {\\n    var self = this;\\n    var view = self.getCollectionView(collectionName);\\n    view.added(subscriptionHandle, id, fields);\\n  },\\n\\n  removed: function (subscriptionHandle, collectionName, id) {\\n    var self = this;\\n    var view = self.getCollectionView(collectionName);\\n    view.removed(subscriptionHandle, id);\\n    if (view.isEmpty()) {\\n      delete self.collectionViews[collectionName];\\n    }\\n  },\\n\\n  changed: function (subscriptionHandle, collectionName, id, fields) {\\n    var self = this;\\n    var view = self.getCollectionView(collectionName);\\n    view.changed(subscriptionHandle, id, fields);\\n  },\\n\\n  startUniversalSubs: function () {\\n    var self = this;\\n    // Make a shallow copy of the set of universal handlers and start them. If\\n    // additional universal publishers start while we're running them (due to\\n    // yielding), they will run separately as part of Server.publish.\\n    var handlers = _.clone(self.server.universal_publish_handlers);\\n    _.each(handlers, function (handler) {\\n      self._startSubscription(handler);\\n    });\\n  },\\n\\n  // Destroy this session and unregister it at the server.\\n  close: function () {\\n    var self = this;\\n\\n    // Destroy this session, even if it's not registered at the\\n    // server. Stop all processing and tear everything down. If a socket\\n    // was attached, close it.\\n\\n    // Already destroyed.\\n    if (! self.inQueue)\\n      return;\\n\\n    // Drop the merge box data immediately.\\n    self.inQueue = null;\\n    self.collectionViews = {};\\n\\n    if (self.heartbeat) {\\n      self.heartbeat.stop();\\n      self.heartbeat = null;\\n    }\\n\\n    if (self.socket) {\\n      self.socket.close();\\n      self.socket._meteorSession = null;\\n    }\\n\\n    Package.facts && Package.facts.Facts.incrementServerFact(\\n      \\\"livedata\\\", \\\"sessions\\\", -1);\\n\\n    Meteor.defer(function () {\\n      // stop callbacks can yield, so we defer this on close.\\n      // sub._isDeactivated() detects that we set inQueue to null and\\n      // treats it as semi-deactivated (it will ignore incoming callbacks, etc).\\n      self._deactivateAllSubscriptions();\\n\\n      // Defer calling the close callbacks, so that the caller closing\\n      // the session isn't waiting for all the callbacks to complete.\\n      _.each(self._closeCallbacks, function (callback) {\\n        callback();\\n      });\\n    });\\n\\n    // Unregister the session.\\n    self.server._removeSession(self);\\n  },\\n\\n  // Send a message (doing nothing if no socket is connected right now.)\\n  // It should be a JSON object (it will be stringified.)\\n  send: function (msg) {\\n    var self = this;\\n    if (self.socket) {\\n      if (Meteor._printSentDDP)\\n        Meteor._debug(\\\"Sent DDP\\\", stringifyDDP(msg));\\n      self.socket.send(stringifyDDP(msg));\\n    }\\n  },\\n\\n  // Send a connection error.\\n  sendError: function (reason, offendingMessage) {\\n    var self = this;\\n    var msg = {msg: 'error', reason: reason};\\n    if (offendingMessage)\\n      msg.offendingMessage = offendingMessage;\\n    self.send(msg);\\n  },\\n\\n  // Process 'msg' as an incoming message. (But as a guard against\\n  // race conditions during reconnection, ignore the message if\\n  // 'socket' is not the currently connected socket.)\\n  //\\n  // We run the messages from the client one at a time, in the order\\n  // given by the client. The message handler is passed an idempotent\\n  // function 'unblock' which it may call to allow other messages to\\n  // begin running in parallel in another fiber (for example, a method\\n  // that wants to yield.) Otherwise, it is automatically unblocked\\n  // when it returns.\\n  //\\n  // Actually, we don't have to 'totally order' the messages in this\\n  // way, but it's the easiest thing that's correct. (unsub needs to\\n  // be ordered against sub, methods need to be ordered against each\\n  // other.)\\n  processMessage: function (msg_in) {\\n    var self = this;\\n    if (!self.inQueue) // we have been destroyed.\\n      return;\\n\\n    // Respond to ping and pong messages immediately without queuing.\\n    // If the negotiated DDP version is \\\"pre1\\\" which didn't support\\n    // pings, preserve the \\\"pre1\\\" behavior of responding with a \\\"bad\\n    // request\\\" for the unknown messages.\\n    //\\n    // Fibers are needed because heartbeat uses Meteor.setTimeout, which\\n    // needs a Fiber. We could actually use regular setTimeout and avoid\\n    // these new fibers, but it is easier to just make everything use\\n    // Meteor.setTimeout and not think too hard.\\n    if (self.version !== 'pre1' && msg_in.msg === 'ping') {\\n      if (self._respondToPings)\\n        self.send({msg: \\\"pong\\\", id: msg_in.id});\\n      if (self.heartbeat)\\n        Fiber(function () {\\n          self.heartbeat.pingReceived();\\n        }).run();\\n      return;\\n    }\\n    if (self.version !== 'pre1' && msg_in.msg === 'pong') {\\n      if (self.heartbeat)\\n        Fiber(function () {\\n          self.heartbeat.pongReceived();\\n        }).run();\\n      return;\\n    }\\n\\n    self.inQueue.push(msg_in);\\n    if (self.workerRunning)\\n      return;\\n    self.workerRunning = true;\\n\\n    var processNext = function () {\\n      var msg = self.inQueue && self.inQueue.shift();\\n      if (!msg) {\\n        self.workerRunning = false;\\n        return;\\n      }\\n\\n      Fiber(function () {\\n        var blocked = true;\\n\\n        var unblock = function () {\\n          if (!blocked)\\n            return; // idempotent\\n          blocked = false;\\n          processNext();\\n        };\\n\\n        if (_.has(self.protocol_handlers, msg.msg))\\n          self.protocol_handlers[msg.msg].call(self, msg, unblock);\\n        else\\n          self.sendError('Bad request', msg);\\n        unblock(); // in case the handler didn't already do it\\n      }).run();\\n    };\\n\\n    processNext();\\n  },\\n\\n  protocol_handlers: {\\n    sub: function (msg) {\\n      var self = this;\\n\\n      // reject malformed messages\\n      if (typeof (msg.id) !== \\\"string\\\" ||\\n          typeof (msg.name) !== \\\"string\\\" ||\\n          (('params' in msg) && !(msg.params instanceof Array))) {\\n        self.sendError(\\\"Malformed subscription\\\", msg);\\n        return;\\n      }\\n\\n      if (!self.server.publish_handlers[msg.name]) {\\n        self.send({\\n          msg: 'nosub', id: msg.id,\\n          error: new Meteor.Error(404, \\\"Subscription not found\\\")});\\n        return;\\n      }\\n\\n      if (_.has(self._namedSubs, msg.id))\\n        // subs are idempotent, or rather, they are ignored if a sub\\n        // with that id already exists. this is important during\\n        // reconnect.\\n        return;\\n\\n      var handler = self.server.publish_handlers[msg.name];\\n      self._startSubscription(handler, msg.id, msg.params, msg.name);\\n\\n    },\\n\\n    unsub: function (msg) {\\n      var self = this;\\n\\n      self._stopSubscription(msg.id);\\n    },\\n\\n    method: function (msg, unblock) {\\n      var self = this;\\n\\n      // reject malformed messages\\n      // For now, we silently ignore unknown attributes,\\n      // for forwards compatibility.\\n      if (typeof (msg.id) !== \\\"string\\\" ||\\n          typeof (msg.method) !== \\\"string\\\" ||\\n          (('params' in msg) && !(msg.params instanceof Array)) ||\\n          (('randomSeed' in msg) && (typeof msg.randomSeed !== \\\"string\\\"))) {\\n        self.sendError(\\\"Malformed method invocation\\\", msg);\\n        return;\\n      }\\n\\n      var randomSeed = msg.randomSeed || null;\\n\\n      // set up to mark the method as satisfied once all observers\\n      // (and subscriptions) have reacted to any writes that were\\n      // done.\\n      var fence = new DDPServer._WriteFence;\\n      fence.onAllCommitted(function () {\\n        // Retire the fence so that future writes are allowed.\\n        // This means that callbacks like timers are free to use\\n        // the fence, and if they fire before it's armed (for\\n        // example, because the method waits for them) their\\n        // writes will be included in the fence.\\n        fence.retire();\\n        self.send({\\n          msg: 'updated', methods: [msg.id]});\\n      });\\n\\n      // find the handler\\n      var handler = self.server.method_handlers[msg.method];\\n      if (!handler) {\\n        self.send({\\n          msg: 'result', id: msg.id,\\n          error: new Meteor.Error(404, \\\"Method not found\\\")});\\n        fence.arm();\\n        return;\\n      }\\n\\n      var setUserId = function(userId) {\\n        self._setUserId(userId);\\n      };\\n\\n      var invocation = new MethodInvocation({\\n        isSimulation: false,\\n        userId: self.userId,\\n        setUserId: setUserId,\\n        unblock: unblock,\\n        connection: self.connectionHandle,\\n        randomSeed: randomSeed\\n      });\\n      try {\\n        var result = DDPServer._CurrentWriteFence.withValue(fence, function () {\\n          return DDP._CurrentInvocation.withValue(invocation, function () {\\n            return maybeAuditArgumentChecks(\\n              handler, invocation, msg.params, \\\"call to '\\\" + msg.method + \\\"'\\\");\\n          });\\n        });\\n      } catch (e) {\\n        var exception = e;\\n      }\\n\\n      fence.arm(); // we're done adding writes to the fence\\n      unblock(); // unblock, if the method hasn't done it already\\n\\n      exception = wrapInternalException(\\n        exception, \\\"while invoking method '\\\" + msg.method + \\\"'\\\");\\n\\n      // send response and add to cache\\n      var payload =\\n        exception ? {error: exception} : (result !== undefined ?\\n                                          {result: result} : {});\\n      self.send(_.extend({msg: 'result', id: msg.id}, payload));\\n    }\\n  },\\n\\n  _eachSub: function (f) {\\n    var self = this;\\n    _.each(self._namedSubs, f);\\n    _.each(self._universalSubs, f);\\n  },\\n\\n  _diffCollectionViews: function (beforeCVs) {\\n    var self = this;\\n    LocalCollection._diffObjects(beforeCVs, self.collectionViews, {\\n      both: function (collectionName, leftValue, rightValue) {\\n        rightValue.diff(leftValue);\\n      },\\n      rightOnly: function (collectionName, rightValue) {\\n        _.each(rightValue.documents, function (docView, id) {\\n          self.sendAdded(collectionName, id, docView.getFields());\\n        });\\n      },\\n      leftOnly: function (collectionName, leftValue) {\\n        _.each(leftValue.documents, function (doc, id) {\\n          self.sendRemoved(collectionName, id);\\n        });\\n      }\\n    });\\n  },\\n\\n  // Sets the current user id in all appropriate contexts and reruns\\n  // all subscriptions\\n  _setUserId: function(userId) {\\n    var self = this;\\n\\n    if (userId !== null && typeof userId !== \\\"string\\\")\\n      throw new Error(\\\"setUserId must be called on string or null, not \\\" +\\n                      typeof userId);\\n\\n    // Prevent newly-created universal subscriptions from being added to our\\n    // session; they will be found below when we call startUniversalSubs.\\n    //\\n    // (We don't have to worry about named subscriptions, because we only add\\n    // them when we process a 'sub' message. We are currently processing a\\n    // 'method' message, and the method did not unblock, because it is illegal\\n    // to call setUserId after unblock. Thus we cannot be concurrently adding a\\n    // new named subscription.)\\n    self._dontStartNewUniversalSubs = true;\\n\\n    // Prevent current subs from updating our collectionViews and call their\\n    // stop callbacks. This may yield.\\n    self._eachSub(function (sub) {\\n      sub._deactivate();\\n    });\\n\\n    // All subs should now be deactivated. Stop sending messages to the client,\\n    // save the state of the published collections, reset to an empty view, and\\n    // update the userId.\\n    self._isSending = false;\\n    var beforeCVs = self.collectionViews;\\n    self.collectionViews = {};\\n    self.userId = userId;\\n\\n    // Save the old named subs, and reset to having no subscriptions.\\n    var oldNamedSubs = self._namedSubs;\\n    self._namedSubs = {};\\n    self._universalSubs = [];\\n\\n    _.each(oldNamedSubs, function (sub, subscriptionId) {\\n      self._namedSubs[subscriptionId] = sub._recreate();\\n      // nb: if the handler throws or calls this.error(), it will in fact\\n      // immediately send its 'nosub'. This is OK, though.\\n      self._namedSubs[subscriptionId]._runHandler();\\n    });\\n\\n    // Allow newly-created universal subs to be started on our connection in\\n    // parallel with the ones we're spinning up here, and spin up universal\\n    // subs.\\n    self._dontStartNewUniversalSubs = false;\\n    self.startUniversalSubs();\\n\\n    // Start sending messages again, beginning with the diff from the previous\\n    // state of the world to the current state. No yields are allowed during\\n    // this diff, so that other changes cannot interleave.\\n    Meteor._noYieldsAllowed(function () {\\n      self._isSending = true;\\n      self._diffCollectionViews(beforeCVs);\\n      if (!_.isEmpty(self._pendingReady)) {\\n        self.sendReady(self._pendingReady);\\n        self._pendingReady = [];\\n      }\\n    });\\n  },\\n\\n  _startSubscription: function (handler, subId, params, name) {\\n    var self = this;\\n\\n    var sub = new Subscription(\\n      self, handler, subId, params, name);\\n    if (subId)\\n      self._namedSubs[subId] = sub;\\n    else\\n      self._universalSubs.push(sub);\\n\\n    sub._runHandler();\\n  },\\n\\n  // tear down specified subscription\\n  _stopSubscription: function (subId, error) {\\n    var self = this;\\n\\n    var subName = null;\\n\\n    if (subId && self._namedSubs[subId]) {\\n      subName = self._namedSubs[subId]._name;\\n      self._namedSubs[subId]._removeAllDocuments();\\n      self._namedSubs[subId]._deactivate();\\n      delete self._namedSubs[subId];\\n    }\\n\\n    var response = {msg: 'nosub', id: subId};\\n\\n    if (error) {\\n      response.error = wrapInternalException(\\n        error,\\n        subName ? (\\\"from sub \\\" + subName + \\\" id \\\" + subId)\\n          : (\\\"from sub id \\\" + subId));\\n    }\\n\\n    self.send(response);\\n  },\\n\\n  // tear down all subscriptions. Note that this does NOT send removed or nosub\\n  // messages, since we assume the client is gone.\\n  _deactivateAllSubscriptions: function () {\\n    var self = this;\\n\\n    _.each(self._namedSubs, function (sub, id) {\\n      sub._deactivate();\\n    });\\n    self._namedSubs = {};\\n\\n    _.each(self._universalSubs, function (sub) {\\n      sub._deactivate();\\n    });\\n    self._universalSubs = [];\\n  },\\n\\n  // Determine the remote client's IP address, based on the\\n  // HTTP_FORWARDED_COUNT environment variable representing how many\\n  // proxies the server is behind.\\n  _clientAddress: function () {\\n    var self = this;\\n\\n    // For the reported client address for a connection to be correct,\\n    // the developer must set the HTTP_FORWARDED_COUNT environment\\n    // variable to an integer representing the number of hops they\\n    // expect in the `x-forwarded-for` header. E.g., set to \\\"1\\\" if the\\n    // server is behind one proxy.\\n    //\\n    // This could be computed once at startup instead of every time.\\n    var httpForwardedCount = parseInt(process.env['HTTP_FORWARDED_COUNT']) || 0;\\n\\n    if (httpForwardedCount === 0)\\n      return self.socket.remoteAddress;\\n\\n    var forwardedFor = self.socket.headers[\\\"x-forwarded-for\\\"];\\n    if (! _.isString(forwardedFor))\\n      return null;\\n    forwardedFor = forwardedFor.trim().split(/\\\\s*,\\\\s*/);\\n\\n    // Typically the first value in the `x-forwarded-for` header is\\n    // the original IP address of the client connecting to the first\\n    // proxy.  However, the end user can easily spoof the header, in\\n    // which case the first value(s) will be the fake IP address from\\n    // the user pretending to be a proxy reporting the original IP\\n    // address value.  By counting HTTP_FORWARDED_COUNT back from the\\n    // end of the list, we ensure that we get the IP address being\\n    // reported by *our* first proxy.\\n\\n    if (httpForwardedCount < 0 || httpForwardedCount > forwardedFor.length)\\n      return null;\\n\\n    return forwardedFor[forwardedFor.length - httpForwardedCount];\\n  }\\n});\\n\\n/******************************************************************************/\\n/* Subscription                                                               */\\n/******************************************************************************/\\n\\n// ctor for a sub handle: the input to each publish function\\n\\n// Instance name is this because it's usually referred to as this inside a\\n// publish\\n/**\\n * @summary The server's side of a subscription\\n * @class Subscription\\n * @instanceName this\\n */\\nvar Subscription = function (\\n    session, handler, subscriptionId, params, name) {\\n  var self = this;\\n  self._session = session; // type is Session\\n\\n  /**\\n   * @summary Access inside the publish function. The incoming [connection](#meteor_onconnection) for this subscription.\\n   * @locus Server\\n   * @name  connection\\n   * @memberOf Subscription\\n   * @instance\\n   */\\n  self.connection = session.connectionHandle; // public API object\\n\\n  self._handler = handler;\\n\\n  // my subscription ID (generated by client, undefined for universal subs).\\n  self._subscriptionId = subscriptionId;\\n  // undefined for universal subs\\n  self._name = name;\\n\\n  self._params = params || [];\\n\\n  // Only named subscriptions have IDs, but we need some sort of string\\n  // internally to keep track of all subscriptions inside\\n  // SessionDocumentViews. We use this subscriptionHandle for that.\\n  if (self._subscriptionId) {\\n    self._subscriptionHandle = 'N' + self._subscriptionId;\\n  } else {\\n    self._subscriptionHandle = 'U' + Random.id();\\n  }\\n\\n  // has _deactivate been called?\\n  self._deactivated = false;\\n\\n  // stop callbacks to g/c this sub.  called w/ zero arguments.\\n  self._stopCallbacks = [];\\n\\n  // the set of (collection, documentid) that this subscription has\\n  // an opinion about\\n  self._documents = {};\\n\\n  // remember if we are ready.\\n  self._ready = false;\\n\\n  // Part of the public API: the user of this sub.\\n\\n  /**\\n   * @summary Access inside the publish function. The id of the logged-in user, or `null` if no user is logged in.\\n   * @locus Server\\n   * @memberOf Subscription\\n   * @name  userId\\n   * @instance\\n   */\\n  self.userId = session.userId;\\n\\n  // For now, the id filter is going to default to\\n  // the to/from DDP methods on LocalCollection, to\\n  // specifically deal with mongo/minimongo ObjectIds.\\n\\n  // Later, you will be able to make this be \\\"raw\\\"\\n  // if you want to publish a collection that you know\\n  // just has strings for keys and no funny business, to\\n  // a ddp consumer that isn't minimongo\\n\\n  self._idFilter = {\\n    idStringify: LocalCollection._idStringify,\\n    idParse: LocalCollection._idParse\\n  };\\n\\n  Package.facts && Package.facts.Facts.incrementServerFact(\\n    \\\"livedata\\\", \\\"subscriptions\\\", 1);\\n};\\n\\n_.extend(Subscription.prototype, {\\n  _runHandler: function () {\\n    // XXX should we unblock() here? Either before running the publish\\n    // function, or before running _publishCursor.\\n    //\\n    // Right now, each publish function blocks all future publishes and\\n    // methods waiting on data from Mongo (or whatever else the function\\n    // blocks on). This probably slows page load in common cases.\\n\\n    var self = this;\\n    try {\\n      var res = maybeAuditArgumentChecks(\\n        self._handler, self, EJSON.clone(self._params),\\n        // It's OK that this would look weird for universal subscriptions,\\n        // because they have no arguments so there can never be an\\n        // audit-argument-checks failure.\\n        \\\"publisher '\\\" + self._name + \\\"'\\\");\\n    } catch (e) {\\n      self.error(e);\\n      return;\\n    }\\n\\n    // Did the handler call this.error or this.stop?\\n    if (self._isDeactivated())\\n      return;\\n\\n    // SPECIAL CASE: Instead of writing their own callbacks that invoke\\n    // this.added/changed/ready/etc, the user can just return a collection\\n    // cursor or array of cursors from the publish function; we call their\\n    // _publishCursor method which starts observing the cursor and publishes the\\n    // results. Note that _publishCursor does NOT call ready().\\n    //\\n    // XXX This uses an undocumented interface which only the Mongo cursor\\n    // interface publishes. Should we make this interface public and encourage\\n    // users to implement it themselves? Arguably, it's unnecessary; users can\\n    // already write their own functions like\\n    //   var publishMyReactiveThingy = function (name, handler) {\\n    //     Meteor.publish(name, function () {\\n    //       var reactiveThingy = handler();\\n    //       reactiveThingy.publishMe();\\n    //     });\\n    //   };\\n    var isCursor = function (c) {\\n      return c && c._publishCursor;\\n    };\\n    if (isCursor(res)) {\\n      try {\\n        res._publishCursor(self);\\n      } catch (e) {\\n        self.error(e);\\n        return;\\n      }\\n      // _publishCursor only returns after the initial added callbacks have run.\\n      // mark subscription as ready.\\n      self.ready();\\n    } else if (_.isArray(res)) {\\n      // check all the elements are cursors\\n      if (! _.all(res, isCursor)) {\\n        self.error(new Error(\\\"Publish function returned an array of non-Cursors\\\"));\\n        return;\\n      }\\n      // find duplicate collection names\\n      // XXX we should support overlapping cursors, but that would require the\\n      // merge box to allow overlap within a subscription\\n      var collectionNames = {};\\n      for (var i = 0; i < res.length; ++i) {\\n        var collectionName = res[i]._getCollectionName();\\n        if (_.has(collectionNames, collectionName)) {\\n          self.error(new Error(\\n            \\\"Publish function returned multiple cursors for collection \\\" +\\n              collectionName));\\n          return;\\n        }\\n        collectionNames[collectionName] = true;\\n      };\\n\\n      try {\\n        _.each(res, function (cur) {\\n          cur._publishCursor(self);\\n        });\\n      } catch (e) {\\n        self.error(e);\\n        return;\\n      }\\n      self.ready();\\n    } else if (res) {\\n      // truthy values other than cursors or arrays are probably a\\n      // user mistake (possible returning a Mongo document via, say,\\n      // `coll.findOne()`).\\n      self.error(new Error(\\\"Publish function can only return a Cursor or \\\"\\n                           + \\\"an array of Cursors\\\"));\\n    }\\n  },\\n\\n  // This calls all stop callbacks and prevents the handler from updating any\\n  // SessionCollectionViews further. It's used when the user unsubscribes or\\n  // disconnects, as well as during setUserId re-runs. It does *NOT* send\\n  // removed messages for the published objects; if that is necessary, call\\n  // _removeAllDocuments first.\\n  _deactivate: function() {\\n    var self = this;\\n    if (self._deactivated)\\n      return;\\n    self._deactivated = true;\\n    self._callStopCallbacks();\\n    Package.facts && Package.facts.Facts.incrementServerFact(\\n      \\\"livedata\\\", \\\"subscriptions\\\", -1);\\n  },\\n\\n  _callStopCallbacks: function () {\\n    var self = this;\\n    // tell listeners, so they can clean up\\n    var callbacks = self._stopCallbacks;\\n    self._stopCallbacks = [];\\n    _.each(callbacks, function (callback) {\\n      callback();\\n    });\\n  },\\n\\n  // Send remove messages for every document.\\n  _removeAllDocuments: function () {\\n    var self = this;\\n    Meteor._noYieldsAllowed(function () {\\n      _.each(self._documents, function(collectionDocs, collectionName) {\\n        // Iterate over _.keys instead of the dictionary itself, since we'll be\\n        // mutating it.\\n        _.each(_.keys(collectionDocs), function (strId) {\\n          self.removed(collectionName, self._idFilter.idParse(strId));\\n        });\\n      });\\n    });\\n  },\\n\\n  // Returns a new Subscription for the same session with the same\\n  // initial creation parameters. This isn't a clone: it doesn't have\\n  // the same _documents cache, stopped state or callbacks; may have a\\n  // different _subscriptionHandle, and gets its userId from the\\n  // session, not from this object.\\n  _recreate: function () {\\n    var self = this;\\n    return new Subscription(\\n      self._session, self._handler, self._subscriptionId, self._params,\\n      self._name);\\n  },\\n\\n  /**\\n   * @summary Call inside the publish function.  Stops this client's subscription, triggering a call on the client to the `onStop` callback passed to [`Meteor.subscribe`](#meteor_subscribe), if any. If `error` is not a [`Meteor.Error`](#meteor_error), it will be [sanitized](#meteor_error).\\n   * @locus Server\\n   * @param {Error} error The error to pass to the client.\\n   * @instance\\n   * @memberOf Subscription\\n   */\\n  error: function (error) {\\n    var self = this;\\n    if (self._isDeactivated())\\n      return;\\n    self._session._stopSubscription(self._subscriptionId, error);\\n  },\\n\\n  // Note that while our DDP client will notice that you've called stop() on the\\n  // server (and clean up its _subscriptions table) we don't actually provide a\\n  // mechanism for an app to notice this (the subscribe onError callback only\\n  // triggers if there is an error).\\n\\n  /**\\n   * @summary Call inside the publish function.  Stops this client's subscription and invokes the client's `onStop` callback with no error.\\n   * @locus Server\\n   * @instance\\n   * @memberOf Subscription\\n   */\\n  stop: function () {\\n    var self = this;\\n    if (self._isDeactivated())\\n      return;\\n    self._session._stopSubscription(self._subscriptionId);\\n  },\\n\\n  /**\\n   * @summary Call inside the publish function.  Registers a callback function to run when the subscription is stopped.\\n   * @locus Server\\n   * @memberOf Subscription\\n   * @instance\\n   * @param {Function} func The callback function\\n   */\\n  onStop: function (callback) {\\n    var self = this;\\n    if (self._isDeactivated())\\n      callback();\\n    else\\n      self._stopCallbacks.push(callback);\\n  },\\n\\n  // This returns true if the sub has been deactivated, *OR* if the session was\\n  // destroyed but the deferred call to _deactivateAllSubscriptions hasn't\\n  // happened yet.\\n  _isDeactivated: function () {\\n    var self = this;\\n    return self._deactivated || self._session.inQueue === null;\\n  },\\n\\n  /**\\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been added to the record set.\\n   * @locus Server\\n   * @memberOf Subscription\\n   * @instance\\n   * @param {String} collection The name of the collection that contains the new document.\\n   * @param {String} id The new document's ID.\\n   * @param {Object} fields The fields in the new document.  If `_id` is present it is ignored.\\n   */\\n  added: function (collectionName, id, fields) {\\n    var self = this;\\n    if (self._isDeactivated())\\n      return;\\n    id = self._idFilter.idStringify(id);\\n    Meteor._ensure(self._documents, collectionName)[id] = true;\\n    self._session.added(self._subscriptionHandle, collectionName, id, fields);\\n  },\\n\\n  /**\\n   * @summary Call inside the publish function.  Informs the subscriber that a document in the record set has been modified.\\n   * @locus Server\\n   * @memberOf Subscription\\n   * @instance\\n   * @param {String} collection The name of the collection that contains the changed document.\\n   * @param {String} id The changed document's ID.\\n   * @param {Object} fields The fields in the document that have changed, together with their new values.  If a field is not present in `fields` it was left unchanged; if it is present in `fields` and has a value of `undefined` it was removed from the document.  If `_id` is present it is ignored.\\n   */\\n  changed: function (collectionName, id, fields) {\\n    var self = this;\\n    if (self._isDeactivated())\\n      return;\\n    id = self._idFilter.idStringify(id);\\n    self._session.changed(self._subscriptionHandle, collectionName, id, fields);\\n  },\\n\\n  /**\\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been removed from the record set.\\n   * @locus Server\\n   * @memberOf Subscription\\n   * @instance\\n   * @param {String} collection The name of the collection that the document has been removed from.\\n   * @param {String} id The ID of the document that has been removed.\\n   */\\n  removed: function (collectionName, id) {\\n    var self = this;\\n    if (self._isDeactivated())\\n      return;\\n    id = self._idFilter.idStringify(id);\\n    // We don't bother to delete sets of things in a collection if the\\n    // collection is empty.  It could break _removeAllDocuments.\\n    delete self._documents[collectionName][id];\\n    self._session.removed(self._subscriptionHandle, collectionName, id);\\n  },\\n\\n  /**\\n   * @summary Call inside the publish function.  Informs the subscriber that an initial, complete snapshot of the record set has been sent.  This will trigger a call on the client to the `onReady` callback passed to  [`Meteor.subscribe`](#meteor_subscribe), if any.\\n   * @locus Server\\n   * @memberOf Subscription\\n   * @instance\\n   */\\n  ready: function () {\\n    var self = this;\\n    if (self._isDeactivated())\\n      return;\\n    if (!self._subscriptionId)\\n      return;  // unnecessary but ignored for universal sub\\n    if (!self._ready) {\\n      self._session.sendReady([self._subscriptionId]);\\n      self._ready = true;\\n    }\\n  }\\n});\\n\\n/******************************************************************************/\\n/* Server                                                                     */\\n/******************************************************************************/\\n\\nServer = function (options) {\\n  var self = this;\\n\\n  // The default heartbeat interval is 30 seconds on the server and 35\\n  // seconds on the client.  Since the client doesn't need to send a\\n  // ping as long as it is receiving pings, this means that pings\\n  // normally go from the server to the client.\\n  //\\n  // Note: Troposphere depends on the ability to mutate\\n  // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.\\n  self.options = _.defaults(options || {}, {\\n    heartbeatInterval: 30000,\\n    heartbeatTimeout: 15000,\\n    // For testing, allow responding to pings to be disabled.\\n    respondToPings: true\\n  });\\n\\n  // Map of callbacks to call when a new connection comes in to the\\n  // server and completes DDP version negotiation. Use an object instead\\n  // of an array so we can safely remove one from the list while\\n  // iterating over it.\\n  self.onConnectionHook = new Hook({\\n    debugPrintExceptions: \\\"onConnection callback\\\"\\n  });\\n\\n  self.publish_handlers = {};\\n  self.universal_publish_handlers = [];\\n\\n  self.method_handlers = {};\\n\\n  self.sessions = {}; // map from id to session\\n\\n  self.stream_server = new StreamServer;\\n\\n  self.stream_server.register(function (socket) {\\n    // socket implements the SockJSConnection interface\\n    socket._meteorSession = null;\\n\\n    var sendError = function (reason, offendingMessage) {\\n      var msg = {msg: 'error', reason: reason};\\n      if (offendingMessage)\\n        msg.offendingMessage = offendingMessage;\\n      socket.send(stringifyDDP(msg));\\n    };\\n\\n    socket.on('data', function (raw_msg) {\\n      if (Meteor._printReceivedDDP) {\\n        Meteor._debug(\\\"Received DDP\\\", raw_msg);\\n      }\\n      try {\\n        try {\\n          var msg = parseDDP(raw_msg);\\n        } catch (err) {\\n          sendError('Parse error');\\n          return;\\n        }\\n        if (msg === null || !msg.msg) {\\n          sendError('Bad request', msg);\\n          return;\\n        }\\n\\n        if (msg.msg === 'connect') {\\n          if (socket._meteorSession) {\\n            sendError(\\\"Already connected\\\", msg);\\n            return;\\n          }\\n          Fiber(function () {\\n            self._handleConnect(socket, msg);\\n          }).run();\\n          return;\\n        }\\n\\n        if (!socket._meteorSession) {\\n          sendError('Must connect first', msg);\\n          return;\\n        }\\n        socket._meteorSession.processMessage(msg);\\n      } catch (e) {\\n        // XXX print stack nicely\\n        Meteor._debug(\\\"Internal exception while processing message\\\", msg,\\n                      e.message, e.stack);\\n      }\\n    });\\n\\n    socket.on('close', function () {\\n      if (socket._meteorSession) {\\n        Fiber(function () {\\n          socket._meteorSession.close();\\n        }).run();\\n      }\\n    });\\n  });\\n};\\n\\n_.extend(Server.prototype, {\\n\\n  /**\\n   * @summary Register a callback to be called when a new DDP connection is made to the server.\\n   * @locus Server\\n   * @param {function} callback The function to call when a new DDP connection is established.\\n   * @memberOf Meteor\\n   */\\n  onConnection: function (fn) {\\n    var self = this;\\n    return self.onConnectionHook.register(fn);\\n  },\\n\\n  _handleConnect: function (socket, msg) {\\n    var self = this;\\n\\n    // The connect message must specify a version and an array of supported\\n    // versions, and it must claim to support what it is proposing.\\n    if (!(typeof (msg.version) === 'string' &&\\n          _.isArray(msg.support) &&\\n          _.all(msg.support, _.isString) &&\\n          _.contains(msg.support, msg.version))) {\\n      socket.send(stringifyDDP({msg: 'failed',\\n                                version: SUPPORTED_DDP_VERSIONS[0]}));\\n      socket.close();\\n      return;\\n    }\\n\\n    // In the future, handle session resumption: something like:\\n    //  socket._meteorSession = self.sessions[msg.session]\\n    var version = calculateVersion(msg.support, SUPPORTED_DDP_VERSIONS);\\n\\n    if (msg.version !== version) {\\n      // The best version to use (according to the client's stated preferences)\\n      // is not the one the client is trying to use. Inform them about the best\\n      // version to use.\\n      socket.send(stringifyDDP({msg: 'failed', version: version}));\\n      socket.close();\\n      return;\\n    }\\n\\n    // Yay, version matches! Create a new session.\\n    // Note: Troposphere depends on the ability to mutate\\n    // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.\\n    socket._meteorSession = new Session(self, version, socket, self.options);\\n    self.sessions[socket._meteorSession.id] = socket._meteorSession;\\n    self.onConnectionHook.each(function (callback) {\\n      if (socket._meteorSession)\\n        callback(socket._meteorSession.connectionHandle);\\n      return true;\\n    });\\n  },\\n  /**\\n   * Register a publish handler function.\\n   *\\n   * @param name {String} identifier for query\\n   * @param handler {Function} publish handler\\n   * @param options {Object}\\n   *\\n   * Server will call handler function on each new subscription,\\n   * either when receiving DDP sub message for a named subscription, or on\\n   * DDP connect for a universal subscription.\\n   *\\n   * If name is null, this will be a subscription that is\\n   * automatically established and permanently on for all connected\\n   * client, instead of a subscription that can be turned on and off\\n   * with subscribe().\\n   *\\n   * options to contain:\\n   *  - (mostly internal) is_auto: true if generated automatically\\n   *    from an autopublish hook. this is for cosmetic purposes only\\n   *    (it lets us determine whether to print a warning suggesting\\n   *    that you turn off autopublish.)\\n   */\\n\\n  /**\\n   * @summary Publish a record set.\\n   * @memberOf Meteor\\n   * @locus Server\\n   * @param {String} name Name of the record set.  If `null`, the set has no name, and the record set is automatically sent to all connected clients.\\n   * @param {Function} func Function called on the server each time a client subscribes.  Inside the function, `this` is the publish handler object, described below.  If the client passed arguments to `subscribe`, the function is called with the same arguments.\\n   */\\n  publish: function (name, handler, options) {\\n    var self = this;\\n\\n    options = options || {};\\n\\n    if (name && name in self.publish_handlers) {\\n      Meteor._debug(\\\"Ignoring duplicate publish named '\\\" + name + \\\"'\\\");\\n      return;\\n    }\\n\\n    if (Package.autopublish && !options.is_auto) {\\n      // They have autopublish on, yet they're trying to manually\\n      // picking stuff to publish. They probably should turn off\\n      // autopublish. (This check isn't perfect -- if you create a\\n      // publish before you turn on autopublish, it won't catch\\n      // it. But this will definitely handle the simple case where\\n      // you've added the autopublish package to your app, and are\\n      // calling publish from your app code.)\\n      if (!self.warned_about_autopublish) {\\n        self.warned_about_autopublish = true;\\n        Meteor._debug(\\n\\\"** You've set up some data subscriptions with Meteor.publish(), but\\\\n\\\" +\\n\\\"** you still have autopublish turned on. Because autopublish is still\\\\n\\\" +\\n\\\"** on, your Meteor.publish() calls won't have much effect. All data\\\\n\\\" +\\n\\\"** will still be sent to all clients.\\\\n\\\" +\\n\\\"**\\\\n\\\" +\\n\\\"** Turn off autopublish by removing the autopublish package:\\\\n\\\" +\\n\\\"**\\\\n\\\" +\\n\\\"**   $ meteor remove autopublish\\\\n\\\" +\\n\\\"**\\\\n\\\" +\\n\\\"** .. and make sure you have Meteor.publish() and Meteor.subscribe() calls\\\\n\\\" +\\n\\\"** for each collection that you want clients to see.\\\\n\\\");\\n      }\\n    }\\n\\n    if (name)\\n      self.publish_handlers[name] = handler;\\n    else {\\n      self.universal_publish_handlers.push(handler);\\n      // Spin up the new publisher on any existing session too. Run each\\n      // session's subscription in a new Fiber, so that there's no change for\\n      // self.sessions to change while we're running this loop.\\n      _.each(self.sessions, function (session) {\\n        if (!session._dontStartNewUniversalSubs) {\\n          Fiber(function() {\\n            session._startSubscription(handler);\\n          }).run();\\n        }\\n      });\\n    }\\n  },\\n\\n  _removeSession: function (session) {\\n    var self = this;\\n    if (self.sessions[session.id]) {\\n      delete self.sessions[session.id];\\n    }\\n  },\\n\\n  /**\\n   * @summary Defines functions that can be invoked over the network by clients.\\n   * @locus Anywhere\\n   * @param {Object} methods Dictionary whose keys are method names and values are functions.\\n   * @memberOf Meteor\\n   */\\n  methods: function (methods) {\\n    var self = this;\\n    _.each(methods, function (func, name) {\\n      if (self.method_handlers[name])\\n        throw new Error(\\\"A method named '\\\" + name + \\\"' is already defined\\\");\\n      self.method_handlers[name] = func;\\n    });\\n  },\\n\\n  call: function (name /*, arguments */) {\\n    // if it's a function, the last argument is the result callback,\\n    // not a parameter to the remote method.\\n    var args = Array.prototype.slice.call(arguments, 1);\\n    if (args.length && typeof args[args.length - 1] === \\\"function\\\")\\n      var callback = args.pop();\\n    return this.apply(name, args, callback);\\n  },\\n\\n  // @param options {Optional Object}\\n  // @param callback {Optional Function}\\n  apply: function (name, args, options, callback) {\\n    var self = this;\\n\\n    // We were passed 3 arguments. They may be either (name, args, options)\\n    // or (name, args, callback)\\n    if (!callback && typeof options === 'function') {\\n      callback = options;\\n      options = {};\\n    }\\n    options = options || {};\\n\\n    if (callback)\\n      // It's not really necessary to do this, since we immediately\\n      // run the callback in this fiber before returning, but we do it\\n      // anyway for regularity.\\n      // XXX improve error message (and how we report it)\\n      callback = Meteor.bindEnvironment(\\n        callback,\\n        \\\"delivering result of invoking '\\\" + name + \\\"'\\\"\\n      );\\n\\n    // Run the handler\\n    var handler = self.method_handlers[name];\\n    var exception;\\n    if (!handler) {\\n      exception = new Meteor.Error(404, \\\"Method not found\\\");\\n    } else {\\n      // If this is a method call from within another method, get the\\n      // user state from the outer method, otherwise don't allow\\n      // setUserId to be called\\n      var userId = null;\\n      var setUserId = function() {\\n        throw new Error(\\\"Can't call setUserId on a server initiated method call\\\");\\n      };\\n      var connection = null;\\n      var currentInvocation = DDP._CurrentInvocation.get();\\n      if (currentInvocation) {\\n        userId = currentInvocation.userId;\\n        setUserId = function(userId) {\\n          currentInvocation.setUserId(userId);\\n        };\\n        connection = currentInvocation.connection;\\n      }\\n\\n      var invocation = new MethodInvocation({\\n        isSimulation: false,\\n        userId: userId,\\n        setUserId: setUserId,\\n        connection: connection,\\n        randomSeed: makeRpcSeed(currentInvocation, name)\\n      });\\n      try {\\n        var result = DDP._CurrentInvocation.withValue(invocation, function () {\\n          return maybeAuditArgumentChecks(\\n            handler, invocation, EJSON.clone(args), \\\"internal call to '\\\" +\\n              name + \\\"'\\\");\\n        });\\n        result = EJSON.clone(result);\\n      } catch (e) {\\n        exception = e;\\n      }\\n    }\\n\\n    // Return the result in whichever way the caller asked for it. Note that we\\n    // do NOT block on the write fence in an analogous way to how the client\\n    // blocks on the relevant data being visible, so you are NOT guaranteed that\\n    // cursor observe callbacks have fired when your callback is invoked. (We\\n    // can change this if there's a real use case.)\\n    if (callback) {\\n      callback(exception, result);\\n      return undefined;\\n    }\\n    if (exception)\\n      throw exception;\\n    return result;\\n  },\\n\\n  _urlForSession: function (sessionId) {\\n    var self = this;\\n    var session = self.sessions[sessionId];\\n    if (session)\\n      return session._socketUrl;\\n    else\\n      return null;\\n  }\\n});\\n\\nvar calculateVersion = function (clientSupportedVersions,\\n                                 serverSupportedVersions) {\\n  var correctVersion = _.find(clientSupportedVersions, function (version) {\\n    return _.contains(serverSupportedVersions, version);\\n  });\\n  if (!correctVersion) {\\n    correctVersion = serverSupportedVersions[0];\\n  }\\n  return correctVersion;\\n};\\n\\nLivedataTest.calculateVersion = calculateVersion;\\n\\n\\n// \\\"blind\\\" exceptions other than those that were deliberately thrown to signal\\n// errors to the client\\nvar wrapInternalException = function (exception, context) {\\n  if (!exception || exception instanceof Meteor.Error)\\n    return exception;\\n\\n  // tests can set the 'expected' flag on an exception so it won't go to the\\n  // server log\\n  if (!exception.expected) {\\n    Meteor._debug(\\\"Exception \\\" + context, exception.stack);\\n    if (exception.sanitizedError) {\\n      Meteor._debug(\\\"Sanitized and reported to the client as:\\\", exception.sanitizedError.message);\\n      Meteor._debug();\\n    }\\n  }\\n\\n  // Did the error contain more details that could have been useful if caught in\\n  // server code (or if thrown from non-client-originated code), but also\\n  // provided a \\\"sanitized\\\" version with more context than 500 Internal server\\n  // error? Use that.\\n  if (exception.sanitizedError) {\\n    if (exception.sanitizedError instanceof Meteor.Error)\\n      return exception.sanitizedError;\\n    Meteor._debug(\\\"Exception \\\" + context + \\\" provides a sanitizedError that \\\" +\\n                  \\\"is not a Meteor.Error; ignoring\\\");\\n  }\\n\\n  return new Meteor.Error(500, \\\"Internal server error\\\");\\n};\\n\\n\\n// Audit argument checks, if the audit-argument-checks package exists (it is a\\n// weak dependency of this package).\\nvar maybeAuditArgumentChecks = function (f, context, args, description) {\\n  args = args || [];\\n  if (Package['audit-argument-checks']) {\\n    return Match._failIfArgumentsAreNotAllChecked(\\n      f, context, args, description);\\n  }\\n  return f.apply(context, args);\\n};\\n\",\"var path = Npm.require('path');\\nvar Future = Npm.require(path.join('fibers', 'future'));\\n\\n// A write fence collects a group of writes, and provides a callback\\n// when all of the writes are fully committed and propagated (all\\n// observers have been notified of the write and acknowledged it.)\\n//\\nDDPServer._WriteFence = function () {\\n  var self = this;\\n\\n  self.armed = false;\\n  self.fired = false;\\n  self.retired = false;\\n  self.outstanding_writes = 0;\\n  self.completion_callbacks = [];\\n};\\n\\n// The current write fence. When there is a current write fence, code\\n// that writes to databases should register their writes with it using\\n// beginWrite().\\n//\\nDDPServer._CurrentWriteFence = new Meteor.EnvironmentVariable;\\n\\n_.extend(DDPServer._WriteFence.prototype, {\\n  // Start tracking a write, and return an object to represent it. The\\n  // object has a single method, committed(). This method should be\\n  // called when the write is fully committed and propagated. You can\\n  // continue to add writes to the WriteFence up until it is triggered\\n  // (calls its callbacks because all writes have committed.)\\n  beginWrite: function () {\\n    var self = this;\\n\\n    if (self.retired)\\n      return { committed: function () {} };\\n\\n    if (self.fired)\\n      throw new Error(\\\"fence has already activated -- too late to add writes\\\");\\n\\n    self.outstanding_writes++;\\n    var committed = false;\\n    return {\\n      committed: function () {\\n        if (committed)\\n          throw new Error(\\\"committed called twice on the same write\\\");\\n        committed = true;\\n        self.outstanding_writes--;\\n        self._maybeFire();\\n      }\\n    };\\n  },\\n\\n  // Arm the fence. Once the fence is armed, and there are no more\\n  // uncommitted writes, it will activate.\\n  arm: function () {\\n    var self = this;\\n    if (self === DDPServer._CurrentWriteFence.get())\\n      throw Error(\\\"Can't arm the current fence\\\");\\n    self.armed = true;\\n    self._maybeFire();\\n  },\\n\\n  // Register a function to be called when the fence fires.\\n  onAllCommitted: function (func) {\\n    var self = this;\\n    if (self.fired)\\n      throw new Error(\\\"fence has already activated -- too late to \\\" +\\n                      \\\"add a callback\\\");\\n    self.completion_callbacks.push(func);\\n  },\\n\\n  // Convenience function. Arms the fence, then blocks until it fires.\\n  armAndWait: function () {\\n    var self = this;\\n    var future = new Future;\\n    self.onAllCommitted(function () {\\n      future['return']();\\n    });\\n    self.arm();\\n    future.wait();\\n  },\\n\\n  _maybeFire: function () {\\n    var self = this;\\n    if (self.fired)\\n      throw new Error(\\\"write fence already activated?\\\");\\n    if (self.armed && !self.outstanding_writes) {\\n      self.fired = true;\\n      _.each(self.completion_callbacks, function (f) {f(self);});\\n      self.completion_callbacks = [];\\n    }\\n  },\\n\\n  // Deactivate this fence so that adding more writes has no effect.\\n  // The fence must have already fired.\\n  retire: function () {\\n    var self = this;\\n    if (! self.fired)\\n      throw new Error(\\\"Can't retire a fence that hasn't fired.\\\");\\n    self.retired = true;\\n  }\\n});\\n\",\"// A \\\"crossbar\\\" is a class that provides structured notification registration.\\n// See _match for the definition of how a notification matches a trigger.\\n// All notifications and triggers must have a string key named 'collection'.\\n\\nDDPServer._Crossbar = function (options) {\\n  var self = this;\\n  options = options || {};\\n\\n  self.nextId = 1;\\n  // map from collection name (string) -> listener id -> object. each object has\\n  // keys 'trigger', 'callback'.\\n  self.listenersByCollection = {};\\n  self.factPackage = options.factPackage || \\\"livedata\\\";\\n  self.factName = options.factName || null;\\n};\\n\\n_.extend(DDPServer._Crossbar.prototype, {\\n  // Listen for notification that match 'trigger'. A notification\\n  // matches if it has the key-value pairs in trigger as a\\n  // subset. When a notification matches, call 'callback', passing\\n  // the actual notification.\\n  //\\n  // Returns a listen handle, which is an object with a method\\n  // stop(). Call stop() to stop listening.\\n  //\\n  // XXX It should be legal to call fire() from inside a listen()\\n  // callback?\\n  listen: function (trigger, callback) {\\n    var self = this;\\n    var id = self.nextId++;\\n\\n    if (typeof(trigger.collection) !== 'string') {\\n      throw Error(\\\"Trigger lacks collection!\\\");\\n    }\\n\\n    var collection = trigger.collection;  // save in case trigger is mutated\\n    var record = {trigger: EJSON.clone(trigger), callback: callback};\\n    if (! _.has(self.listenersByCollection, collection)) {\\n      self.listenersByCollection[collection] = {};\\n    }\\n    self.listenersByCollection[collection][id] = record;\\n\\n    if (self.factName && Package.facts) {\\n      Package.facts.Facts.incrementServerFact(\\n        self.factPackage, self.factName, 1);\\n    }\\n\\n    return {\\n      stop: function () {\\n        if (self.factName && Package.facts) {\\n          Package.facts.Facts.incrementServerFact(\\n            self.factPackage, self.factName, -1);\\n        }\\n        delete self.listenersByCollection[collection][id];\\n        if (_.isEmpty(self.listenersByCollection[collection])) {\\n          delete self.listenersByCollection[collection];\\n        }\\n      }\\n    };\\n  },\\n\\n  // Fire the provided 'notification' (an object whose attribute\\n  // values are all JSON-compatibile) -- inform all matching listeners\\n  // (registered with listen()).\\n  //\\n  // If fire() is called inside a write fence, then each of the\\n  // listener callbacks will be called inside the write fence as well.\\n  //\\n  // The listeners may be invoked in parallel, rather than serially.\\n  fire: function (notification) {\\n    var self = this;\\n\\n    if (typeof(notification.collection) !== 'string') {\\n      throw Error(\\\"Notification lacks collection!\\\");\\n    }\\n\\n    if (! _.has(self.listenersByCollection, notification.collection))\\n      return;\\n\\n    var listenersForCollection =\\n          self.listenersByCollection[notification.collection];\\n    var callbackIds = [];\\n    _.each(listenersForCollection, function (l, id) {\\n      if (self._matches(notification, l.trigger)) {\\n        callbackIds.push(id);\\n      }\\n    });\\n\\n    // Listener callbacks can yield, so we need to first find all the ones that\\n    // match in a single iteration over self.listenersByCollection (which can't\\n    // be mutated during this iteration), and then invoke the matching\\n    // callbacks, checking before each call to ensure they haven't stopped.\\n    // Note that we don't have to check that\\n    // self.listenersByCollection[notification.collection] still ===\\n    // listenersForCollection, because the only way that stops being true is if\\n    // listenersForCollection first gets reduced down to the empty object (and\\n    // then never gets increased again).\\n    _.each(callbackIds, function (id) {\\n      if (_.has(listenersForCollection, id)) {\\n        listenersForCollection[id].callback(notification);\\n      }\\n    });\\n  },\\n\\n  // A notification matches a trigger if all keys that exist in both are equal.\\n  //\\n  // Examples:\\n  //  N:{collection: \\\"C\\\"} matches T:{collection: \\\"C\\\"}\\n  //    (a non-targeted write to a collection matches a\\n  //     non-targeted query)\\n  //  N:{collection: \\\"C\\\", id: \\\"X\\\"} matches T:{collection: \\\"C\\\"}\\n  //    (a targeted write to a collection matches a non-targeted query)\\n  //  N:{collection: \\\"C\\\"} matches T:{collection: \\\"C\\\", id: \\\"X\\\"}\\n  //    (a non-targeted write to a collection matches a\\n  //     targeted query)\\n  //  N:{collection: \\\"C\\\", id: \\\"X\\\"} matches T:{collection: \\\"C\\\", id: \\\"X\\\"}\\n  //    (a targeted write to a collection matches a targeted query targeted\\n  //     at the same document)\\n  //  N:{collection: \\\"C\\\", id: \\\"X\\\"} does not match T:{collection: \\\"C\\\", id: \\\"Y\\\"}\\n  //    (a targeted write to a collection does not match a targeted query\\n  //     targeted at a different document)\\n  _matches: function (notification, trigger) {\\n    // Most notifications that use the crossbar have a string `collection` and\\n    // maybe an `id` that is a string or ObjectID. We're already dividing up\\n    // triggers by collection, but let's fast-track \\\"nope, different ID\\\" (and\\n    // avoid the overly generic EJSON.equals). This makes a noticeable\\n    // performance difference; see https://github.com/meteor/meteor/pull/3697\\n    if (typeof(notification.id) === 'string' &&\\n        typeof(trigger.id) === 'string' &&\\n        notification.id !== trigger.id) {\\n      return false;\\n    }\\n    if (notification.id instanceof LocalCollection._ObjectID &&\\n        trigger.id instanceof LocalCollection._ObjectID &&\\n        ! notification.id.equals(trigger.id)) {\\n      return false;\\n    }\\n\\n    return _.all(trigger, function (triggerValue, key) {\\n      return !_.has(notification, key) ||\\n        EJSON.equals(triggerValue, notification[key]);\\n    });\\n  }\\n});\\n\\n// The \\\"invalidation crossbar\\\" is a specific instance used by the DDP server to\\n// implement write fence notifications. Listener callbacks on this crossbar\\n// should call beginWrite on the current write fence before they return, if they\\n// want to delay the write fence from firing (ie, the DDP method-data-updated\\n// message from being sent).\\nDDPServer._InvalidationCrossbar = new DDPServer._Crossbar({\\n  factName: \\\"invalidation-crossbar-listeners\\\"\\n});\\n\",\"// All the supported versions (for both the client and server)\\n// These must be in order of preference; most favored-first\\nSUPPORTED_DDP_VERSIONS = [ '1', 'pre2', 'pre1' ];\\n\\nLivedataTest.SUPPORTED_DDP_VERSIONS = SUPPORTED_DDP_VERSIONS;\\n\\n// Instance name is this because it is usually referred to as this inside a\\n// method definition\\n/**\\n * @summary The state for a single invocation of a method, referenced by this\\n * inside a method definition.\\n * @param {Object} options\\n * @instanceName this\\n */\\nMethodInvocation = function (options) {\\n  var self = this;\\n\\n  // true if we're running not the actual method, but a stub (that is,\\n  // if we're on a client (which may be a browser, or in the future a\\n  // server connecting to another server) and presently running a\\n  // simulation of a server-side method for latency compensation\\n  // purposes). not currently true except in a client such as a browser,\\n  // since there's usually no point in running stubs unless you have a\\n  // zero-latency connection to the user.\\n\\n  /**\\n   * @summary Access inside a method invocation.  Boolean value, true if this invocation is a stub.\\n   * @locus Anywhere\\n   * @name  isSimulation\\n   * @memberOf MethodInvocation\\n   * @instance\\n   * @type {Boolean}\\n   */\\n  this.isSimulation = options.isSimulation;\\n\\n  // call this function to allow other method invocations (from the\\n  // same client) to continue running without waiting for this one to\\n  // complete.\\n  this._unblock = options.unblock || function () {};\\n  this._calledUnblock = false;\\n\\n  // current user id\\n\\n  /**\\n   * @summary The id of the user that made this method call, or `null` if no user was logged in.\\n   * @locus Anywhere\\n   * @name  userId\\n   * @memberOf MethodInvocation\\n   * @instance\\n   */\\n  this.userId = options.userId;\\n\\n  // sets current user id in all appropriate server contexts and\\n  // reruns subscriptions\\n  this._setUserId = options.setUserId || function () {};\\n\\n  // On the server, the connection this method call came in on.\\n\\n  /**\\n   * @summary Access inside a method invocation. The [connection](#meteor_onconnection) that this method was received on. `null` if the method is not associated with a connection, eg. a server initiated method call.\\n   * @locus Server\\n   * @name  connection\\n   * @memberOf MethodInvocation\\n   * @instance\\n   */\\n  this.connection = options.connection;\\n\\n  // The seed for randomStream value generation\\n  this.randomSeed = options.randomSeed;\\n\\n  // This is set by RandomStream.get; and holds the random stream state\\n  this.randomStream = null;\\n};\\n\\n_.extend(MethodInvocation.prototype, {\\n  /**\\n   * @summary Call inside a method invocation.  Allow subsequent method from this client to begin running in a new fiber.\\n   * @locus Server\\n   * @memberOf MethodInvocation\\n   * @instance\\n   */\\n  unblock: function () {\\n    var self = this;\\n    self._calledUnblock = true;\\n    self._unblock();\\n  },\\n\\n  /**\\n   * @summary Set the logged in user.\\n   * @locus Server\\n   * @memberOf MethodInvocation\\n   * @instance\\n   * @param {String | null} userId The value that should be returned by `userId` on this connection.\\n   */\\n  setUserId: function(userId) {\\n    var self = this;\\n    if (self._calledUnblock)\\n      throw new Error(\\\"Can't call setUserId in a method after calling unblock\\\");\\n    self.userId = userId;\\n    self._setUserId(userId);\\n  }\\n});\\n\\nparseDDP = function (stringMessage) {\\n  try {\\n    var msg = JSON.parse(stringMessage);\\n  } catch (e) {\\n    Meteor._debug(\\\"Discarding message with invalid JSON\\\", stringMessage);\\n    return null;\\n  }\\n  // DDP messages must be objects.\\n  if (msg === null || typeof msg !== 'object') {\\n    Meteor._debug(\\\"Discarding non-object DDP message\\\", stringMessage);\\n    return null;\\n  }\\n\\n  // massage msg to get it into \\\"abstract ddp\\\" rather than \\\"wire ddp\\\" format.\\n\\n  // switch between \\\"cleared\\\" rep of unsetting fields and \\\"undefined\\\"\\n  // rep of same\\n  if (_.has(msg, 'cleared')) {\\n    if (!_.has(msg, 'fields'))\\n      msg.fields = {};\\n    _.each(msg.cleared, function (clearKey) {\\n      msg.fields[clearKey] = undefined;\\n    });\\n    delete msg.cleared;\\n  }\\n\\n  _.each(['fields', 'params', 'result'], function (field) {\\n    if (_.has(msg, field))\\n      msg[field] = EJSON._adjustTypesFromJSONValue(msg[field]);\\n  });\\n\\n  return msg;\\n};\\n\\nstringifyDDP = function (msg) {\\n  var copy = EJSON.clone(msg);\\n  // swizzle 'changed' messages from 'fields undefined' rep to 'fields\\n  // and cleared' rep\\n  if (_.has(msg, 'fields')) {\\n    var cleared = [];\\n    _.each(msg.fields, function (value, key) {\\n      if (value === undefined) {\\n        cleared.push(key);\\n        delete copy.fields[key];\\n      }\\n    });\\n    if (!_.isEmpty(cleared))\\n      copy.cleared = cleared;\\n    if (_.isEmpty(copy.fields))\\n      delete copy.fields;\\n  }\\n  // adjust types to basic\\n  _.each(['fields', 'params', 'result'], function (field) {\\n    if (_.has(copy, field))\\n      copy[field] = EJSON._adjustTypesToJSONValue(copy[field]);\\n  });\\n  if (msg.id && typeof msg.id !== 'string') {\\n    throw new Error(\\\"Message id is not a string\\\");\\n  }\\n  return JSON.stringify(copy);\\n};\\n\\n// This is private but it's used in a few places. accounts-base uses\\n// it to get the current user. accounts-password uses it to stash SRP\\n// state in the DDP session. Meteor.setTimeout and friends clear\\n// it. We can probably find a better way to factor this.\\nDDP._CurrentInvocation = new Meteor.EnvironmentVariable;\\n\",\"// RandomStream allows for generation of pseudo-random values, from a seed.\\n//\\n// We use this for consistent 'random' numbers across the client and server.\\n// We want to generate probably-unique IDs on the client, and we ideally want\\n// the server to generate the same IDs when it executes the method.\\n//\\n// For generated values to be the same, we must seed ourselves the same way,\\n// and we must keep track of the current state of our pseudo-random generators.\\n// We call this state the scope. By default, we use the current DDP method\\n// invocation as our scope.  DDP now allows the client to specify a randomSeed.\\n// If a randomSeed is provided it will be used to seed our random sequences.\\n// In this way, client and server method calls will generate the same values.\\n//\\n// We expose multiple named streams; each stream is independent\\n// and is seeded differently (but predictably from the name).\\n// By using multiple streams, we support reordering of requests,\\n// as long as they occur on different streams.\\n//\\n// @param options {Optional Object}\\n//   seed: Array or value - Seed value(s) for the generator.\\n//                          If an array, will be used as-is\\n//                          If a value, will be converted to a single-value array\\n//                          If omitted, a random array will be used as the seed.\\nRandomStream = function (options) {\\n  var self = this;\\n\\n  this.seed = [].concat(options.seed || randomToken());\\n\\n  this.sequences = {};\\n};\\n\\n// Returns a random string of sufficient length for a random seed.\\n// This is a placeholder function; a similar function is planned\\n// for Random itself; when that is added we should remove this function,\\n// and call Random's randomToken instead.\\nfunction randomToken() {\\n  return Random.hexString(20);\\n};\\n\\n// Returns the random stream with the specified name, in the specified scope.\\n// If scope is null (or otherwise falsey) then we will use Random, which will\\n// give us as random numbers as possible, but won't produce the same\\n// values across client and server.\\n// However, scope will normally be the current DDP method invocation, so\\n// we'll use the stream with the specified name, and we should get consistent\\n// values on the client and server sides of a method call.\\nRandomStream.get = function (scope, name) {\\n  if (!name) {\\n    name = \\\"default\\\";\\n  }\\n  if (!scope) {\\n    // There was no scope passed in;\\n    // the sequence won't actually be reproducible.\\n    return Random;\\n  }\\n  var randomStream = scope.randomStream;\\n  if (!randomStream) {\\n    scope.randomStream = randomStream = new RandomStream({\\n      seed: scope.randomSeed\\n    });\\n  }\\n  return randomStream._sequence(name);\\n};\\n\\n// Returns the named sequence of pseudo-random values.\\n// The scope will be DDP._CurrentInvocation.get(), so the stream will produce\\n// consistent values for method calls on the client and server.\\nDDP.randomStream = function (name) {\\n  var scope = DDP._CurrentInvocation.get();\\n  return RandomStream.get(scope, name);\\n};\\n\\n// Creates a randomSeed for passing to a method call.\\n// Note that we take enclosing as an argument,\\n// though we expect it to be DDP._CurrentInvocation.get()\\n// However, we often evaluate makeRpcSeed lazily, and thus the relevant\\n// invocation may not be the one currently in scope.\\n// If enclosing is null, we'll use Random and values won't be repeatable.\\nmakeRpcSeed = function (enclosing, methodName) {\\n  var stream = RandomStream.get(enclosing, '/rpc/' + methodName);\\n  return stream.hexString(20);\\n};\\n\\n_.extend(RandomStream.prototype, {\\n  // Get a random sequence with the specified name, creating it if does not exist.\\n  // New sequences are seeded with the seed concatenated with the name.\\n  // By passing a seed into Random.create, we use the Alea generator.\\n  _sequence: function (name) {\\n    var self = this;\\n\\n    var sequence = self.sequences[name] || null;\\n    if (sequence === null) {\\n      var sequenceSeed = self.seed.concat(name);\\n      for (var i = 0; i < sequenceSeed.length; i++) {\\n        if (_.isFunction(sequenceSeed[i])) {\\n          sequenceSeed[i] = sequenceSeed[i]();\\n        }\\n      }\\n      self.sequences[name] = sequence = Random.createWithSeeds.apply(null, sequenceSeed);\\n    }\\n    return sequence;\\n  }\\n});\\n\",\"if (Meteor.isServer) {\\n  var path = Npm.require('path');\\n  var Fiber = Npm.require('fibers');\\n  var Future = Npm.require(path.join('fibers', 'future'));\\n}\\n\\n// @param url {String|Object} URL to Meteor app,\\n//   or an object as a test hook (see code)\\n// Options:\\n//   reloadWithOutstanding: is it OK to reload if there are outstanding methods?\\n//   headers: extra headers to send on the websockets connection, for\\n//     server-to-server DDP only\\n//   _sockjsOptions: Specifies options to pass through to the sockjs client\\n//   onDDPNegotiationVersionFailure: callback when version negotiation fails.\\n//\\n// XXX There should be a way to destroy a DDP connection, causing all\\n// outstanding method calls to fail.\\n//\\n// XXX Our current way of handling failure and reconnection is great\\n// for an app (where we want to tolerate being disconnected as an\\n// expect state, and keep trying forever to reconnect) but cumbersome\\n// for something like a command line tool that wants to make a\\n// connection, call a method, and print an error if connection\\n// fails. We should have better usability in the latter case (while\\n// still transparently reconnecting if it's just a transient failure\\n// or the server migrating us).\\nvar Connection = function (url, options) {\\n  var self = this;\\n  options = _.extend({\\n    onConnected: function () {},\\n    onDDPVersionNegotiationFailure: function (description) {\\n      Meteor._debug(description);\\n    },\\n    heartbeatInterval: 35000,\\n    heartbeatTimeout: 15000,\\n    // These options are only for testing.\\n    reloadWithOutstanding: false,\\n    supportedDDPVersions: SUPPORTED_DDP_VERSIONS,\\n    retry: true,\\n    respondToPings: true\\n  }, options);\\n\\n  // If set, called when we reconnect, queuing method calls _before_ the\\n  // existing outstanding ones. This is the only data member that is part of the\\n  // public API!\\n  self.onReconnect = null;\\n\\n  // as a test hook, allow passing a stream instead of a url.\\n  if (typeof url === \\\"object\\\") {\\n    self._stream = url;\\n  } else {\\n    self._stream = new LivedataTest.ClientStream(url, {\\n      retry: options.retry,\\n      headers: options.headers,\\n      _sockjsOptions: options._sockjsOptions,\\n      // Used to keep some tests quiet, or for other cases in which\\n      // the right thing to do with connection errors is to silently\\n      // fail (e.g. sending package usage stats). At some point we\\n      // should have a real API for handling client-stream-level\\n      // errors.\\n      _dontPrintErrors: options._dontPrintErrors,\\n      connectTimeoutMs: options.connectTimeoutMs\\n    });\\n  }\\n\\n  self._lastSessionId = null;\\n  self._versionSuggestion = null;  // The last proposed DDP version.\\n  self._version = null;   // The DDP version agreed on by client and server.\\n  self._stores = {}; // name -> object with methods\\n  self._methodHandlers = {}; // name -> func\\n  self._nextMethodId = 1;\\n  self._supportedDDPVersions = options.supportedDDPVersions;\\n\\n  self._heartbeatInterval = options.heartbeatInterval;\\n  self._heartbeatTimeout = options.heartbeatTimeout;\\n\\n  // Tracks methods which the user has tried to call but which have not yet\\n  // called their user callback (ie, they are waiting on their result or for all\\n  // of their writes to be written to the local cache). Map from method ID to\\n  // MethodInvoker object.\\n  self._methodInvokers = {};\\n\\n  // Tracks methods which the user has called but whose result messages have not\\n  // arrived yet.\\n  //\\n  // _outstandingMethodBlocks is an array of blocks of methods. Each block\\n  // represents a set of methods that can run at the same time. The first block\\n  // represents the methods which are currently in flight; subsequent blocks\\n  // must wait for previous blocks to be fully finished before they can be sent\\n  // to the server.\\n  //\\n  // Each block is an object with the following fields:\\n  // - methods: a list of MethodInvoker objects\\n  // - wait: a boolean; if true, this block had a single method invoked with\\n  //         the \\\"wait\\\" option\\n  //\\n  // There will never be adjacent blocks with wait=false, because the only thing\\n  // that makes methods need to be serialized is a wait method.\\n  //\\n  // Methods are removed from the first block when their \\\"result\\\" is\\n  // received. The entire first block is only removed when all of the in-flight\\n  // methods have received their results (so the \\\"methods\\\" list is empty) *AND*\\n  // all of the data written by those methods are visible in the local cache. So\\n  // it is possible for the first block's methods list to be empty, if we are\\n  // still waiting for some objects to quiesce.\\n  //\\n  // Example:\\n  //  _outstandingMethodBlocks = [\\n  //    {wait: false, methods: []},\\n  //    {wait: true, methods: [<MethodInvoker for 'login'>]},\\n  //    {wait: false, methods: [<MethodInvoker for 'foo'>,\\n  //                            <MethodInvoker for 'bar'>]}]\\n  // This means that there were some methods which were sent to the server and\\n  // which have returned their results, but some of the data written by\\n  // the methods may not be visible in the local cache. Once all that data is\\n  // visible, we will send a 'login' method. Once the login method has returned\\n  // and all the data is visible (including re-running subs if userId changes),\\n  // we will send the 'foo' and 'bar' methods in parallel.\\n  self._outstandingMethodBlocks = [];\\n\\n  // method ID -> array of objects with keys 'collection' and 'id', listing\\n  // documents written by a given method's stub. keys are associated with\\n  // methods whose stub wrote at least one document, and whose data-done message\\n  // has not yet been received.\\n  self._documentsWrittenByStub = {};\\n  // collection -> IdMap of \\\"server document\\\" object. A \\\"server document\\\" has:\\n  // - \\\"document\\\": the version of the document according the\\n  //   server (ie, the snapshot before a stub wrote it, amended by any changes\\n  //   received from the server)\\n  //   It is undefined if we think the document does not exist\\n  // - \\\"writtenByStubs\\\": a set of method IDs whose stubs wrote to the document\\n  //   whose \\\"data done\\\" messages have not yet been processed\\n  self._serverDocuments = {};\\n\\n  // Array of callbacks to be called after the next update of the local\\n  // cache. Used for:\\n  //  - Calling methodInvoker.dataVisible and sub ready callbacks after\\n  //    the relevant data is flushed.\\n  //  - Invoking the callbacks of \\\"half-finished\\\" methods after reconnect\\n  //    quiescence. Specifically, methods whose result was received over the old\\n  //    connection (so we don't re-send it) but whose data had not been made\\n  //    visible.\\n  self._afterUpdateCallbacks = [];\\n\\n  // In two contexts, we buffer all incoming data messages and then process them\\n  // all at once in a single update:\\n  //   - During reconnect, we buffer all data messages until all subs that had\\n  //     been ready before reconnect are ready again, and all methods that are\\n  //     active have returned their \\\"data done message\\\"; then\\n  //   - During the execution of a \\\"wait\\\" method, we buffer all data messages\\n  //     until the wait method gets its \\\"data done\\\" message. (If the wait method\\n  //     occurs during reconnect, it doesn't get any special handling.)\\n  // all data messages are processed in one update.\\n  //\\n  // The following fields are used for this \\\"quiescence\\\" process.\\n\\n  // This buffers the messages that aren't being processed yet.\\n  self._messagesBufferedUntilQuiescence = [];\\n  // Map from method ID -> true. Methods are removed from this when their\\n  // \\\"data done\\\" message is received, and we will not quiesce until it is\\n  // empty.\\n  self._methodsBlockingQuiescence = {};\\n  // map from sub ID -> true for subs that were ready (ie, called the sub\\n  // ready callback) before reconnect but haven't become ready again yet\\n  self._subsBeingRevived = {}; // map from sub._id -> true\\n  // if true, the next data update should reset all stores. (set during\\n  // reconnect.)\\n  self._resetStores = false;\\n\\n  // name -> array of updates for (yet to be created) collections\\n  self._updatesForUnknownStores = {};\\n  // if we're blocking a migration, the retry func\\n  self._retryMigrate = null;\\n\\n  // metadata for subscriptions.  Map from sub ID to object with keys:\\n  //   - id\\n  //   - name\\n  //   - params\\n  //   - inactive (if true, will be cleaned up if not reused in re-run)\\n  //   - ready (has the 'ready' message been received?)\\n  //   - readyCallback (an optional callback to call when ready)\\n  //   - errorCallback (an optional callback to call if the sub terminates with\\n  //                    an error, XXX COMPAT WITH 1.0.3.1)\\n  //   - stopCallback (an optional callback to call when the sub terminates\\n  //     for any reason, with an error argument if an error triggered the stop)\\n  self._subscriptions = {};\\n\\n  // Reactive userId.\\n  self._userId = null;\\n  self._userIdDeps = new Tracker.Dependency;\\n\\n  // Block auto-reload while we're waiting for method responses.\\n  if (Meteor.isClient && Package.reload && !options.reloadWithOutstanding) {\\n    Package.reload.Reload._onMigrate(function (retry) {\\n      if (!self._readyToMigrate()) {\\n        if (self._retryMigrate)\\n          throw new Error(\\\"Two migrations in progress?\\\");\\n        self._retryMigrate = retry;\\n        return false;\\n      } else {\\n        return [true];\\n      }\\n    });\\n  }\\n\\n  var onMessage = function (raw_msg) {\\n    try {\\n      var msg = parseDDP(raw_msg);\\n    } catch (e) {\\n      Meteor._debug(\\\"Exception while parsing DDP\\\", e);\\n      return;\\n    }\\n\\n    if (msg === null || !msg.msg) {\\n      // XXX COMPAT WITH 0.6.6. ignore the old welcome message for back\\n      // compat.  Remove this 'if' once the server stops sending welcome\\n      // messages (stream_server.js).\\n      if (! (msg && msg.server_id))\\n        Meteor._debug(\\\"discarding invalid livedata message\\\", msg);\\n      return;\\n    }\\n\\n    if (msg.msg === 'connected') {\\n      self._version = self._versionSuggestion;\\n      self._livedata_connected(msg);\\n      options.onConnected();\\n    }\\n    else if (msg.msg == 'failed') {\\n      if (_.contains(self._supportedDDPVersions, msg.version)) {\\n        self._versionSuggestion = msg.version;\\n        self._stream.reconnect({_force: true});\\n      } else {\\n        var description =\\n              \\\"DDP version negotiation failed; server requested version \\\" + msg.version;\\n        self._stream.disconnect({_permanent: true, _error: description});\\n        options.onDDPVersionNegotiationFailure(description);\\n      }\\n    }\\n    else if (msg.msg === 'ping') {\\n      if (options.respondToPings)\\n        self._send({msg: \\\"pong\\\", id: msg.id});\\n      if (self._heartbeat)\\n        self._heartbeat.pingReceived();\\n    }\\n    else if (msg.msg === 'pong') {\\n      if (self._heartbeat) {\\n        self._heartbeat.pongReceived();\\n      }\\n    }\\n    else if (_.include(['added', 'changed', 'removed', 'ready', 'updated'], msg.msg))\\n      self._livedata_data(msg);\\n    else if (msg.msg === 'nosub')\\n      self._livedata_nosub(msg);\\n    else if (msg.msg === 'result')\\n      self._livedata_result(msg);\\n    else if (msg.msg === 'error')\\n      self._livedata_error(msg);\\n    else\\n      Meteor._debug(\\\"discarding unknown livedata message type\\\", msg);\\n  };\\n\\n  var onReset = function () {\\n    // Send a connect message at the beginning of the stream.\\n    // NOTE: reset is called even on the first connection, so this is\\n    // the only place we send this message.\\n    var msg = {msg: 'connect'};\\n    if (self._lastSessionId)\\n      msg.session = self._lastSessionId;\\n    msg.version = self._versionSuggestion || self._supportedDDPVersions[0];\\n    self._versionSuggestion = msg.version;\\n    msg.support = self._supportedDDPVersions;\\n    self._send(msg);\\n\\n    // Now, to minimize setup latency, go ahead and blast out all of\\n    // our pending methods ands subscriptions before we've even taken\\n    // the necessary RTT to know if we successfully reconnected. (1)\\n    // They're supposed to be idempotent; (2) even if we did\\n    // reconnect, we're not sure what messages might have gotten lost\\n    // (in either direction) since we were disconnected (TCP being\\n    // sloppy about that.)\\n\\n    // If the current block of methods all got their results (but didn't all get\\n    // their data visible), discard the empty block now.\\n    if (! _.isEmpty(self._outstandingMethodBlocks) &&\\n        _.isEmpty(self._outstandingMethodBlocks[0].methods)) {\\n      self._outstandingMethodBlocks.shift();\\n    }\\n\\n    // Mark all messages as unsent, they have not yet been sent on this\\n    // connection.\\n    _.each(self._methodInvokers, function (m) {\\n      m.sentMessage = false;\\n    });\\n\\n    // If an `onReconnect` handler is set, call it first. Go through\\n    // some hoops to ensure that methods that are called from within\\n    // `onReconnect` get executed _before_ ones that were originally\\n    // outstanding (since `onReconnect` is used to re-establish auth\\n    // certificates)\\n    if (self.onReconnect)\\n      self._callOnReconnectAndSendAppropriateOutstandingMethods();\\n    else\\n      self._sendOutstandingMethods();\\n\\n    // add new subscriptions at the end. this way they take effect after\\n    // the handlers and we don't see flicker.\\n    _.each(self._subscriptions, function (sub, id) {\\n      self._send({\\n        msg: 'sub',\\n        id: id,\\n        name: sub.name,\\n        params: sub.params\\n      });\\n    });\\n  };\\n\\n  var onDisconnect = function () {\\n    if (self._heartbeat) {\\n      self._heartbeat.stop();\\n      self._heartbeat = null;\\n    }\\n  };\\n\\n  if (Meteor.isServer) {\\n    self._stream.on('message', Meteor.bindEnvironment(onMessage, Meteor._debug));\\n    self._stream.on('reset', Meteor.bindEnvironment(onReset, Meteor._debug));\\n    self._stream.on('disconnect', Meteor.bindEnvironment(onDisconnect, Meteor._debug));\\n  } else {\\n    self._stream.on('message', onMessage);\\n    self._stream.on('reset', onReset);\\n    self._stream.on('disconnect', onDisconnect);\\n  }\\n};\\n\\n// A MethodInvoker manages sending a method to the server and calling the user's\\n// callbacks. On construction, it registers itself in the connection's\\n// _methodInvokers map; it removes itself once the method is fully finished and\\n// the callback is invoked. This occurs when it has both received a result,\\n// and the data written by it is fully visible.\\nvar MethodInvoker = function (options) {\\n  var self = this;\\n\\n  // Public (within this file) fields.\\n  self.methodId = options.methodId;\\n  self.sentMessage = false;\\n\\n  self._callback = options.callback;\\n  self._connection = options.connection;\\n  self._message = options.message;\\n  self._onResultReceived = options.onResultReceived || function () {};\\n  self._wait = options.wait;\\n  self._methodResult = null;\\n  self._dataVisible = false;\\n\\n  // Register with the connection.\\n  self._connection._methodInvokers[self.methodId] = self;\\n};\\n_.extend(MethodInvoker.prototype, {\\n  // Sends the method message to the server. May be called additional times if\\n  // we lose the connection and reconnect before receiving a result.\\n  sendMessage: function () {\\n    var self = this;\\n    // This function is called before sending a method (including resending on\\n    // reconnect). We should only (re)send methods where we don't already have a\\n    // result!\\n    if (self.gotResult())\\n      throw new Error(\\\"sendingMethod is called on method with result\\\");\\n\\n    // If we're re-sending it, it doesn't matter if data was written the first\\n    // time.\\n    self._dataVisible = false;\\n\\n    self.sentMessage = true;\\n\\n    // If this is a wait method, make all data messages be buffered until it is\\n    // done.\\n    if (self._wait)\\n      self._connection._methodsBlockingQuiescence[self.methodId] = true;\\n\\n    // Actually send the message.\\n    self._connection._send(self._message);\\n  },\\n  // Invoke the callback, if we have both a result and know that all data has\\n  // been written to the local cache.\\n  _maybeInvokeCallback: function () {\\n    var self = this;\\n    if (self._methodResult && self._dataVisible) {\\n      // Call the callback. (This won't throw: the callback was wrapped with\\n      // bindEnvironment.)\\n      self._callback(self._methodResult[0], self._methodResult[1]);\\n\\n      // Forget about this method.\\n      delete self._connection._methodInvokers[self.methodId];\\n\\n      // Let the connection know that this method is finished, so it can try to\\n      // move on to the next block of methods.\\n      self._connection._outstandingMethodFinished();\\n    }\\n  },\\n  // Call with the result of the method from the server. Only may be called\\n  // once; once it is called, you should not call sendMessage again.\\n  // If the user provided an onResultReceived callback, call it immediately.\\n  // Then invoke the main callback if data is also visible.\\n  receiveResult: function (err, result) {\\n    var self = this;\\n    if (self.gotResult())\\n      throw new Error(\\\"Methods should only receive results once\\\");\\n    self._methodResult = [err, result];\\n    self._onResultReceived(err, result);\\n    self._maybeInvokeCallback();\\n  },\\n  // Call this when all data written by the method is visible. This means that\\n  // the method has returns its \\\"data is done\\\" message *AND* all server\\n  // documents that are buffered at that time have been written to the local\\n  // cache. Invokes the main callback if the result has been received.\\n  dataVisible: function () {\\n    var self = this;\\n    self._dataVisible = true;\\n    self._maybeInvokeCallback();\\n  },\\n  // True if receiveResult has been called.\\n  gotResult: function () {\\n    var self = this;\\n    return !!self._methodResult;\\n  }\\n});\\n\\n_.extend(Connection.prototype, {\\n  // 'name' is the name of the data on the wire that should go in the\\n  // store. 'wrappedStore' should be an object with methods beginUpdate, update,\\n  // endUpdate, saveOriginals, retrieveOriginals. see Collection for an example.\\n  registerStore: function (name, wrappedStore) {\\n    var self = this;\\n\\n    if (name in self._stores)\\n      return false;\\n\\n    // Wrap the input object in an object which makes any store method not\\n    // implemented by 'store' into a no-op.\\n    var store = {};\\n    _.each(['update', 'beginUpdate', 'endUpdate', 'saveOriginals',\\n            'retrieveOriginals'], function (method) {\\n              store[method] = function () {\\n                return (wrappedStore[method]\\n                        ? wrappedStore[method].apply(wrappedStore, arguments)\\n                        : undefined);\\n              };\\n            });\\n\\n    self._stores[name] = store;\\n\\n    var queued = self._updatesForUnknownStores[name];\\n    if (queued) {\\n      store.beginUpdate(queued.length, false);\\n      _.each(queued, function (msg) {\\n        store.update(msg);\\n      });\\n      store.endUpdate();\\n      delete self._updatesForUnknownStores[name];\\n    }\\n\\n    return true;\\n  },\\n\\n  /**\\n   * @memberOf Meteor\\n   * @summary Subscribe to a record set.  Returns a handle that provides\\n   * `stop()` and `ready()` methods.\\n   * @locus Client\\n   * @param {String} name Name of the subscription.  Matches the name of the\\n   * server's `publish()` call.\\n   * @param {Any} [arg1,arg2...] Optional arguments passed to publisher\\n   * function on server.\\n   * @param {Function|Object} [callbacks] Optional. May include `onStop`\\n   * and `onReady` callbacks. If there is an error, it is passed as an\\n   * argument to `onStop`. If a function is passed instead of an object, it\\n   * is interpreted as an `onReady` callback.\\n   */\\n  subscribe: function (name /* .. [arguments] .. (callback|callbacks) */) {\\n    var self = this;\\n\\n    var params = Array.prototype.slice.call(arguments, 1);\\n    var callbacks = {};\\n    if (params.length) {\\n      var lastParam = params[params.length - 1];\\n      if (_.isFunction(lastParam)) {\\n        callbacks.onReady = params.pop();\\n      } else if (lastParam &&\\n        // XXX COMPAT WITH 1.0.3.1 onError used to exist, but now we use\\n        // onStop with an error callback instead.\\n        _.any([lastParam.onReady, lastParam.onError, lastParam.onStop],\\n          _.isFunction)) {\\n        callbacks = params.pop();\\n      }\\n    }\\n\\n    // Is there an existing sub with the same name and param, run in an\\n    // invalidated Computation? This will happen if we are rerunning an\\n    // existing computation.\\n    //\\n    // For example, consider a rerun of:\\n    //\\n    //     Tracker.autorun(function () {\\n    //       Meteor.subscribe(\\\"foo\\\", Session.get(\\\"foo\\\"));\\n    //       Meteor.subscribe(\\\"bar\\\", Session.get(\\\"bar\\\"));\\n    //     });\\n    //\\n    // If \\\"foo\\\" has changed but \\\"bar\\\" has not, we will match the \\\"bar\\\"\\n    // subcribe to an existing inactive subscription in order to not\\n    // unsub and resub the subscription unnecessarily.\\n    //\\n    // We only look for one such sub; if there are N apparently-identical subs\\n    // being invalidated, we will require N matching subscribe calls to keep\\n    // them all active.\\n    var existing = _.find(self._subscriptions, function (sub) {\\n      return sub.inactive && sub.name === name &&\\n        EJSON.equals(sub.params, params);\\n    });\\n\\n    var id;\\n    if (existing) {\\n      id = existing.id;\\n      existing.inactive = false; // reactivate\\n\\n      if (callbacks.onReady) {\\n        // If the sub is not already ready, replace any ready callback with the\\n        // one provided now. (It's not really clear what users would expect for\\n        // an onReady callback inside an autorun; the semantics we provide is\\n        // that at the time the sub first becomes ready, we call the last\\n        // onReady callback provided, if any.)\\n        if (!existing.ready)\\n          existing.readyCallback = callbacks.onReady;\\n      }\\n\\n      // XXX COMPAT WITH 1.0.3.1 we used to have onError but now we call\\n      // onStop with an optional error argument\\n      if (callbacks.onError) {\\n        // Replace existing callback if any, so that errors aren't\\n        // double-reported.\\n        existing.errorCallback = callbacks.onError;\\n      }\\n\\n      if (callbacks.onStop) {\\n        existing.stopCallback = callbacks.onStop;\\n      }\\n    } else {\\n      // New sub! Generate an id, save it locally, and send message.\\n      id = Random.id();\\n      self._subscriptions[id] = {\\n        id: id,\\n        name: name,\\n        params: EJSON.clone(params),\\n        inactive: false,\\n        ready: false,\\n        readyDeps: new Tracker.Dependency,\\n        readyCallback: callbacks.onReady,\\n        // XXX COMPAT WITH 1.0.3.1 #errorCallback\\n        errorCallback: callbacks.onError,\\n        stopCallback: callbacks.onStop,\\n        connection: self,\\n        remove: function() {\\n          delete this.connection._subscriptions[this.id];\\n          this.ready && this.readyDeps.changed();\\n        },\\n        stop: function() {\\n          this.connection._send({msg: 'unsub', id: id});\\n          this.remove();\\n\\n          if (callbacks.onStop) {\\n            callbacks.onStop();\\n          }\\n        }\\n      };\\n      self._send({msg: 'sub', id: id, name: name, params: params});\\n    }\\n\\n    // return a handle to the application.\\n    var handle = {\\n      stop: function () {\\n        if (!_.has(self._subscriptions, id))\\n          return;\\n\\n        self._subscriptions[id].stop();\\n      },\\n      ready: function () {\\n        // return false if we've unsubscribed.\\n        if (!_.has(self._subscriptions, id))\\n          return false;\\n        var record = self._subscriptions[id];\\n        record.readyDeps.depend();\\n        return record.ready;\\n      },\\n      subscriptionId: id\\n    };\\n\\n    if (Tracker.active) {\\n      // We're in a reactive computation, so we'd like to unsubscribe when the\\n      // computation is invalidated... but not if the rerun just re-subscribes\\n      // to the same subscription!  When a rerun happens, we use onInvalidate\\n      // as a change to mark the subscription \\\"inactive\\\" so that it can\\n      // be reused from the rerun.  If it isn't reused, it's killed from\\n      // an afterFlush.\\n      Tracker.onInvalidate(function (c) {\\n        if (_.has(self._subscriptions, id))\\n          self._subscriptions[id].inactive = true;\\n\\n        Tracker.afterFlush(function () {\\n          if (_.has(self._subscriptions, id) &&\\n              self._subscriptions[id].inactive)\\n            handle.stop();\\n        });\\n      });\\n    }\\n\\n    return handle;\\n  },\\n\\n  // options:\\n  // - onLateError {Function(error)} called if an error was received after the ready event.\\n  //     (errors received before ready cause an error to be thrown)\\n  _subscribeAndWait: function (name, args, options) {\\n    var self = this;\\n    var f = new Future();\\n    var ready = false;\\n    var handle;\\n    args = args || [];\\n    args.push({\\n      onReady: function () {\\n        ready = true;\\n        f['return']();\\n      },\\n      onError: function (e) {\\n        if (!ready)\\n          f['throw'](e);\\n        else\\n          options && options.onLateError && options.onLateError(e);\\n      }\\n    });\\n\\n    handle = self.subscribe.apply(self, [name].concat(args));\\n    f.wait();\\n    return handle;\\n  },\\n\\n  methods: function (methods) {\\n    var self = this;\\n    _.each(methods, function (func, name) {\\n      if (self._methodHandlers[name])\\n        throw new Error(\\\"A method named '\\\" + name + \\\"' is already defined\\\");\\n      self._methodHandlers[name] = func;\\n    });\\n  },\\n\\n  /**\\n   * @memberOf Meteor\\n   * @summary Invokes a method passing any number of arguments.\\n   * @locus Anywhere\\n   * @param {String} name Name of method to invoke\\n   * @param {EJSONable} [arg1,arg2...] Optional method arguments\\n   * @param {Function} [asyncCallback] Optional callback, which is called asynchronously with the error or result after the method is complete. If not provided, the method runs synchronously if possible (see below).\\n   */\\n  call: function (name /* .. [arguments] .. callback */) {\\n    // if it's a function, the last argument is the result callback,\\n    // not a parameter to the remote method.\\n    var args = Array.prototype.slice.call(arguments, 1);\\n    if (args.length && typeof args[args.length - 1] === \\\"function\\\")\\n      var callback = args.pop();\\n    return this.apply(name, args, callback);\\n  },\\n\\n  // @param options {Optional Object}\\n  //   wait: Boolean - Should we wait to call this until all current methods\\n  //                   are fully finished, and block subsequent method calls\\n  //                   until this method is fully finished?\\n  //                   (does not affect methods called from within this method)\\n  //   onResultReceived: Function - a callback to call as soon as the method\\n  //                                result is received. the data written by\\n  //                                the method may not yet be in the cache!\\n  //   returnStubValue: Boolean - If true then in cases where we would have\\n  //                              otherwise discarded the stub's return value\\n  //                              and returned undefined, instead we go ahead\\n  //                              and return it.  Specifically, this is any\\n  //                              time other than when (a) we are already\\n  //                              inside a stub or (b) we are in Node and no\\n  //                              callback was provided.  Currently we require\\n  //                              this flag to be explicitly passed to reduce\\n  //                              the likelihood that stub return values will\\n  //                              be confused with server return values; we\\n  //                              may improve this in future.\\n  // @param callback {Optional Function}\\n\\n  /**\\n   * @memberOf Meteor\\n   * @summary Invoke a method passing an array of arguments.\\n   * @locus Anywhere\\n   * @param {String} name Name of method to invoke\\n   * @param {EJSONable[]} args Method arguments\\n   * @param {Object} [options]\\n   * @param {Boolean} options.wait (Client only) If true, don't send this method until all previous method calls have completed, and don't send any subsequent method calls until this one is completed.\\n   * @param {Function} options.onResultReceived (Client only) This callback is invoked with the error or result of the method (just like `asyncCallback`) as soon as the error or result is available. The local cache may not yet reflect the writes performed by the method.\\n   * @param {Function} [asyncCallback] Optional callback; same semantics as in [`Meteor.call`](#meteor_call).\\n   */\\n  apply: function (name, args, options, callback) {\\n    var self = this;\\n\\n    // We were passed 3 arguments. They may be either (name, args, options)\\n    // or (name, args, callback)\\n    if (!callback && typeof options === 'function') {\\n      callback = options;\\n      options = {};\\n    }\\n    options = options || {};\\n\\n    if (callback) {\\n      // XXX would it be better form to do the binding in stream.on,\\n      // or caller, instead of here?\\n      // XXX improve error message (and how we report it)\\n      callback = Meteor.bindEnvironment(\\n        callback,\\n        \\\"delivering result of invoking '\\\" + name + \\\"'\\\"\\n      );\\n    }\\n\\n    // Keep our args safe from mutation (eg if we don't send the message for a\\n    // while because of a wait method).\\n    args = EJSON.clone(args);\\n\\n    // Lazily allocate method ID once we know that it'll be needed.\\n    var methodId = (function () {\\n      var id;\\n      return function () {\\n        if (id === undefined)\\n          id = '' + (self._nextMethodId++);\\n        return id;\\n      };\\n    })();\\n\\n    var enclosing = DDP._CurrentInvocation.get();\\n    var alreadyInSimulation = enclosing && enclosing.isSimulation;\\n\\n    // Lazily generate a randomSeed, only if it is requested by the stub.\\n    // The random streams only have utility if they're used on both the client\\n    // and the server; if the client doesn't generate any 'random' values\\n    // then we don't expect the server to generate any either.\\n    // Less commonly, the server may perform different actions from the client,\\n    // and may in fact generate values where the client did not, but we don't\\n    // have any client-side values to match, so even here we may as well just\\n    // use a random seed on the server.  In that case, we don't pass the\\n    // randomSeed to save bandwidth, and we don't even generate it to save a\\n    // bit of CPU and to avoid consuming entropy.\\n    var randomSeed = null;\\n    var randomSeedGenerator = function () {\\n      if (randomSeed === null) {\\n        randomSeed = makeRpcSeed(enclosing, name);\\n      }\\n      return randomSeed;\\n    };\\n\\n    // Run the stub, if we have one. The stub is supposed to make some\\n    // temporary writes to the database to give the user a smooth experience\\n    // until the actual result of executing the method comes back from the\\n    // server (whereupon the temporary writes to the database will be reversed\\n    // during the beginUpdate/endUpdate process.)\\n    //\\n    // Normally, we ignore the return value of the stub (even if it is an\\n    // exception), in favor of the real return value from the server. The\\n    // exception is if the *caller* is a stub. In that case, we're not going\\n    // to do a RPC, so we use the return value of the stub as our return\\n    // value.\\n\\n    var stub = self._methodHandlers[name];\\n    if (stub) {\\n      var setUserId = function(userId) {\\n        self.setUserId(userId);\\n      };\\n\\n      var invocation = new MethodInvocation({\\n        isSimulation: true,\\n        userId: self.userId(),\\n        setUserId: setUserId,\\n        randomSeed: function () { return randomSeedGenerator(); }\\n      });\\n\\n      if (!alreadyInSimulation)\\n        self._saveOriginals();\\n\\n      try {\\n        // Note that unlike in the corresponding server code, we never audit\\n        // that stubs check() their arguments.\\n        var stubReturnValue = DDP._CurrentInvocation.withValue(invocation, function () {\\n          if (Meteor.isServer) {\\n            // Because saveOriginals and retrieveOriginals aren't reentrant,\\n            // don't allow stubs to yield.\\n            return Meteor._noYieldsAllowed(function () {\\n              // re-clone, so that the stub can't affect our caller's values\\n              return stub.apply(invocation, EJSON.clone(args));\\n            });\\n          } else {\\n            return stub.apply(invocation, EJSON.clone(args));\\n          }\\n        });\\n      }\\n      catch (e) {\\n        var exception = e;\\n      }\\n\\n      if (!alreadyInSimulation)\\n        self._retrieveAndStoreOriginals(methodId());\\n    }\\n\\n    // If we're in a simulation, stop and return the result we have,\\n    // rather than going on to do an RPC. If there was no stub,\\n    // we'll end up returning undefined.\\n    if (alreadyInSimulation) {\\n      if (callback) {\\n        callback(exception, stubReturnValue);\\n        return undefined;\\n      }\\n      if (exception)\\n        throw exception;\\n      return stubReturnValue;\\n    }\\n\\n    // If an exception occurred in a stub, and we're ignoring it\\n    // because we're doing an RPC and want to use what the server\\n    // returns instead, log it so the developer knows.\\n    //\\n    // Tests can set the 'expected' flag on an exception so it won't\\n    // go to log.\\n    if (exception && !exception.expected) {\\n      Meteor._debug(\\\"Exception while simulating the effect of invoking '\\\" +\\n                    name + \\\"'\\\", exception, exception.stack);\\n    }\\n\\n\\n    // At this point we're definitely doing an RPC, and we're going to\\n    // return the value of the RPC to the caller.\\n\\n    // If the caller didn't give a callback, decide what to do.\\n    if (!callback) {\\n      if (Meteor.isClient) {\\n        // On the client, we don't have fibers, so we can't block. The\\n        // only thing we can do is to return undefined and discard the\\n        // result of the RPC. If an error occurred then print the error\\n        // to the console.\\n        callback = function (err) {\\n          err && Meteor._debug(\\\"Error invoking Method '\\\" + name + \\\"':\\\",\\n                               err.message);\\n        };\\n      } else {\\n        // On the server, make the function synchronous. Throw on\\n        // errors, return on success.\\n        var future = new Future;\\n        callback = future.resolver();\\n      }\\n    }\\n    // Send the RPC. Note that on the client, it is important that the\\n    // stub have finished before we send the RPC, so that we know we have\\n    // a complete list of which local documents the stub wrote.\\n    var message = {\\n      msg: 'method',\\n      method: name,\\n      params: args,\\n      id: methodId()\\n    };\\n\\n    // Send the randomSeed only if we used it\\n    if (randomSeed !== null) {\\n      message.randomSeed = randomSeed;\\n    }\\n\\n    var methodInvoker = new MethodInvoker({\\n      methodId: methodId(),\\n      callback: callback,\\n      connection: self,\\n      onResultReceived: options.onResultReceived,\\n      wait: !!options.wait,\\n      message: message\\n    });\\n\\n    if (options.wait) {\\n      // It's a wait method! Wait methods go in their own block.\\n      self._outstandingMethodBlocks.push(\\n        {wait: true, methods: [methodInvoker]});\\n    } else {\\n      // Not a wait method. Start a new block if the previous block was a wait\\n      // block, and add it to the last block of methods.\\n      if (_.isEmpty(self._outstandingMethodBlocks) ||\\n          _.last(self._outstandingMethodBlocks).wait)\\n        self._outstandingMethodBlocks.push({wait: false, methods: []});\\n      _.last(self._outstandingMethodBlocks).methods.push(methodInvoker);\\n    }\\n\\n    // If we added it to the first block, send it out now.\\n    if (self._outstandingMethodBlocks.length === 1)\\n      methodInvoker.sendMessage();\\n\\n    // If we're using the default callback on the server,\\n    // block waiting for the result.\\n    if (future) {\\n      return future.wait();\\n    }\\n    return options.returnStubValue ? stubReturnValue : undefined;\\n  },\\n\\n  // Before calling a method stub, prepare all stores to track changes and allow\\n  // _retrieveAndStoreOriginals to get the original versions of changed\\n  // documents.\\n  _saveOriginals: function () {\\n    var self = this;\\n    _.each(self._stores, function (s) {\\n      s.saveOriginals();\\n    });\\n  },\\n  // Retrieves the original versions of all documents modified by the stub for\\n  // method 'methodId' from all stores and saves them to _serverDocuments (keyed\\n  // by document) and _documentsWrittenByStub (keyed by method ID).\\n  _retrieveAndStoreOriginals: function (methodId) {\\n    var self = this;\\n    if (self._documentsWrittenByStub[methodId])\\n      throw new Error(\\\"Duplicate methodId in _retrieveAndStoreOriginals\\\");\\n\\n    var docsWritten = [];\\n    _.each(self._stores, function (s, collection) {\\n      var originals = s.retrieveOriginals();\\n      // not all stores define retrieveOriginals\\n      if (!originals)\\n        return;\\n      originals.forEach(function (doc, id) {\\n        docsWritten.push({collection: collection, id: id});\\n        if (!_.has(self._serverDocuments, collection))\\n          self._serverDocuments[collection] = new LocalCollection._IdMap;\\n        var serverDoc = self._serverDocuments[collection].setDefault(id, {});\\n        if (serverDoc.writtenByStubs) {\\n          // We're not the first stub to write this doc. Just add our method ID\\n          // to the record.\\n          serverDoc.writtenByStubs[methodId] = true;\\n        } else {\\n          // First stub! Save the original value and our method ID.\\n          serverDoc.document = doc;\\n          serverDoc.flushCallbacks = [];\\n          serverDoc.writtenByStubs = {};\\n          serverDoc.writtenByStubs[methodId] = true;\\n        }\\n      });\\n    });\\n    if (!_.isEmpty(docsWritten)) {\\n      self._documentsWrittenByStub[methodId] = docsWritten;\\n    }\\n  },\\n\\n  // This is very much a private function we use to make the tests\\n  // take up fewer server resources after they complete.\\n  _unsubscribeAll: function () {\\n    var self = this;\\n    _.each(_.clone(self._subscriptions), function (sub, id) {\\n      // Avoid killing the autoupdate subscription so that developers\\n      // still get hot code pushes when writing tests.\\n      //\\n      // XXX it's a hack to encode knowledge about autoupdate here,\\n      // but it doesn't seem worth it yet to have a special API for\\n      // subscriptions to preserve after unit tests.\\n      if (sub.name !== 'meteor_autoupdate_clientVersions') {\\n        self._subscriptions[id].stop();\\n      }\\n    });\\n  },\\n\\n  // Sends the DDP stringification of the given message object\\n  _send: function (obj) {\\n    var self = this;\\n    self._stream.send(stringifyDDP(obj));\\n  },\\n\\n  // We detected via DDP-level heartbeats that we've lost the\\n  // connection.  Unlike `disconnect` or `close`, a lost connection\\n  // will be automatically retried.\\n  _lostConnection: function (error) {\\n    var self = this;\\n    self._stream._lostConnection(error);\\n  },\\n\\n  /**\\n   * @summary Get the current connection status. A reactive data source.\\n   * @locus Client\\n   * @memberOf Meteor\\n   */\\n  status: function (/*passthrough args*/) {\\n    var self = this;\\n    return self._stream.status.apply(self._stream, arguments);\\n  },\\n\\n  /**\\n   * @summary Force an immediate reconnection attempt if the client is not connected to the server.\\n\\n  This method does nothing if the client is already connected.\\n   * @locus Client\\n   * @memberOf Meteor\\n   */\\n  reconnect: function (/*passthrough args*/) {\\n    var self = this;\\n    return self._stream.reconnect.apply(self._stream, arguments);\\n  },\\n\\n  /**\\n   * @summary Disconnect the client from the server.\\n   * @locus Client\\n   * @memberOf Meteor\\n   */\\n  disconnect: function (/*passthrough args*/) {\\n    var self = this;\\n    return self._stream.disconnect.apply(self._stream, arguments);\\n  },\\n\\n  close: function () {\\n    var self = this;\\n    return self._stream.disconnect({_permanent: true});\\n  },\\n\\n  ///\\n  /// Reactive user system\\n  ///\\n  userId: function () {\\n    var self = this;\\n    if (self._userIdDeps)\\n      self._userIdDeps.depend();\\n    return self._userId;\\n  },\\n\\n  setUserId: function (userId) {\\n    var self = this;\\n    // Avoid invalidating dependents if setUserId is called with current value.\\n    if (self._userId === userId)\\n      return;\\n    self._userId = userId;\\n    if (self._userIdDeps)\\n      self._userIdDeps.changed();\\n  },\\n\\n  // Returns true if we are in a state after reconnect of waiting for subs to be\\n  // revived or early methods to finish their data, or we are waiting for a\\n  // \\\"wait\\\" method to finish.\\n  _waitingForQuiescence: function () {\\n    var self = this;\\n    return (! _.isEmpty(self._subsBeingRevived) ||\\n            ! _.isEmpty(self._methodsBlockingQuiescence));\\n  },\\n\\n  // Returns true if any method whose message has been sent to the server has\\n  // not yet invoked its user callback.\\n  _anyMethodsAreOutstanding: function () {\\n    var self = this;\\n    return _.any(_.pluck(self._methodInvokers, 'sentMessage'));\\n  },\\n\\n  _livedata_connected: function (msg) {\\n    var self = this;\\n\\n    if (self._version !== 'pre1' && self._heartbeatInterval !== 0) {\\n      self._heartbeat = new Heartbeat({\\n        heartbeatInterval: self._heartbeatInterval,\\n        heartbeatTimeout: self._heartbeatTimeout,\\n        onTimeout: function () {\\n          self._lostConnection(\\n            new DDP.ConnectionError(\\\"DDP heartbeat timed out\\\"));\\n        },\\n        sendPing: function () {\\n          self._send({msg: 'ping'});\\n        }\\n      });\\n      self._heartbeat.start();\\n    }\\n\\n    // If this is a reconnect, we'll have to reset all stores.\\n    if (self._lastSessionId)\\n      self._resetStores = true;\\n\\n    if (typeof (msg.session) === \\\"string\\\") {\\n      var reconnectedToPreviousSession = (self._lastSessionId === msg.session);\\n      self._lastSessionId = msg.session;\\n    }\\n\\n    if (reconnectedToPreviousSession) {\\n      // Successful reconnection -- pick up where we left off.  Note that right\\n      // now, this never happens: the server never connects us to a previous\\n      // session, because DDP doesn't provide enough data for the server to know\\n      // what messages the client has processed. We need to improve DDP to make\\n      // this possible, at which point we'll probably need more code here.\\n      return;\\n    }\\n\\n    // Server doesn't have our data any more. Re-sync a new session.\\n\\n    // Forget about messages we were buffering for unknown collections. They'll\\n    // be resent if still relevant.\\n    self._updatesForUnknownStores = {};\\n\\n    if (self._resetStores) {\\n      // Forget about the effects of stubs. We'll be resetting all collections\\n      // anyway.\\n      self._documentsWrittenByStub = {};\\n      self._serverDocuments = {};\\n    }\\n\\n    // Clear _afterUpdateCallbacks.\\n    self._afterUpdateCallbacks = [];\\n\\n    // Mark all named subscriptions which are ready (ie, we already called the\\n    // ready callback) as needing to be revived.\\n    // XXX We should also block reconnect quiescence until unnamed subscriptions\\n    //     (eg, autopublish) are done re-publishing to avoid flicker!\\n    self._subsBeingRevived = {};\\n    _.each(self._subscriptions, function (sub, id) {\\n      if (sub.ready)\\n        self._subsBeingRevived[id] = true;\\n    });\\n\\n    // Arrange for \\\"half-finished\\\" methods to have their callbacks run, and\\n    // track methods that were sent on this connection so that we don't\\n    // quiesce until they are all done.\\n    //\\n    // Start by clearing _methodsBlockingQuiescence: methods sent before\\n    // reconnect don't matter, and any \\\"wait\\\" methods sent on the new connection\\n    // that we drop here will be restored by the loop below.\\n    self._methodsBlockingQuiescence = {};\\n    if (self._resetStores) {\\n      _.each(self._methodInvokers, function (invoker) {\\n        if (invoker.gotResult()) {\\n          // This method already got its result, but it didn't call its callback\\n          // because its data didn't become visible. We did not resend the\\n          // method RPC. We'll call its callback when we get a full quiesce,\\n          // since that's as close as we'll get to \\\"data must be visible\\\".\\n          self._afterUpdateCallbacks.push(_.bind(invoker.dataVisible, invoker));\\n        } else if (invoker.sentMessage) {\\n          // This method has been sent on this connection (maybe as a resend\\n          // from the last connection, maybe from onReconnect, maybe just very\\n          // quickly before processing the connected message).\\n          //\\n          // We don't need to do anything special to ensure its callbacks get\\n          // called, but we'll count it as a method which is preventing\\n          // reconnect quiescence. (eg, it might be a login method that was run\\n          // from onReconnect, and we don't want to see flicker by seeing a\\n          // logged-out state.)\\n          self._methodsBlockingQuiescence[invoker.methodId] = true;\\n        }\\n      });\\n    }\\n\\n    self._messagesBufferedUntilQuiescence = [];\\n\\n    // If we're not waiting on any methods or subs, we can reset the stores and\\n    // call the callbacks immediately.\\n    if (!self._waitingForQuiescence()) {\\n      if (self._resetStores) {\\n        _.each(self._stores, function (s) {\\n          s.beginUpdate(0, true);\\n          s.endUpdate();\\n        });\\n        self._resetStores = false;\\n      }\\n      self._runAfterUpdateCallbacks();\\n    }\\n  },\\n\\n\\n  _processOneDataMessage: function (msg, updates) {\\n    var self = this;\\n    // Using underscore here so as not to need to capitalize.\\n    self['_process_' + msg.msg](msg, updates);\\n  },\\n\\n\\n  _livedata_data: function (msg) {\\n    var self = this;\\n\\n    // collection name -> array of messages\\n    var updates = {};\\n\\n    if (self._waitingForQuiescence()) {\\n      self._messagesBufferedUntilQuiescence.push(msg);\\n\\n      if (msg.msg === \\\"nosub\\\")\\n        delete self._subsBeingRevived[msg.id];\\n\\n      _.each(msg.subs || [], function (subId) {\\n        delete self._subsBeingRevived[subId];\\n      });\\n      _.each(msg.methods || [], function (methodId) {\\n        delete self._methodsBlockingQuiescence[methodId];\\n      });\\n\\n      if (self._waitingForQuiescence())\\n        return;\\n\\n      // No methods or subs are blocking quiescence!\\n      // We'll now process and all of our buffered messages, reset all stores,\\n      // and apply them all at once.\\n      _.each(self._messagesBufferedUntilQuiescence, function (bufferedMsg) {\\n        self._processOneDataMessage(bufferedMsg, updates);\\n      });\\n      self._messagesBufferedUntilQuiescence = [];\\n    } else {\\n      self._processOneDataMessage(msg, updates);\\n    }\\n\\n    if (self._resetStores || !_.isEmpty(updates)) {\\n      // Begin a transactional update of each store.\\n      _.each(self._stores, function (s, storeName) {\\n        s.beginUpdate(_.has(updates, storeName) ? updates[storeName].length : 0,\\n                      self._resetStores);\\n      });\\n      self._resetStores = false;\\n\\n      _.each(updates, function (updateMessages, storeName) {\\n        var store = self._stores[storeName];\\n        if (store) {\\n          _.each(updateMessages, function (updateMessage) {\\n            store.update(updateMessage);\\n          });\\n        } else {\\n          // Nobody's listening for this data. Queue it up until\\n          // someone wants it.\\n          // XXX memory use will grow without bound if you forget to\\n          // create a collection or just don't care about it... going\\n          // to have to do something about that.\\n          if (!_.has(self._updatesForUnknownStores, storeName))\\n            self._updatesForUnknownStores[storeName] = [];\\n          Array.prototype.push.apply(self._updatesForUnknownStores[storeName],\\n                                     updateMessages);\\n        }\\n      });\\n\\n      // End update transaction.\\n      _.each(self._stores, function (s) { s.endUpdate(); });\\n    }\\n\\n    self._runAfterUpdateCallbacks();\\n  },\\n\\n  // Call any callbacks deferred with _runWhenAllServerDocsAreFlushed whose\\n  // relevant docs have been flushed, as well as dataVisible callbacks at\\n  // reconnect-quiescence time.\\n  _runAfterUpdateCallbacks: function () {\\n    var self = this;\\n    var callbacks = self._afterUpdateCallbacks;\\n    self._afterUpdateCallbacks = [];\\n    _.each(callbacks, function (c) {\\n      c();\\n    });\\n  },\\n\\n  _pushUpdate: function (updates, collection, msg) {\\n    var self = this;\\n    if (!_.has(updates, collection)) {\\n      updates[collection] = [];\\n    }\\n    updates[collection].push(msg);\\n  },\\n\\n  _getServerDoc: function (collection, id) {\\n    var self = this;\\n    if (!_.has(self._serverDocuments, collection))\\n      return null;\\n    var serverDocsForCollection = self._serverDocuments[collection];\\n    return serverDocsForCollection.get(id) || null;\\n  },\\n\\n  _process_added: function (msg, updates) {\\n    var self = this;\\n    var id = LocalCollection._idParse(msg.id);\\n    var serverDoc = self._getServerDoc(msg.collection, id);\\n    if (serverDoc) {\\n      // Some outstanding stub wrote here.\\n      if (serverDoc.document !== undefined)\\n        throw new Error(\\\"Server sent add for existing id: \\\" + msg.id);\\n      serverDoc.document = msg.fields || {};\\n      serverDoc.document._id = id;\\n    } else {\\n      self._pushUpdate(updates, msg.collection, msg);\\n    }\\n  },\\n\\n  _process_changed: function (msg, updates) {\\n    var self = this;\\n    var serverDoc = self._getServerDoc(\\n      msg.collection, LocalCollection._idParse(msg.id));\\n    if (serverDoc) {\\n      if (serverDoc.document === undefined)\\n        throw new Error(\\\"Server sent changed for nonexisting id: \\\" + msg.id);\\n      LocalCollection._applyChanges(serverDoc.document, msg.fields);\\n    } else {\\n      self._pushUpdate(updates, msg.collection, msg);\\n    }\\n  },\\n\\n  _process_removed: function (msg, updates) {\\n    var self = this;\\n    var serverDoc = self._getServerDoc(\\n      msg.collection, LocalCollection._idParse(msg.id));\\n    if (serverDoc) {\\n      // Some outstanding stub wrote here.\\n      if (serverDoc.document === undefined)\\n        throw new Error(\\\"Server sent removed for nonexisting id:\\\" + msg.id);\\n      serverDoc.document = undefined;\\n    } else {\\n      self._pushUpdate(updates, msg.collection, {\\n        msg: 'removed',\\n        collection: msg.collection,\\n        id: msg.id\\n      });\\n    }\\n  },\\n\\n  _process_updated: function (msg, updates) {\\n    var self = this;\\n    // Process \\\"method done\\\" messages.\\n    _.each(msg.methods, function (methodId) {\\n      _.each(self._documentsWrittenByStub[methodId], function (written) {\\n        var serverDoc = self._getServerDoc(written.collection, written.id);\\n        if (!serverDoc)\\n          throw new Error(\\\"Lost serverDoc for \\\" + JSON.stringify(written));\\n        if (!serverDoc.writtenByStubs[methodId])\\n          throw new Error(\\\"Doc \\\" + JSON.stringify(written) +\\n                          \\\" not written by  method \\\" + methodId);\\n        delete serverDoc.writtenByStubs[methodId];\\n        if (_.isEmpty(serverDoc.writtenByStubs)) {\\n          // All methods whose stubs wrote this method have completed! We can\\n          // now copy the saved document to the database (reverting the stub's\\n          // change if the server did not write to this object, or applying the\\n          // server's writes if it did).\\n\\n          // This is a fake ddp 'replace' message.  It's just for talking\\n          // between livedata connections and minimongo.  (We have to stringify\\n          // the ID because it's supposed to look like a wire message.)\\n          self._pushUpdate(updates, written.collection, {\\n            msg: 'replace',\\n            id: LocalCollection._idStringify(written.id),\\n            replace: serverDoc.document\\n          });\\n          // Call all flush callbacks.\\n          _.each(serverDoc.flushCallbacks, function (c) {\\n            c();\\n          });\\n\\n          // Delete this completed serverDocument. Don't bother to GC empty\\n          // IdMaps inside self._serverDocuments, since there probably aren't\\n          // many collections and they'll be written repeatedly.\\n          self._serverDocuments[written.collection].remove(written.id);\\n        }\\n      });\\n      delete self._documentsWrittenByStub[methodId];\\n\\n      // We want to call the data-written callback, but we can't do so until all\\n      // currently buffered messages are flushed.\\n      var callbackInvoker = self._methodInvokers[methodId];\\n      if (!callbackInvoker)\\n        throw new Error(\\\"No callback invoker for method \\\" + methodId);\\n      self._runWhenAllServerDocsAreFlushed(\\n        _.bind(callbackInvoker.dataVisible, callbackInvoker));\\n    });\\n  },\\n\\n  _process_ready: function (msg, updates) {\\n    var self = this;\\n    // Process \\\"sub ready\\\" messages. \\\"sub ready\\\" messages don't take effect\\n    // until all current server documents have been flushed to the local\\n    // database. We can use a write fence to implement this.\\n    _.each(msg.subs, function (subId) {\\n      self._runWhenAllServerDocsAreFlushed(function () {\\n        var subRecord = self._subscriptions[subId];\\n        // Did we already unsubscribe?\\n        if (!subRecord)\\n          return;\\n        // Did we already receive a ready message? (Oops!)\\n        if (subRecord.ready)\\n          return;\\n        subRecord.readyCallback && subRecord.readyCallback();\\n        subRecord.ready = true;\\n        subRecord.readyDeps.changed();\\n      });\\n    });\\n  },\\n\\n  // Ensures that \\\"f\\\" will be called after all documents currently in\\n  // _serverDocuments have been written to the local cache. f will not be called\\n  // if the connection is lost before then!\\n  _runWhenAllServerDocsAreFlushed: function (f) {\\n    var self = this;\\n    var runFAfterUpdates = function () {\\n      self._afterUpdateCallbacks.push(f);\\n    };\\n    var unflushedServerDocCount = 0;\\n    var onServerDocFlush = function () {\\n      --unflushedServerDocCount;\\n      if (unflushedServerDocCount === 0) {\\n        // This was the last doc to flush! Arrange to run f after the updates\\n        // have been applied.\\n        runFAfterUpdates();\\n      }\\n    };\\n    _.each(self._serverDocuments, function (collectionDocs) {\\n      collectionDocs.forEach(function (serverDoc) {\\n        var writtenByStubForAMethodWithSentMessage = _.any(\\n          serverDoc.writtenByStubs, function (dummy, methodId) {\\n            var invoker = self._methodInvokers[methodId];\\n            return invoker && invoker.sentMessage;\\n          });\\n        if (writtenByStubForAMethodWithSentMessage) {\\n          ++unflushedServerDocCount;\\n          serverDoc.flushCallbacks.push(onServerDocFlush);\\n        }\\n      });\\n    });\\n    if (unflushedServerDocCount === 0) {\\n      // There aren't any buffered docs --- we can call f as soon as the current\\n      // round of updates is applied!\\n      runFAfterUpdates();\\n    }\\n  },\\n\\n  _livedata_nosub: function (msg) {\\n    var self = this;\\n\\n    // First pass it through _livedata_data, which only uses it to help get\\n    // towards quiescence.\\n    self._livedata_data(msg);\\n\\n    // Do the rest of our processing immediately, with no\\n    // buffering-until-quiescence.\\n\\n    // we weren't subbed anyway, or we initiated the unsub.\\n    if (!_.has(self._subscriptions, msg.id))\\n      return;\\n\\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback\\n    var errorCallback = self._subscriptions[msg.id].errorCallback;\\n    var stopCallback = self._subscriptions[msg.id].stopCallback;\\n\\n    self._subscriptions[msg.id].remove();\\n\\n    var meteorErrorFromMsg = function (msgArg) {\\n      return msgArg && msgArg.error && new Meteor.Error(\\n        msgArg.error.error, msgArg.error.reason, msgArg.error.details);\\n    }\\n\\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback\\n    if (errorCallback && msg.error) {\\n      errorCallback(meteorErrorFromMsg(msg));\\n    }\\n\\n    if (stopCallback) {\\n      stopCallback(meteorErrorFromMsg(msg));\\n    }\\n  },\\n\\n  _process_nosub: function () {\\n    // This is called as part of the \\\"buffer until quiescence\\\" process, but\\n    // nosub's effect is always immediate. It only goes in the buffer at all\\n    // because it's possible for a nosub to be the thing that triggers\\n    // quiescence, if we were waiting for a sub to be revived and it dies\\n    // instead.\\n  },\\n\\n  _livedata_result: function (msg) {\\n    // id, result or error. error has error (code), reason, details\\n\\n    var self = this;\\n\\n    // find the outstanding request\\n    // should be O(1) in nearly all realistic use cases\\n    if (_.isEmpty(self._outstandingMethodBlocks)) {\\n      Meteor._debug(\\\"Received method result but no methods outstanding\\\");\\n      return;\\n    }\\n    var currentMethodBlock = self._outstandingMethodBlocks[0].methods;\\n    var m;\\n    for (var i = 0; i < currentMethodBlock.length; i++) {\\n      m = currentMethodBlock[i];\\n      if (m.methodId === msg.id)\\n        break;\\n    }\\n\\n    if (!m) {\\n      Meteor._debug(\\\"Can't match method response to original method call\\\", msg);\\n      return;\\n    }\\n\\n    // Remove from current method block. This may leave the block empty, but we\\n    // don't move on to the next block until the callback has been delivered, in\\n    // _outstandingMethodFinished.\\n    currentMethodBlock.splice(i, 1);\\n\\n    if (_.has(msg, 'error')) {\\n      m.receiveResult(new Meteor.Error(\\n        msg.error.error, msg.error.reason,\\n        msg.error.details));\\n    } else {\\n      // msg.result may be undefined if the method didn't return a\\n      // value\\n      m.receiveResult(undefined, msg.result);\\n    }\\n  },\\n\\n  // Called by MethodInvoker after a method's callback is invoked.  If this was\\n  // the last outstanding method in the current block, runs the next block. If\\n  // there are no more methods, consider accepting a hot code push.\\n  _outstandingMethodFinished: function () {\\n    var self = this;\\n    if (self._anyMethodsAreOutstanding())\\n      return;\\n\\n    // No methods are outstanding. This should mean that the first block of\\n    // methods is empty. (Or it might not exist, if this was a method that\\n    // half-finished before disconnect/reconnect.)\\n    if (! _.isEmpty(self._outstandingMethodBlocks)) {\\n      var firstBlock = self._outstandingMethodBlocks.shift();\\n      if (! _.isEmpty(firstBlock.methods))\\n        throw new Error(\\\"No methods outstanding but nonempty block: \\\" +\\n                        JSON.stringify(firstBlock));\\n\\n      // Send the outstanding methods now in the first block.\\n      if (!_.isEmpty(self._outstandingMethodBlocks))\\n        self._sendOutstandingMethods();\\n    }\\n\\n    // Maybe accept a hot code push.\\n    self._maybeMigrate();\\n  },\\n\\n  // Sends messages for all the methods in the first block in\\n  // _outstandingMethodBlocks.\\n  _sendOutstandingMethods: function() {\\n    var self = this;\\n    if (_.isEmpty(self._outstandingMethodBlocks))\\n      return;\\n    _.each(self._outstandingMethodBlocks[0].methods, function (m) {\\n      m.sendMessage();\\n    });\\n  },\\n\\n  _livedata_error: function (msg) {\\n    Meteor._debug(\\\"Received error from server: \\\", msg.reason);\\n    if (msg.offendingMessage)\\n      Meteor._debug(\\\"For: \\\", msg.offendingMessage);\\n  },\\n\\n  _callOnReconnectAndSendAppropriateOutstandingMethods: function() {\\n    var self = this;\\n    var oldOutstandingMethodBlocks = self._outstandingMethodBlocks;\\n    self._outstandingMethodBlocks = [];\\n\\n    self.onReconnect();\\n\\n    if (_.isEmpty(oldOutstandingMethodBlocks))\\n      return;\\n\\n    // We have at least one block worth of old outstanding methods to try\\n    // again. First: did onReconnect actually send anything? If not, we just\\n    // restore all outstanding methods and run the first block.\\n    if (_.isEmpty(self._outstandingMethodBlocks)) {\\n      self._outstandingMethodBlocks = oldOutstandingMethodBlocks;\\n      self._sendOutstandingMethods();\\n      return;\\n    }\\n\\n    // OK, there are blocks on both sides. Special case: merge the last block of\\n    // the reconnect methods with the first block of the original methods, if\\n    // neither of them are \\\"wait\\\" blocks.\\n    if (!_.last(self._outstandingMethodBlocks).wait &&\\n        !oldOutstandingMethodBlocks[0].wait) {\\n      _.each(oldOutstandingMethodBlocks[0].methods, function (m) {\\n        _.last(self._outstandingMethodBlocks).methods.push(m);\\n\\n        // If this \\\"last block\\\" is also the first block, send the message.\\n        if (self._outstandingMethodBlocks.length === 1)\\n          m.sendMessage();\\n      });\\n\\n      oldOutstandingMethodBlocks.shift();\\n    }\\n\\n    // Now add the rest of the original blocks on.\\n    _.each(oldOutstandingMethodBlocks, function (block) {\\n      self._outstandingMethodBlocks.push(block);\\n    });\\n  },\\n\\n  // We can accept a hot code push if there are no methods in flight.\\n  _readyToMigrate: function() {\\n    var self = this;\\n    return _.isEmpty(self._methodInvokers);\\n  },\\n\\n  // If we were blocking a migration, see if it's now possible to continue.\\n  // Call whenever the set of outstanding/blocked methods shrinks.\\n  _maybeMigrate: function () {\\n    var self = this;\\n    if (self._retryMigrate && self._readyToMigrate()) {\\n      self._retryMigrate();\\n      self._retryMigrate = null;\\n    }\\n  }\\n});\\n\\nLivedataTest.Connection = Connection;\\n\\n// @param url {String} URL to Meteor app,\\n//     e.g.:\\n//     \\\"subdomain.meteor.com\\\",\\n//     \\\"http://subdomain.meteor.com\\\",\\n//     \\\"/\\\",\\n//     \\\"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\\\"\\n\\n/**\\n * @summary Connect to the server of a different Meteor application to subscribe to its document sets and invoke its remote methods.\\n * @locus Anywhere\\n * @param {String} url The URL of another Meteor application.\\n */\\nDDP.connect = function (url, options) {\\n  var ret = new Connection(url, options);\\n  allConnections.push(ret); // hack. see below.\\n  return ret;\\n};\\n\\n// Hack for `spiderable` package: a way to see if the page is done\\n// loading all the data it needs.\\n//\\nallConnections = [];\\nDDP._allSubscriptionsReady = function () {\\n  return _.all(allConnections, function (conn) {\\n    return _.all(conn._subscriptions, function (sub) {\\n      return sub.ready;\\n    });\\n  });\\n};\\n\",\"// Only create a server if we are in an environment with a HTTP server\\n// (as opposed to, eg, a command-line tool).\\n//\\n// Note: this whole conditional is a total hack to get around the fact that this\\n// package logically should be split into a ddp-client and ddp-server package;\\n// see https://github.com/meteor/meteor/issues/3452\\n//\\n// Until we do that, this conditional (and the weak dependency on webapp that\\n// should really be a strong dependency of the ddp-server package) allows you to\\n// build projects which use `ddp` in Node without wanting to run a DDP server\\n// (ie, allows you to act as if you were using the nonexistent `ddp-client`\\n// server package).\\nif (Package.webapp) {\\n  if (process.env.DDP_DEFAULT_CONNECTION_URL) {\\n    __meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL =\\n      process.env.DDP_DEFAULT_CONNECTION_URL;\\n  }\\n\\n  Meteor.server = new Server;\\n\\n  Meteor.refresh = function (notification) {\\n    DDPServer._InvalidationCrossbar.fire(notification);\\n  };\\n\\n  // Proxy the public methods of Meteor.server so they can\\n  // be called directly on Meteor.\\n  _.each(['publish', 'methods', 'call', 'apply', 'onConnection'],\\n         function (name) {\\n           Meteor[name] = _.bind(Meteor.server[name], Meteor.server);\\n         });\\n} else {\\n  // No server? Make these empty/no-ops.\\n  Meteor.server = null;\\n  Meteor.refresh = function (notification) {\\n  };\\n\\n  // Make these empty/no-ops too, so that non-webapp apps can still\\n  // depend on/use packages that use those functions.\\n  _.each(['publish', 'methods', 'onConnection'],\\n      function (name) {\\n        Meteor[name] = function () { };\\n      });\\n}\\n\\n// Meteor.server used to be called Meteor.default_server. Provide\\n// backcompat as a courtesy even though it was never documented.\\n// XXX COMPAT WITH 0.6.4\\nMeteor.default_server = Meteor.server;\\n\"]}\n\nC:\\socialite\\.meteor\\local\\build\\programs\\server\\packages\\routepolicy.js:\n   28  //                                                                                                             // 11\n   29  // \"network\": for network routes that should not conflict with static                                          // 12\n   30: // resources.  (For example, if \"/sockjs/\" is a network route, we                                              // 13\n   31: // shouldn't have \"/sockjs/red-sock.jpg\" as a static resource).                                                // 14\n   32  //                                                                                                             // 15\n   33  // \"static-online\": for static resources which should not be cached in                                         // 16\n\nC:\\socialite\\.meteor\\local\\build\\programs\\server\\packages\\routepolicy.js.map:\n    1: {\"version\":3,\"sources\":[\"routepolicy/routepolicy.js\"],\"names\":[],\"mappings\":\";;;;;;;;;;;;;;;;;AAAA,kE;AACA,qE;AACA,mE;AACA,qC;AACA,E;AACA,sE;AACA,mE;AACA,2C;AACA,E;AACA,+E;AACA,E;AACA,qE;AACA,iE;AACA,+D;AACA,E;AACA,sE;AACA,iE;AACA,mE;AACA,sE;AACA,+D;;AAEA,mE;AACA,mE;AACA,iE;AACA,2B;;AAEA,qB;;AAEA,wE;AACA,kB;AACA,2B;AACA,E;;AAEA,4C;;AAEA,+C;AACA,yD;AACA,I;;AAEA,8B;AACA,yD;AACA,mE;AACA,gB;AACA,I;;AAEA,8C;AACA,oB;;AAEA,oC;AACA,0D;;AAEA,0B;AACA,8C;;AAEA,sD;AACA,8C;AACA,8G;;AAEA,gB;AACA,I;;AAEA,yE;AACA,oB;AACA,iC;AACA,kB;AACA,iD;AACA,gD;AACA,+F;AACA,wD;AACA,6D;AACA,2D;AACA,4B;AACA,kB;AACA,K;AACA,mC;AACA,uF;AACA,yD;AACA,2C;AACA,4C;AACA,8D;AACA,O;AACA,iB;AACA,sE;AACA,4C;AACA,Q;AACA,kB;AACA,I;;AAEA,uC;AACA,oB;AACA,yC;AACA,yD;AACA,mE;AACA,gB;AACA,+B;AACA,0D;AACA,0C;AACA,I;;AAEA,8B;AACA,iC;AACA,I;;AAEA,4B;AACA,oB;AACA,8B;AACA,4D;AACA,yE;AACA,iD;AACA,O;AACA,e;AACA,yC;AACA,Q;AACA,kB;AACA,I;;AAEA,mC;AACA,oB;AACA,sB;AACA,2D;AACA,yB;AACA,+B;AACA,O;AACA,2B;AACA,G;AACA,G;;AAEA,2C\",\"file\":\"/packages/routepolicy.js\",\"sourcesContent\":[\"// In addition to listing specific files to be cached, the browser\\n// application cache manifest allows URLs to be designated as NETWORK\\n// (always fetched from the Internet) and FALLBACK (which we use to\\n// serve app HTML on arbitrary URLs).\\n//\\n// The limitation of the manifest file format is that the designations\\n// are by prefix only: if \\\"/foo\\\" is declared NETWORK then \\\"/foobar\\\"\\n// will also be treated as a network route.\\n//\\n// RoutePolicy is a low-level API for declaring the route type of URL prefixes:\\n//\\n// \\\"network\\\": for network routes that should not conflict with static\\n// resources.  (For example, if \\\"/sockjs/\\\" is a network route, we\\n// shouldn't have \\\"/sockjs/red-sock.jpg\\\" as a static resource).\\n//\\n// \\\"static-online\\\": for static resources which should not be cached in\\n// the app cache.  This is implemented by also adding them to the\\n// NETWORK section (as otherwise the browser would receive app HTML\\n// for them because of the FALLBACK section), but static-online routes\\n// don't need to be checked for conflict with static resources.\\n\\n// The route policy is a singleton in a running application, but we\\n// can't unit test the real singleton because messing with the real\\n// routes would break tinytest... so allow policy instances to be\\n// constructed for testing.\\n\\nRoutePolicyTest = {};\\n\\nvar RoutePolicyConstructor = RoutePolicyTest.Constructor = function () {\\n  var self = this;\\n  self.urlPrefixTypes = {};\\n};\\n\\n_.extend(RoutePolicyConstructor.prototype, {\\n\\n  urlPrefixMatches: function (urlPrefix, url) {\\n    return url.substr(0, urlPrefix.length) === urlPrefix;\\n  },\\n\\n  checkType: function (type) {\\n    if (! _.contains(['network', 'static-online'], type))\\n      return 'the route type must be \\\"network\\\" or \\\"static-online\\\"';\\n    return null;\\n  },\\n\\n  checkUrlPrefix: function (urlPrefix, type) {\\n    var self = this;\\n\\n    if (urlPrefix.charAt(0) !== '/')\\n      return 'a route URL prefix must begin with a slash';\\n\\n    if (urlPrefix === '/')\\n      return 'a route URL prefix cannot be /';\\n\\n    var existingType = self.urlPrefixTypes[urlPrefix];\\n    if (existingType && existingType !== type)\\n      return 'the route URL prefix ' + urlPrefix + ' has already been declared to be of type ' + existingType;\\n\\n    return null;\\n  },\\n\\n  checkForConflictWithStatic: function (urlPrefix, type, _testManifest) {\\n    var self = this;\\n    if (type === 'static-online')\\n      return null;\\n    if (!Package.webapp || !Package.webapp.WebApp\\n        || !Package.webapp.WebApp.clientPrograms\\n        || !Package.webapp.WebApp.clientPrograms[Package.webapp.WebApp.defaultArch].manifest) {\\n      // Hack: If we don't have a manifest, deal with it\\n      // gracefully. This lets us load livedata into a nodejs\\n      // environment that doesn't have a HTTP server (eg, a\\n      // command-line tool).\\n      return null;\\n    }\\n    var manifest = _testManifest ||\\n      Package.webapp.WebApp.clientPrograms[Package.webapp.WebApp.defaultArch].manifest;\\n    var conflict = _.find(manifest, function (resource) {\\n      return (resource.type === 'static' &&\\n              resource.where === 'client' &&\\n              self.urlPrefixMatches(urlPrefix, resource.url));\\n    });\\n    if (conflict)\\n      return ('static resource ' + conflict.url + ' conflicts with ' +\\n              type + ' route ' + urlPrefix);\\n    else\\n      return null;\\n  },\\n\\n  declare: function (urlPrefix, type) {\\n    var self = this;\\n    var problem = self.checkType(type) ||\\n                  self.checkUrlPrefix(urlPrefix, type) ||\\n                  self.checkForConflictWithStatic(urlPrefix, type);\\n    if (problem)\\n      throw new Error(problem);\\n    // TODO overlapping prefixes, e.g. /foo/ and /foo/bar/\\n    self.urlPrefixTypes[urlPrefix] = type;\\n  },\\n\\n  isValidUrl: function (url) {\\n    return url.charAt(0) === '/';\\n  },\\n\\n  classify: function (url) {\\n    var self = this;\\n    if (url.charAt(0) !== '/')\\n      throw new Error('url must be a relative URL: ' + url);\\n    var prefix = _.find(_.keys(self.urlPrefixTypes), function (_prefix) {\\n      return self.urlPrefixMatches(_prefix, url);\\n    });\\n    if (prefix)\\n      return self.urlPrefixTypes[prefix];\\n    else\\n      return null;\\n  },\\n\\n  urlPrefixesFor: function (type) {\\n    var self = this;\\n    var prefixes = [];\\n    _.each(self.urlPrefixTypes, function (_type, _prefix) {\\n      if (_type === type)\\n        prefixes.push(_prefix);\\n    });\\n    return prefixes.sort();\\n  }\\n});\\n\\nRoutePolicy = new RoutePolicyConstructor();\\n\"]}\n\nC:\\socialite\\.meteor\\local\\build\\programs\\server\\packages\\webapp.js:\n  168      return false;                                                                   // 147\n  169                                                                                      // 148\n  170:   // Avoid serving app HTML for declared routes such as /sockjs/.                   // 149\n  171    if (RoutePolicy.classify(url))                                                    // 150\n  172      return false;                                                                   // 151\n  ...\n  229                                                                                      // 208\n  230  // When we have a request pending, we want the socket timeout to be long, to        // 209\n  231: // give ourselves a while to serve it, and to allow sockjs long polls to            // 210\n  232  // complete.  On the other hand, we want to close idle sockets relatively           // 211\n  233  // quickly, so that we can shut down relatively promptly but cleanly, without       // 212\n\nC:\\socialite\\.meteor\\local\\build\\programs\\server\\packages\\webapp.js.map:\n    1: {\"version\":3,\"sources\":[\"webapp/webapp_server.js\"],\"names\":[],\"mappings\":\";;;;;;;;;;;;;;;;;;;;;AAAA,8B;;AAEA,2B;AACA,+B;AACA,2B;AACA,+B;AACA,6B;AACA,mC;;AAEA,qC;AACA,yC;AACA,+B;;AAEA,0C;AACA,kC;;AAEA,kC;AACA,mC;;AAEA,Y;AACA,qB;;AAEA,8B;AACA,Y;AACA,yD;AACA,mB;AACA,G;AACA,E;;AAEA,mC;;AAEA,8B;AACA,2B;;AAEA,+C;AACA,kB;;AAEA,uB;;AAEA,gC;AACA,uC;AACA,wB;AACA,4B;AACA,E;;AAEA,4C;AACA,yD;AACA,E;;AAEA,yB;AACA,E;AACA,iE;AACA,kE;AACA,+C;AACA,E;AACA,wE;AACA,+D;AACA,sE;AACA,kE;AACA,W;AACA,E;AACA,kD;AACA,uE;AACA,E;AACA,uE;AACA,iE;AACA,gE;AACA,E;AACA,6D;AACA,qD;AACA,E;AACA,8E;AACA,8E;AACA,8E;AACA,sB;AACA,E;AACA,uE;AACA,qE;AACA,8C;AACA,E;AACA,mE;AACA,W;;;AAGA,yC;AACA,iC;AACA,8B;AACA,oC;AACA,4C;AACA,qE;AACA,G;AACA,wB;AACA,E;;AAEA,kD;AACA,oD;AACA,U;AACA,sC;AACA,4B;AACA,4B;AACA,2B;AACA,I;AACA,E;;AAEA,qD;AACA,kD;;AAEA,2C;AACA,U;AACA,wD;AACA,iC;AACA,I;AACA,E;;AAEA,8E;AACA,gF;AACA,4D;AACA,4B;AACA,4C;AACA,+B;AACA,oD;AACA,mC;AACA,4B;AACA,a;AACA,uC;AACA,oE;AACA,6C;AACA,K;AACA,4B;AACA,E;AACA,+C;AACA,gC;AACA,E;;AAEA,+B;AACA,6B;AACA,sD;AACA,iB;;AAEA,kE;AACA,kE;AACA,oE;AACA,oE;AACA,8D;AACA,kD;AACA,8B;AACA,iB;;AAEA,iE;AACA,gC;AACA,iB;;AAEA,wD;AACA,c;AACA,E;;;AAGA,sE;AACA,+D;AACA,E;AACA,mE;AACA,sE;AACA,E;AACA,oE;AACA,sD;AACA,oE;AACA,oE;AACA,6C;AACA,qD;AACA,E;AACA,4D;AACA,oE;AACA,oB;;AAEA,4B;AACA,8D;AACA,2C;AACA,8C;AACA,yE;AACA,I;;AAEA,+D;AACA,8C;AACA,wE;AACA,uB;AACA,8B;AACA,S;AACA,I;AACA,kE;AACA,8C;AACA,wE;AACA,uB;AACA,8B;AACA,S;AACA,I;AACA,mD;AACA,iC;AACA,0C;AACA,oB;;AAEA,+B;AACA,6D;AACA,uD;AACA,I;AACA,G;;;;AAIA,4E;AACA,wE;AACA,yE;AACA,6E;AACA,iC;AACA,gE;AACA,oE;AACA,sC;AACA,gF;AACA,kC;AACA,gD;AACA,sE;AACA,mD;AACA,mC;AACA,gC;AACA,yC;AACA,K;AACA,iE;AACA,E;;;AAGA,4C;AACA,8C;AACA,0B;AACA,gB;AACA,oB;AACA,2B;;AAEA,qE;AACA,+D;AACA,oE;AACA,qB;AACA,wE;AACA,6B;AACA,+C;;AAEA,kD;;AAEA,sE;AACA,mE;AACA,0D;AACA,gC;AACA,+C;AACA,mC;AACA,c;AACA,K;;AAEA,uC;AACA,mE;AACA,oC;AACA,O;AACA,G;AACA,sC;AACA,E;;AAEA,6D;AACA,iE;AACA,4E;AACA,8C;;AAEA,+B;AACA,uC;AACA,kD;AACA,I;;AAEA,kB;AACA,+B;AACA,0E;AACA,2E;AACA,uC;AACA,qB;AACA,U;AACA,uC;AACA,2D;AACA,G;;AAEA,wC;AACA,c;AACA,uC;AACA,sD;AACA,0B;AACA,kC;AACA,mC;AACA,yC;AACA,oB;AACA,iC;AACA,gC;AACA,c;AACA,W;AACA,U;AACA,gF;AACA,+E;AACA,gF;AACA,+E;AACA,+E;AACA,uD;AACA,4C;AACA,6D;AACA,gF;AACA,wC;AACA,qE;AACA,wC;AACA,O;AACA,yB;AACA,I;AACA,E;;AAEA,4E;AACA,wC;AACA,oE;AACA,wD;AACA,E;AACA,2C;AACA,wE;AACA,wD;;AAEA,gB;;AAEA,qD;AACA,qC;AACA,gF;AACA,oD;AACA,W;AACA,W;AACA,G;AACA,sD;AACA,O;AACA,4C;AACA,e;AACA,W;AACA,W;AACA,G;;AAEA,oC;AACA,wB;AACA,6D;AACA,O;AACA,iB;AACA,c;AACA,I;;AAEA,iD;AACA,iD;AACA,kD;AACA,mE;AACA,W;AACA,mD;AACA,yD;AACA,gD;AACA,W;AACA,G;;AAEA,sC;AACA,W;AACA,W;AACA,G;;AAEA,4E;AACA,2E;AACA,Y;;AAEA,mC;;AAEA,kE;AACA,8D;AACA,kC;AACA,I;AACA,6E;AACA,8E;AACA,kE;AACA,8E;AACA,0E;AACA,0E;AACA,gD;AACA,6B;AACA,mC;AACA,8B;;AAEA,0E;AACA,4E;AACA,4B;AACA,I;AACA,6E;AACA,0E;AACA,0B;AACA,gC;AACA,kE;AACA,qC;AACA,G;;AAEA,2B;AACA,2E;AACA,mC;AACA,6D;AACA,oC;AACA,qE;AACA,qE;AACA,4C;AACA,wD;AACA,K;AACA,G;;AAEA,qB;AACA,4B;AACA,c;AACA,U;AACA,gC;AACA,qB;AACA,2E;AACA,mC;AACA,sD;AACA,2B;AACA,kB;AACA,Q;AACA,oC;AACA,+D;AACA,2B;AACA,kB;AACA,Q;AACA,iB;AACA,G;AACA,E;;AAEA,2C;AACA,kE;AACA,gD;;AAEA,0E;AACA,yB;AACA,sC;AACA,iD;AACA,E;;AAEA,mC;AACA,2B;AACA,iD;;AAEA,4C;AACA,2D;AACA,I;;AAEA,sD;AACA,kC;AACA,uB;AACA,+D;AACA,8D;AACA,sE;AACA,+C;AACA,qD;AACA,sE;AACA,qD;AACA,oE;AACA,6D;;AAEA,4D;AACA,4D;;AAEA,kD;;AAEA,2C;AACA,0C;AACA,oD;AACA,kE;AACA,4D;AACA,wC;AACA,4C;AACA,8C;AACA,6B;AACA,c;;AAEA,iC;AACA,iF;AACA,2C;AACA,6E;AACA,mE;AACA,+B;AACA,gB;AACA,a;AACA,W;AACA,W;;AAEA,uB;AACA,6B;AACA,4E;AACA,2D;AACA,oE;AACA,U;;AAEA,8C;;AAEA,qE;AACA,mD;AACA,8D;AACA,2C;AACA,0B;AACA,sB;AACA,U;AACA,Q;;AAEA,W;AACA,sE;AACA,yD;AACA,oD;AACA,kD;AACA,W;;AAEA,8B;AACA,kD;AACA,mB;AACA,oE;AACA,wB;AACA,O;AACA,O;AACA,I;;AAEA,qD;AACA,2E;AACA,gF;AACA,4E;AACA,gF;AACA,iC;AACA,sB;AACA,iC;AACA,oE;AACA,uE;AACA,iE;AACA,wE;AACA,4D;AACA,oE;AACA,wD;AACA,8D;AACA,sE;AACA,qB;AACA,mE;AACA,iC;AACA,kD;AACA,gC;AACA,S;AACA,O;AACA,M;;AAEA,kC;AACA,kE;AACA,qC;AACA,sD;AACA,uC;AACA,6C;AACA,S;;AAEA,8C;AACA,+B;;AAEA,qD;AACA,uD;AACA,2C;AACA,kE;AACA,Q;AACA,O;AACA,I;;AAEA,yC;;AAEA,c;AACA,sB;;AAEA,iD;AACA,8B;;AAEA,wE;AACA,4C;AACA,qC;AACA,8B;;AAEA,2E;AACA,sB;AACA,oC;AACA,0C;AACA,a;AACA,a;AACA,K;AACA,uB;AACA,6B;AACA,c;AACA,K;;AAEA,6C;AACA,8C;AACA,oE;AACA,oD;AACA,gC;AACA,6E;AACA,+D;AACA,gF;AACA,4C;AACA,mF;AACA,6D;AACA,a;AACA,2E;AACA,a;AACA,4B;AACA,8B;AACA,qC;AACA,qB;AACA,Y;AACA,a;AACA,K;AACA,K;;AAEA,0E;AACA,6B;AACA,2B;;AAEA,0C;AACA,iD;AACA,qC;AACA,uB;AACA,wE;AACA,a;AACA,K;;AAEA,2E;AACA,kD;AACA,wC;AACA,iC;;AAEA,oC;AACA,+E;AACA,+E;AACA,mC;AACA,0C;AACA,6E;AACA,gB;AACA,a;AACA,K;AACA,gE;AACA,gC;AACA,K;;AAEA,qC;AACA,0B;AACA,oB;;AAEA,mB;AACA,iD;AACA,M;AACA,qB;AACA,sC;;AAEA,gD;;AAEA,wE;AACA,6E;AACA,gF;AACA,8D;AACA,0D;AACA,kC;AACA,8D;AACA,gB;AACA,uB;AACA,K;;AAEA,iD;AACA,wD;AACA,yC;AACA,6D;;AAEA,qE;AACA,mC;AACA,Y;AACA,+B;AACA,K;;AAEA,oB;AACA,S;AACA,qD;AACA,iB;AACA,gD;AACA,kC;AACA,gB;AACA,uB;AACA,K;;AAEA,gC;AACA,2B;AACA,c;AACA,qB;AACA,K;;AAEA,gE;AACA,+B;AACA,uB;AACA,c;AACA,K;;;AAGA,0C;AACA,gC;;AAEA,0E;AACA,+E;AACA,mC;AACA,8C;;AAEA,sE;AACA,gF;AACA,S;AACA,qE;;;AAGA,iB;AACA,oB;AACA,2C;AACA,2C;AACA,2B;AACA,mB;AACA,wC;AACA,mC;AACA,M;AACA,+B;AACA,+B;AACA,qC;AACA,U;AACA,Y;AACA,K;AACA,K;;AAEA,2E;AACA,gF;AACA,2B;AACA,0B;AACA,0C;;AAEA,+D;AACA,oD;AACA,mC;AACA,oC;AACA,6E;AACA,6C;AACA,0D;;AAEA,2C;AACA,kC;AACA,+C;;AAEA,qB;AACA,2C;AACA,kC;AACA,Q;;AAEA,oB;AACA,I;AACA,E;;;AAGA,kB;;;AAGA,gC;;AAEA,oD;AACA,8B;AACA,E;;AAEA,4D;AACA,+B;AACA,wC;AACA,E;;AAEA,2D;AACA,8B;AACA,wC;AACA,E;;AAEA,oE;AACA,wE;AACA,qE;AACA,sC;AACA,4B;AACA,mD;AACA,8D;AACA,E;;AAEA,qB;AACA,gD;AACA,wD\",\"file\":\"/packages/webapp.js\",\"sourcesContent\":[\"////////// Requires //////////\\n\\nvar fs = Npm.require(\\\"fs\\\");\\nvar http = Npm.require(\\\"http\\\");\\nvar os = Npm.require(\\\"os\\\");\\nvar path = Npm.require(\\\"path\\\");\\nvar url = Npm.require(\\\"url\\\");\\nvar crypto = Npm.require(\\\"crypto\\\");\\n\\nvar connect = Npm.require('connect');\\nvar useragent = Npm.require('useragent');\\nvar send = Npm.require('send');\\n\\nvar Future = Npm.require('fibers/future');\\nvar Fiber = Npm.require('fibers');\\n\\nvar SHORT_SOCKET_TIMEOUT = 5*1000;\\nvar LONG_SOCKET_TIMEOUT = 120*1000;\\n\\nWebApp = {};\\nWebAppInternals = {};\\n\\nWebAppInternals.NpmModules = {\\n  connect: {\\n    version: Npm.require('connect/package.json').version,\\n    module: connect\\n  }\\n};\\n\\nWebApp.defaultArch = 'web.browser';\\n\\n// XXX maps archs to manifests\\nWebApp.clientPrograms = {};\\n\\n// XXX maps archs to program path on filesystem\\nvar archPath = {};\\n\\nvar bundledJsCssPrefix;\\n\\nvar sha1 = function (contents) {\\n  var hash = crypto.createHash('sha1');\\n  hash.update(contents);\\n  return hash.digest('hex');\\n};\\n\\nvar readUtf8FileSync = function (filename) {\\n  return Meteor.wrapAsync(fs.readFile)(filename, 'utf8');\\n};\\n\\n// #BrowserIdentification\\n//\\n// We have multiple places that want to identify the browser: the\\n// unsupported browser page, the appcache package, and, eventually\\n// delivering browser polyfills only as needed.\\n//\\n// To avoid detecting the browser in multiple places ad-hoc, we create a\\n// Meteor \\\"browser\\\" object. It uses but does not expose the npm\\n// useragent module (we could choose a different mechanism to identify\\n// the browser in the future if we wanted to).  The browser object\\n// contains\\n//\\n// * `name`: the name of the browser in camel case\\n// * `major`, `minor`, `patch`: integers describing the browser version\\n//\\n// Also here is an early version of a Meteor `request` object, intended\\n// to be a high-level description of the request without exposing\\n// details of connect's low-level `req`.  Currently it contains:\\n//\\n// * `browser`: browser identification object described above\\n// * `url`: parsed url, including parsed query params\\n//\\n// As a temporary hack there is a `categorizeRequest` function on WebApp which\\n// converts a connect `req` to a Meteor `request`. This can go away once smart\\n// packages such as appcache are being passed a `request` object directly when\\n// they serve content.\\n//\\n// This allows `request` to be used uniformly: it is passed to the html\\n// attributes hook, and the appcache package can use it when deciding\\n// whether to generate a 404 for the manifest.\\n//\\n// Real routing / server side rendering will probably refactor this\\n// heavily.\\n\\n\\n// e.g. \\\"Mobile Safari\\\" => \\\"mobileSafari\\\"\\nvar camelCase = function (name) {\\n  var parts = name.split(' ');\\n  parts[0] = parts[0].toLowerCase();\\n  for (var i = 1;  i < parts.length;  ++i) {\\n    parts[i] = parts[i].charAt(0).toUpperCase() + parts[i].substr(1);\\n  }\\n  return parts.join('');\\n};\\n\\nvar identifyBrowser = function (userAgentString) {\\n  var userAgent = useragent.lookup(userAgentString);\\n  return {\\n    name: camelCase(userAgent.family),\\n    major: +userAgent.major,\\n    minor: +userAgent.minor,\\n    patch: +userAgent.patch\\n  };\\n};\\n\\n// XXX Refactor as part of implementing real routing.\\nWebAppInternals.identifyBrowser = identifyBrowser;\\n\\nWebApp.categorizeRequest = function (req) {\\n  return {\\n    browser: identifyBrowser(req.headers['user-agent']),\\n    url: url.parse(req.url, true)\\n  };\\n};\\n\\n// HTML attribute hooks: functions to be called to determine any attributes to\\n// be added to the '<html>' tag. Each function is passed a 'request' object (see\\n// #BrowserIdentification) and should return null or object.\\nvar htmlAttributeHooks = [];\\nvar getHtmlAttributes = function (request) {\\n  var combinedAttributes  = {};\\n  _.each(htmlAttributeHooks || [], function (hook) {\\n    var attributes = hook(request);\\n    if (attributes === null)\\n      return;\\n    if (typeof attributes !== 'object')\\n      throw Error(\\\"HTML attribute hook must return null or object\\\");\\n    _.extend(combinedAttributes, attributes);\\n  });\\n  return combinedAttributes;\\n};\\nWebApp.addHtmlAttributeHook = function (hook) {\\n  htmlAttributeHooks.push(hook);\\n};\\n\\n// Serve app HTML for this URL?\\nvar appUrl = function (url) {\\n  if (url === '/favicon.ico' || url === '/robots.txt')\\n    return false;\\n\\n  // NOTE: app.manifest is not a web standard like favicon.ico and\\n  // robots.txt. It is a file name we have chosen to use for HTML5\\n  // appcache URLs. It is included here to prevent using an appcache\\n  // then removing it from poisoning an app permanently. Eventually,\\n  // once we have server side routing, this won't be needed as\\n  // unknown URLs with return a 404 automatically.\\n  if (url === '/app.manifest')\\n    return false;\\n\\n  // Avoid serving app HTML for declared routes such as /sockjs/.\\n  if (RoutePolicy.classify(url))\\n    return false;\\n\\n  // we currently return app HTML on all URLs by default\\n  return true;\\n};\\n\\n\\n// We need to calculate the client hash after all packages have loaded\\n// to give them a chance to populate __meteor_runtime_config__.\\n//\\n// Calculating the hash during startup means that packages can only\\n// populate __meteor_runtime_config__ during load, not during startup.\\n//\\n// Calculating instead it at the beginning of main after all startup\\n// hooks had run would allow packages to also populate\\n// __meteor_runtime_config__ during startup, but that's too late for\\n// autoupdate because it needs to have the client hash at startup to\\n// insert the auto update version itself into\\n// __meteor_runtime_config__ to get it to the client.\\n//\\n// An alternative would be to give autoupdate a \\\"post-start,\\n// pre-listen\\\" hook to allow it to insert the auto update version at\\n// the right moment.\\n\\nMeteor.startup(function () {\\n  var calculateClientHash = WebAppHashing.calculateClientHash;\\n  WebApp.clientHash = function (archName) {\\n    archName = archName || WebApp.defaultArch;\\n    return calculateClientHash(WebApp.clientPrograms[archName].manifest);\\n  };\\n\\n  WebApp.calculateClientHashRefreshable = function (archName) {\\n    archName = archName || WebApp.defaultArch;\\n    return calculateClientHash(WebApp.clientPrograms[archName].manifest,\\n      function (name) {\\n        return name === \\\"css\\\";\\n      });\\n  };\\n  WebApp.calculateClientHashNonRefreshable = function (archName) {\\n    archName = archName || WebApp.defaultArch;\\n    return calculateClientHash(WebApp.clientPrograms[archName].manifest,\\n      function (name) {\\n        return name !== \\\"css\\\";\\n      });\\n  };\\n  WebApp.calculateClientHashCordova = function () {\\n    var archName = 'web.cordova';\\n    if (! WebApp.clientPrograms[archName])\\n      return 'none';\\n\\n    return calculateClientHash(\\n      WebApp.clientPrograms[archName].manifest, null, _.pick(\\n        __meteor_runtime_config__, 'PUBLIC_SETTINGS'));\\n  };\\n});\\n\\n\\n\\n// When we have a request pending, we want the socket timeout to be long, to\\n// give ourselves a while to serve it, and to allow sockjs long polls to\\n// complete.  On the other hand, we want to close idle sockets relatively\\n// quickly, so that we can shut down relatively promptly but cleanly, without\\n// cutting off anyone's response.\\nWebApp._timeoutAdjustmentRequestCallback = function (req, res) {\\n  // this is really just req.socket.setTimeout(LONG_SOCKET_TIMEOUT);\\n  req.setTimeout(LONG_SOCKET_TIMEOUT);\\n  // Insert our new finish listener to run BEFORE the existing one which removes\\n  // the response from the socket.\\n  var finishListeners = res.listeners('finish');\\n  // XXX Apparently in Node 0.12 this event is now called 'prefinish'.\\n  // https://github.com/joyent/node/commit/7c9b6070\\n  res.removeAllListeners('finish');\\n  res.on('finish', function () {\\n    res.setTimeout(SHORT_SOCKET_TIMEOUT);\\n  });\\n  _.each(finishListeners, function (l) { res.on('finish', l); });\\n};\\n\\n\\n// Will be updated by main before we listen.\\n// Map from client arch to boilerplate object.\\n// Boilerplate object has:\\n//   - func: XXX\\n//   - baseData: XXX\\nvar boilerplateByArch = {};\\n\\n// Given a request (as returned from `categorizeRequest`), return the\\n// boilerplate HTML to serve for that request. Memoizes on HTML\\n// attributes (used by, eg, appcache) and whether inline scripts are\\n// currently allowed.\\n// XXX so far this function is always called with arch === 'web.browser'\\nvar memoizedBoilerplate = {};\\nvar getBoilerplate = function (request, arch) {\\n\\n  var htmlAttributes = getHtmlAttributes(request);\\n\\n  // The only thing that changes from request to request (for now) are\\n  // the HTML attributes (used by, eg, appcache) and whether inline\\n  // scripts are allowed, so we can memoize based on that.\\n  var memHash = JSON.stringify({\\n    inlineScriptsAllowed: inlineScriptsAllowed,\\n    htmlAttributes: htmlAttributes,\\n    arch: arch\\n  });\\n\\n  if (! memoizedBoilerplate[memHash]) {\\n    memoizedBoilerplate[memHash] = boilerplateByArch[arch].toHTML({\\n      htmlAttributes: htmlAttributes\\n    });\\n  }\\n  return memoizedBoilerplate[memHash];\\n};\\n\\nWebAppInternals.generateBoilerplateInstance = function (arch,\\n                                                        manifest,\\n                                                        additionalOptions) {\\n  additionalOptions = additionalOptions || {};\\n\\n  var runtimeConfig = _.extend(\\n    _.clone(__meteor_runtime_config__),\\n    additionalOptions.runtimeConfigOverrides || {}\\n  );\\n\\n  var jsCssPrefix;\\n  if (arch === 'web.cordova') {\\n    // in cordova we serve assets up directly from disk so it doesn't make\\n    // sense to use the prefix (ordinarily something like a CDN) and go out\\n    // to the internet for those files.\\n    jsCssPrefix = '';\\n  } else {\\n    jsCssPrefix = bundledJsCssPrefix ||\\n      __meteor_runtime_config__.ROOT_URL_PATH_PREFIX || '';\\n  }\\n\\n  return new Boilerplate(arch, manifest,\\n    _.extend({\\n      pathMapper: function (itemPath) {\\n        return path.join(archPath[arch], itemPath); },\\n      baseDataExtension: {\\n        additionalStaticJs: _.map(\\n          additionalStaticJs || [],\\n          function (contents, pathname) {\\n            return {\\n              pathname: pathname,\\n              contents: contents\\n            };\\n          }\\n        ),\\n        // Convert to a JSON string, then get rid of most weird characters, then\\n        // wrap in double quotes. (The outermost JSON.stringify really ought to\\n        // just be \\\"wrap in double quotes\\\" but we use it to be safe.) This might\\n        // end up inside a <script> tag so we need to be careful to not include\\n        // \\\"</script>\\\", but normal {{spacebars}} escaping escapes too much! See\\n        // https://github.com/meteor/meteor/issues/3730\\n        meteorRuntimeConfig: JSON.stringify(\\n          encodeURIComponent(JSON.stringify(runtimeConfig))),\\n        rootUrlPathPrefix: __meteor_runtime_config__.ROOT_URL_PATH_PREFIX || '',\\n        bundledJsCssPrefix: jsCssPrefix,\\n        inlineScriptsAllowed: WebAppInternals.inlineScriptsAllowed(),\\n        inline: additionalOptions.inline\\n      }\\n    }, additionalOptions)\\n  );\\n};\\n\\n// A mapping from url path to \\\"info\\\". Where \\\"info\\\" has the following fields:\\n// - type: the type of file to be served\\n// - cacheable: optionally, whether the file should be cached or not\\n// - sourceMapUrl: optionally, the url of the source map\\n//\\n// Info also contains one of the following:\\n// - content: the stringified content that should be served at this path\\n// - absolutePath: the absolute path on disk to the file\\n\\nvar staticFiles;\\n\\n// Serve static files from the manifest or added with\\n// `addStaticJs`. Exported for tests.\\nWebAppInternals.staticFilesMiddleware = function (staticFiles, req, res, next) {\\n  if ('GET' != req.method && 'HEAD' != req.method) {\\n    next();\\n    return;\\n  }\\n  var pathname = connect.utils.parseUrl(req).pathname;\\n  try {\\n    pathname = decodeURIComponent(pathname);\\n  } catch (e) {\\n    next();\\n    return;\\n  }\\n\\n  var serveStaticJs = function (s) {\\n    res.writeHead(200, {\\n      'Content-type': 'application/javascript; charset=UTF-8'\\n    });\\n    res.write(s);\\n    res.end();\\n  };\\n\\n  if (pathname === \\\"/meteor_runtime_config.js\\\" &&\\n      ! WebAppInternals.inlineScriptsAllowed()) {\\n    serveStaticJs(\\\"__meteor_runtime_config__ = \\\" +\\n                  JSON.stringify(__meteor_runtime_config__) + \\\";\\\");\\n    return;\\n  } else if (_.has(additionalStaticJs, pathname) &&\\n              ! WebAppInternals.inlineScriptsAllowed()) {\\n    serveStaticJs(additionalStaticJs[pathname]);\\n    return;\\n  }\\n\\n  if (!_.has(staticFiles, pathname)) {\\n    next();\\n    return;\\n  }\\n\\n  // We don't need to call pause because, unlike 'static', once we call into\\n  // 'send' and yield to the event loop, we never call another handler with\\n  // 'next'.\\n\\n  var info = staticFiles[pathname];\\n\\n  // Cacheable files are files that should never change. Typically\\n  // named by their hash (eg meteor bundled js and css files).\\n  // We cache them ~forever (1yr).\\n  //\\n  // We cache non-cacheable files anyway. This isn't really correct, as users\\n  // can change the files and changes won't propagate immediately. However, if\\n  // we don't cache them, browsers will 'flicker' when rerendering\\n  // images. Eventually we will probably want to rewrite URLs of static assets\\n  // to include a query parameter to bust caches. That way we can both get\\n  // good caching behavior and allow users to change assets without delay.\\n  // https://github.com/meteor/meteor/issues/773\\n  var maxAge = info.cacheable\\n        ? 1000 * 60 * 60 * 24 * 365\\n        : 1000 * 60 * 60 * 24;\\n\\n  // Set the X-SourceMap header, which current Chrome, FireFox, and Safari\\n  // understand.  (The SourceMap header is slightly more spec-correct but FF\\n  // doesn't understand it.)\\n  //\\n  // You may also need to enable source maps in Chrome: open dev tools, click\\n  // the gear in the bottom right corner, and select \\\"enable source maps\\\".\\n  if (info.sourceMapUrl) {\\n    res.setHeader('X-SourceMap',\\n                  __meteor_runtime_config__.ROOT_URL_PATH_PREFIX +\\n                  info.sourceMapUrl);\\n  }\\n\\n  if (info.type === \\\"js\\\") {\\n    res.setHeader(\\\"Content-Type\\\", \\\"application/javascript; charset=UTF-8\\\");\\n  } else if (info.type === \\\"css\\\") {\\n    res.setHeader(\\\"Content-Type\\\", \\\"text/css; charset=UTF-8\\\");\\n  } else if (info.type === \\\"json\\\") {\\n    res.setHeader(\\\"Content-Type\\\", \\\"application/json; charset=UTF-8\\\");\\n    // XXX if it is a manifest we are serving, set additional headers\\n    if (/\\\\/manifest.json$/.test(pathname)) {\\n      res.setHeader(\\\"Access-Control-Allow-Origin\\\", \\\"*\\\");\\n    }\\n  }\\n\\n  if (info.content) {\\n    res.write(info.content);\\n    res.end();\\n  } else {\\n    send(req, info.absolutePath)\\n      .maxage(maxAge)\\n      .hidden(true)  // if we specified a dotfile in the manifest, serve it\\n      .on('error', function (err) {\\n        Log.error(\\\"Error serving static file \\\" + err);\\n        res.writeHead(500);\\n        res.end();\\n      })\\n      .on('directory', function () {\\n        Log.error(\\\"Unexpected directory \\\" + info.absolutePath);\\n        res.writeHead(500);\\n        res.end();\\n      })\\n      .pipe(res);\\n  }\\n};\\n\\nvar getUrlPrefixForArch = function (arch) {\\n  // XXX we rely on the fact that arch names don't contain slashes\\n  // in that case we would need to uri escape it\\n\\n  // We add '__' to the beginning of non-standard archs to \\\"scope\\\" the url\\n  // to Meteor internals.\\n  return arch === WebApp.defaultArch ?\\n    '' : '/' + '__' + arch.replace(/^web\\\\./, '');\\n};\\n\\nvar runWebAppServer = function () {\\n  var shuttingDown = false;\\n  var syncQueue = new Meteor._SynchronousQueue();\\n\\n  var getItemPathname = function (itemUrl) {\\n    return decodeURIComponent(url.parse(itemUrl).pathname);\\n  };\\n\\n  WebAppInternals.reloadClientPrograms = function () {\\n    syncQueue.runTask(function() {\\n      staticFiles = {};\\n      var generateClientProgram = function (clientPath, arch) {\\n        // read the control for the client we'll be serving up\\n        var clientJsonPath = path.join(__meteor_bootstrap__.serverDir,\\n                                   clientPath);\\n        var clientDir = path.dirname(clientJsonPath);\\n        var clientJson = JSON.parse(readUtf8FileSync(clientJsonPath));\\n        if (clientJson.format !== \\\"web-program-pre1\\\")\\n          throw new Error(\\\"Unsupported format for client assets: \\\" +\\n                          JSON.stringify(clientJson.format));\\n\\n        if (! clientJsonPath || ! clientDir || ! clientJson)\\n          throw new Error(\\\"Client config file not parsed.\\\");\\n\\n        var urlPrefix = getUrlPrefixForArch(arch);\\n\\n        var manifest = clientJson.manifest;\\n        _.each(manifest, function (item) {\\n          if (item.url && item.where === \\\"client\\\") {\\n            staticFiles[urlPrefix + getItemPathname(item.url)] = {\\n              absolutePath: path.join(clientDir, item.path),\\n              cacheable: item.cacheable,\\n              // Link from source to its map\\n              sourceMapUrl: item.sourceMapUrl,\\n              type: item.type\\n            };\\n\\n            if (item.sourceMap) {\\n              // Serve the source map too, under the specified URL. We assume all\\n              // source maps are cacheable.\\n              staticFiles[urlPrefix + getItemPathname(item.sourceMapUrl)] = {\\n                absolutePath: path.join(clientDir, item.sourceMap),\\n                cacheable: true\\n              };\\n            }\\n          }\\n        });\\n\\n        var program = {\\n          manifest: manifest,\\n          version: WebAppHashing.calculateClientHash(manifest, null, _.pick(\\n            __meteor_runtime_config__, 'PUBLIC_SETTINGS')),\\n          PUBLIC_SETTINGS: __meteor_runtime_config__.PUBLIC_SETTINGS\\n        };\\n\\n        WebApp.clientPrograms[arch] = program;\\n\\n        // Serve the program as a string at /foo/<arch>/manifest.json\\n        // XXX change manifest.json -> program.json\\n        staticFiles[path.join(urlPrefix, 'manifest.json')] = {\\n          content: JSON.stringify(program),\\n          cacheable: true,\\n          type: \\\"json\\\"\\n        };\\n      };\\n\\n      try {\\n        var clientPaths = __meteor_bootstrap__.configJson.clientPaths;\\n        _.each(clientPaths, function (clientPath, arch) {\\n          archPath[arch] = path.dirname(clientPath);\\n          generateClientProgram(clientPath, arch);\\n        });\\n\\n        // Exported for tests.\\n        WebAppInternals.staticFiles = staticFiles;\\n      } catch (e) {\\n        Log.error(\\\"Error reloading the client program: \\\" + e.stack);\\n        process.exit(1);\\n      }\\n    });\\n  };\\n\\n  WebAppInternals.generateBoilerplate = function () {\\n    // This boilerplate will be served to the mobile devices when used with\\n    // Meteor/Cordova for the Hot-Code Push and since the file will be served by\\n    // the device's server, it is important to set the DDP url to the actual\\n    // Meteor server accepting DDP connections and not the device's file server.\\n    var defaultOptionsForArch = {\\n      'web.cordova': {\\n        runtimeConfigOverrides: {\\n          // XXX We use absoluteUrl() here so that we serve https://\\n          // URLs to cordova clients if force-ssl is in use. If we were\\n          // to use __meteor_runtime_config__.ROOT_URL instead of\\n          // absoluteUrl(), then Cordova clients would immediately get a\\n          // HCP setting their DDP_DEFAULT_CONNECTION_URL to\\n          // http://example.meteor.com. This breaks the app, because\\n          // force-ssl doesn't serve CORS headers on 302\\n          // redirects. (Plus it's undesirable to have clients\\n          // connecting to http://example.meteor.com when force-ssl is\\n          // in use.)\\n          DDP_DEFAULT_CONNECTION_URL: process.env.MOBILE_DDP_URL ||\\n            Meteor.absoluteUrl(),\\n          ROOT_URL: process.env.MOBILE_ROOT_URL ||\\n            Meteor.absoluteUrl()\\n        }\\n      }\\n    };\\n\\n    syncQueue.runTask(function() {\\n      _.each(WebApp.clientPrograms, function (program, archName) {\\n        boilerplateByArch[archName] =\\n          WebAppInternals.generateBoilerplateInstance(\\n            archName, program.manifest,\\n            defaultOptionsForArch[archName]);\\n      });\\n\\n      // Clear the memoized boilerplate cache.\\n      memoizedBoilerplate = {};\\n\\n      // Configure CSS injection for the default arch\\n      // XXX implement the CSS injection for all archs?\\n      WebAppInternals.refreshableAssets = {\\n        allCss: boilerplateByArch[WebApp.defaultArch].baseData.css\\n      };\\n    });\\n  };\\n\\n  WebAppInternals.reloadClientPrograms();\\n\\n  // webserver\\n  var app = connect();\\n\\n  // Auto-compress any json, javascript, or text.\\n  app.use(connect.compress());\\n\\n  // Packages and apps can add handlers that run before any other Meteor\\n  // handlers via WebApp.rawConnectHandlers.\\n  var rawConnectHandlers = connect();\\n  app.use(rawConnectHandlers);\\n\\n  // We're not a proxy; reject (without crashing) attempts to treat us like\\n  // one. (See #1212.)\\n  app.use(function(req, res, next) {\\n    if (RoutePolicy.isValidUrl(req.url)) {\\n      next();\\n      return;\\n    }\\n    res.writeHead(400);\\n    res.write(\\\"Not a proxy\\\");\\n    res.end();\\n  });\\n\\n  // Strip off the path prefix, if it exists.\\n  app.use(function (request, response, next) {\\n    var pathPrefix = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX;\\n    var url = Npm.require('url').parse(request.url);\\n    var pathname = url.pathname;\\n    // check if the path in the url starts with the path prefix (and the part\\n    // after the path prefix must start with a / if it exists.)\\n    if (pathPrefix && pathname.substring(0, pathPrefix.length) === pathPrefix &&\\n       (pathname.length == pathPrefix.length\\n        || pathname.substring(pathPrefix.length, pathPrefix.length + 1) === \\\"/\\\")) {\\n      request.url = request.url.substring(pathPrefix.length);\\n      next();\\n    } else if (pathname === \\\"/favicon.ico\\\" || pathname === \\\"/robots.txt\\\") {\\n      next();\\n    } else if (pathPrefix) {\\n      response.writeHead(404);\\n      response.write(\\\"Unknown path\\\");\\n      response.end();\\n    } else {\\n      next();\\n    }\\n  });\\n\\n  // Parse the query string into res.query. Used by oauth_server, but it's\\n  // generally pretty handy..\\n  app.use(connect.query());\\n\\n  // Serve static files from the manifest.\\n  // This is inspired by the 'static' middleware.\\n  app.use(function (req, res, next) {\\n    Fiber(function () {\\n     WebAppInternals.staticFilesMiddleware(staticFiles, req, res, next);\\n    }).run();\\n  });\\n\\n  // Packages and apps can add handlers to this via WebApp.connectHandlers.\\n  // They are inserted before our default handler.\\n  var packageAndAppHandlers = connect();\\n  app.use(packageAndAppHandlers);\\n\\n  var suppressConnectErrors = false;\\n  // connect knows it is an error handler because it has 4 arguments instead of\\n  // 3. go figure.  (It is not smart enough to find such a thing if it's hidden\\n  // inside packageAndAppHandlers.)\\n  app.use(function (err, req, res, next) {\\n    if (!err || !suppressConnectErrors || !req.headers['x-suppress-error']) {\\n      next(err);\\n      return;\\n    }\\n    res.writeHead(err.status, { 'Content-Type': 'text/plain' });\\n    res.end(\\\"An error message\\\");\\n  });\\n\\n  app.use(function (req, res, next) {\\n    if (! appUrl(req.url))\\n      return next();\\n\\n    var headers = {\\n      'Content-Type':  'text/html; charset=utf-8'\\n    };\\n    if (shuttingDown)\\n      headers['Connection'] = 'Close';\\n\\n    var request = WebApp.categorizeRequest(req);\\n\\n    if (request.url.query && request.url.query['meteor_css_resource']) {\\n      // In this case, we're requesting a CSS resource in the meteor-specific\\n      // way, but we don't have it.  Serve a static css file that indicates that\\n      // we didn't have it, so we can detect that and refresh.\\n      headers['Content-Type'] = 'text/css; charset=utf-8';\\n      res.writeHead(200, headers);\\n      res.write(\\\".meteor-css-not-found-error { width: 0px;}\\\");\\n      res.end();\\n      return undefined;\\n    }\\n\\n    // /packages/asdfsad ... /__cordova/dafsdf.js\\n    var pathname = connect.utils.parseUrl(req).pathname;\\n    var archKey = pathname.split('/')[1];\\n    var archKeyCleaned = 'web.' + archKey.replace(/^__/, '');\\n\\n    if (! /^__/.test(archKey) || ! _.has(archPath, archKeyCleaned)) {\\n      archKey = WebApp.defaultArch;\\n    } else {\\n      archKey = archKeyCleaned;\\n    }\\n\\n    var boilerplate;\\n    try {\\n      boilerplate = getBoilerplate(request, archKey);\\n    } catch (e) {\\n      Log.error(\\\"Error running template: \\\" + e);\\n      res.writeHead(500, headers);\\n      res.end();\\n      return undefined;\\n    }\\n\\n    res.writeHead(200, headers);\\n    res.write(boilerplate);\\n    res.end();\\n    return undefined;\\n  });\\n\\n  // Return 404 by default, if no other handlers serve this URL.\\n  app.use(function (req, res) {\\n    res.writeHead(404);\\n    res.end();\\n  });\\n\\n\\n  var httpServer = http.createServer(app);\\n  var onListeningCallbacks = [];\\n\\n  // After 5 seconds w/o data on a socket, kill it.  On the other hand, if\\n  // there's an outstanding request, give it a higher timeout instead (to avoid\\n  // killing long-polling requests)\\n  httpServer.setTimeout(SHORT_SOCKET_TIMEOUT);\\n\\n  // Do this here, and then also in livedata/stream_server.js, because\\n  // stream_server.js kills all the current request handlers when installing its\\n  // own.\\n  httpServer.on('request', WebApp._timeoutAdjustmentRequestCallback);\\n\\n\\n  // start up app\\n  _.extend(WebApp, {\\n    connectHandlers: packageAndAppHandlers,\\n    rawConnectHandlers: rawConnectHandlers,\\n    httpServer: httpServer,\\n    // For testing.\\n    suppressConnectErrors: function () {\\n      suppressConnectErrors = true;\\n    },\\n    onListening: function (f) {\\n      if (onListeningCallbacks)\\n        onListeningCallbacks.push(f);\\n      else\\n        f();\\n    }\\n  });\\n\\n  // Let the rest of the packages (and Meteor.startup hooks) insert connect\\n  // middlewares and update __meteor_runtime_config__, then keep going to set up\\n  // actually serving HTML.\\n  main = function (argv) {\\n    WebAppInternals.generateBoilerplate();\\n\\n    // only start listening after all the startup code has run.\\n    var localPort = parseInt(process.env.PORT) || 0;\\n    var host = process.env.BIND_IP;\\n    var localIp = host || '0.0.0.0';\\n    httpServer.listen(localPort, localIp, Meteor.bindEnvironment(function() {\\n      if (process.env.METEOR_PRINT_ON_LISTEN)\\n        console.log(\\\"LISTENING\\\"); // must match run-app.js\\n\\n      var callbacks = onListeningCallbacks;\\n      onListeningCallbacks = null;\\n      _.each(callbacks, function (x) { x(); });\\n\\n    }, function (e) {\\n      console.error(\\\"Error listening:\\\", e);\\n      console.error(e && e.stack);\\n    }));\\n\\n    return 'DAEMON';\\n  };\\n};\\n\\n\\nrunWebAppServer();\\n\\n\\nvar inlineScriptsAllowed = true;\\n\\nWebAppInternals.inlineScriptsAllowed = function () {\\n  return inlineScriptsAllowed;\\n};\\n\\nWebAppInternals.setInlineScriptsAllowed = function (value) {\\n  inlineScriptsAllowed = value;\\n  WebAppInternals.generateBoilerplate();\\n};\\n\\nWebAppInternals.setBundledJsCssPrefix = function (prefix) {\\n  bundledJsCssPrefix = prefix;\\n  WebAppInternals.generateBoilerplate();\\n};\\n\\n// Packages can call `WebAppInternals.addStaticJs` to specify static\\n// JavaScript to be included in the app. This static JS will be inlined,\\n// unless inline scripts have been disabled, in which case it will be\\n// served under `/<sha1 of contents>`.\\nvar additionalStaticJs = {};\\nWebAppInternals.addStaticJs = function (contents) {\\n  additionalStaticJs[\\\"/\\\" + sha1(contents) + \\\".js\\\"] = contents;\\n};\\n\\n// Exported for tests\\nWebAppInternals.getBoilerplate = getBoilerplate;\\nWebAppInternals.additionalStaticJs = additionalStaticJs;\\n\"]}\n\nC:\\socialite\\.meteor\\local\\build\\programs\\web.cordova\\packages\\ddp.js:\n   34  \n   35  /* Package-scope variables */\n   36: var DDP, LivedataTest, SockJS, toSockjsUrl, toWebsocketUrl, Heartbeat, SUPPORTED_DDP_VERSIONS, MethodInvocation, parseDDP, stringifyDDP, RandomStream, makeRpcSeed, allConnections;\n   37  \n   38  (function () {\n   ..\n   64  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n   65  //                                                                                                                //\n   66: // packages/ddp/sockjs-0.3.4.js                                                                                   //\n   67  //                                                                                                                //\n   68  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n   ..\n   70  // XXX METEOR changes in <METEOR>                                                                                 // 1\n   71                                                                                                                    // 2\n   72: /* SockJS client, version 0.3.4, http://sockjs.org, MIT License                                                   // 3\n   73                                                                                                                    // 4\n   74  Copyright (c) 2011-2012 VMware, Inc.                                                                              // 5\n   ..\n  100  //     [*] Including lib/index.js                                                                                 // 31\n  101  // Public object                                                                                                  // 32\n  102: SockJS = (function(){                                                                                             // 33\n  103                var _document = document;                                                                           // 34\n  104                var _window = window;                                                                               // 35\n  ...\n  302                                                                                                                    // 233\n  303  // <METEOR>                                                                                                       // 234\n  304: // https://github.com/sockjs/sockjs-client/issues/79                                                              // 235\n  305  utils.isSameOriginScheme = function(url_a, url_b) {                                                               // 236\n  306      if (!url_b) url_b = _window.location.href;                                                                    // 237\n  ...\n  406      }                                                                                                             // 337\n  407      if (!url) {                                                                                                   // 338\n  408:         throw new Error('Wrong url for SockJS');                                                                  // 339\n  409      }                                                                                                             // 340\n  410      if (!utils.flatUrl(url)) {                                                                                    // 341\n  411:         throw new Error('Only basic urls are supported in SockJS');                                               // 342\n  412      }                                                                                                             // 343\n  413                                                                                                                    // 344\n  ...\n  573          var protocol = _all_protocols[i];                                                                         // 504\n  574          // User can have a typo in protocol name.                                                                 // 505\n  575:         probed[protocol] = SockJS[protocol] &&                                                                    // 506\n  576:                            SockJS[protocol].enabled();                                                            // 507\n  577      }                                                                                                             // 508\n  578      return probed;                                                                                                // 509\n  ...\n  641                                                                                                                    // 572\n  642  // May be used by htmlfile jsonp and transports.                                                                  // 573\n  643: var MPrefix = '_sockjs_global';                                                                                   // 574\n  644  utils.createHook = function() {                                                                                   // 575\n  645      var window_id = 'a' + utils.random_string(8);                                                                 // 576\n  ...\n 1041                                                                                                                    // 972\n 1042                                                                                                                    // 973\n 1043: //         [*] Including lib/sockjs.js                                                                            // 974\n 1044  /*                                                                                                                // 975\n 1045   * ***** BEGIN LICENSE BLOCK *****                                                                                // 976\n ....\n 1050   */                                                                                                               // 981\n 1051                                                                                                                    // 982\n 1052: var SockJS = function(url, dep_protocols_whitelist, options) {                                                    // 983\n 1053:     if (!(this instanceof SockJS)) {                                                                              // 984\n 1054          // makes `new` optional                                                                                   // 985\n 1055:         return new SockJS(url, dep_protocols_whitelist, options);                                                 // 986\n 1056      }                                                                                                             // 987\n 1057                                                                                                                    // 988\n ....\n 1080              that._debug('Deprecated API: Use \"protocols_whitelist\" option ' +                                     // 1011\n 1081                          'instead of supplying protocol list as a second ' +                                       // 1012\n 1082:                         'parameter to SockJS constructor.');                                                      // 1013\n 1083          }                                                                                                         // 1014\n 1084      }                                                                                                             // 1015\n 1085      that._protocols = [];                                                                                         // 1016\n 1086      that.protocol = null;                                                                                         // 1017\n 1087:     that.readyState = SockJS.CONNECTING;                                                                          // 1018\n 1088      that._ir = createInfoReceiver(that._base_url);                                                                // 1019\n 1089      that._ir.onfinish = function(info, rtt) {                                                                     // 1020\n ....\n 1105  };                                                                                                                // 1036\n 1106  // Inheritance                                                                                                    // 1037\n 1107: SockJS.prototype = new REventTarget();                                                                            // 1038\n 1108                                                                                                                    // 1039\n 1109: SockJS.version = \"0.3.4\";                                                                                         // 1040\n 1110                                                                                                                    // 1041\n 1111: SockJS.CONNECTING = 0;                                                                                            // 1042\n 1112: SockJS.OPEN = 1;                                                                                                  // 1043\n 1113: SockJS.CLOSING = 2;                                                                                               // 1044\n 1114: SockJS.CLOSED = 3;                                                                                                // 1045\n 1115                                                                                                                    // 1046\n 1116: SockJS.prototype._debug = function() {                                                                            // 1047\n 1117      if (this._options.debug)                                                                                      // 1048\n 1118          utils.log.apply(utils, arguments);                                                                        // 1049\n 1119  };                                                                                                                // 1050\n 1120                                                                                                                    // 1051\n 1121: SockJS.prototype._dispatchOpen = function() {                                                                     // 1052\n 1122      var that = this;                                                                                              // 1053\n 1123:     if (that.readyState === SockJS.CONNECTING) {                                                                  // 1054\n 1124          if (that._transport_tref) {                                                                               // 1055\n 1125              clearTimeout(that._transport_tref);                                                                   // 1056\n 1126              that._transport_tref = null;                                                                          // 1057\n 1127          }                                                                                                         // 1058\n 1128:         that.readyState = SockJS.OPEN;                                                                            // 1059\n 1129          that.dispatchEvent(new SimpleEvent(\"open\"));                                                              // 1060\n 1130      } else {                                                                                                      // 1061\n ....\n 1135  };                                                                                                                // 1066\n 1136                                                                                                                    // 1067\n 1137: SockJS.prototype._dispatchMessage = function(data) {                                                              // 1068\n 1138      var that = this;                                                                                              // 1069\n 1139:     if (that.readyState !== SockJS.OPEN)                                                                          // 1070\n 1140              return;                                                                                               // 1071\n 1141      that.dispatchEvent(new SimpleEvent(\"message\", {data: data}));                                                 // 1072\n 1142  };                                                                                                                // 1073\n 1143                                                                                                                    // 1074\n 1144: SockJS.prototype._dispatchHeartbeat = function(data) {                                                            // 1075\n 1145      var that = this;                                                                                              // 1076\n 1146:     if (that.readyState !== SockJS.OPEN)                                                                          // 1077\n 1147          return;                                                                                                   // 1078\n 1148      that.dispatchEvent(new SimpleEvent('heartbeat', {}));                                                         // 1079\n 1149  };                                                                                                                // 1080\n 1150                                                                                                                    // 1081\n 1151: SockJS.prototype._didClose = function(code, reason, force) {                                                      // 1082\n 1152      var that = this;                                                                                              // 1083\n 1153:     if (that.readyState !== SockJS.CONNECTING &&                                                                  // 1084\n 1154:         that.readyState !== SockJS.OPEN &&                                                                        // 1085\n 1155:         that.readyState !== SockJS.CLOSING)                                                                       // 1086\n 1156              throw new Error('INVALID_STATE_ERR');                                                                 // 1087\n 1157      if (that._ir) {                                                                                               // 1088\n ....\n 1171                                                                                                                    // 1102\n 1172      if (!utils.userSetCode(code) &&                                                                               // 1103\n 1173:         that.readyState === SockJS.CONNECTING && !force) {                                                        // 1104\n 1174          if (that._try_next_protocol(close_event)) {                                                               // 1105\n 1175              return;                                                                                               // 1106\n ....\n 1180                                                  last_event: close_event});                                        // 1111\n 1181      }                                                                                                             // 1112\n 1182:     that.readyState = SockJS.CLOSED;                                                                              // 1113\n 1183                                                                                                                    // 1114\n 1184      utils.delay(function() {                                                                                      // 1115\n ....\n 1187  };                                                                                                                // 1118\n 1188                                                                                                                    // 1119\n 1189: SockJS.prototype._didMessage = function(data) {                                                                   // 1120\n 1190      var that = this;                                                                                              // 1121\n 1191      var type = data.slice(0, 1);                                                                                  // 1122\n ....\n 1214  };                                                                                                                // 1145\n 1215                                                                                                                    // 1146\n 1216: SockJS.prototype._try_next_protocol = function(close_event) {                                                     // 1147\n 1217      var that = this;                                                                                              // 1148\n 1218      if (that.protocol) {                                                                                          // 1149\n ....\n 1232          // Some protocols require access to `body`, what if were in                                               // 1163\n 1233          // the `head`?                                                                                            // 1164\n 1234:         if (SockJS[protocol] &&                                                                                   // 1165\n 1235:             SockJS[protocol].need_body === true &&                                                                // 1166\n 1236              (!_document.body ||                                                                                   // 1167\n 1237               (typeof _document.readyState !== 'undefined'                                                         // 1168\n ....\n 1245          }                                                                                                         // 1176\n 1246                                                                                                                    // 1177\n 1247:         if (!SockJS[protocol] ||                                                                                  // 1178\n 1248:               !SockJS[protocol].enabled(that._options)) {                                                         // 1179\n 1249              that._debug('Skipping transport:', protocol);                                                         // 1180\n 1250          } else {                                                                                                  // 1181\n 1251:             var roundTrips = SockJS[protocol].roundTrips || 1;                                                    // 1182\n 1252              var to = ((that._options.rto || 0) * roundTrips) || 5000;                                             // 1183\n 1253              that._transport_tref = utils.delay(to, function() {                                                   // 1184\n 1254:                 if (that.readyState === SockJS.CONNECTING) {                                                      // 1185\n 1255                      // I can't understand how it is possible to run                                               // 1186\n 1256                      // this timer, when the state is CLOSED, but                                                  // 1187\n ....\n 1264              that._debug('Opening transport:', protocol, ' url:'+trans_url,                                        // 1195\n 1265                          ' RTO:'+that._options.rto);                                                               // 1196\n 1266:             that._transport = new SockJS[protocol](that, trans_url,                                               // 1197\n 1267                                                     that._base_url);                                               // 1198\n 1268              return true;                                                                                          // 1199\n ....\n 1271  };                                                                                                                // 1202\n 1272                                                                                                                    // 1203\n 1273: SockJS.prototype.close = function(code, reason) {                                                                 // 1204\n 1274      var that = this;                                                                                              // 1205\n 1275      if (code && !utils.userSetCode(code))                                                                         // 1206\n 1276          throw new Error(\"INVALID_ACCESS_ERR\");                                                                    // 1207\n 1277:     if(that.readyState !== SockJS.CONNECTING &&                                                                   // 1208\n 1278:        that.readyState !== SockJS.OPEN) {                                                                         // 1209\n 1279          return false;                                                                                             // 1210\n 1280      }                                                                                                             // 1211\n 1281:     that.readyState = SockJS.CLOSING;                                                                             // 1212\n 1282      that._didClose(code || 1000, reason || \"Normal closure\");                                                     // 1213\n 1283      return true;                                                                                                  // 1214\n 1284  };                                                                                                                // 1215\n 1285                                                                                                                    // 1216\n 1286: SockJS.prototype.send = function(data) {                                                                          // 1217\n 1287      var that = this;                                                                                              // 1218\n 1288:     if (that.readyState === SockJS.CONNECTING)                                                                    // 1219\n 1289          throw new Error('INVALID_STATE_ERR');                                                                     // 1220\n 1290:     if (that.readyState === SockJS.OPEN) {                                                                        // 1221\n 1291          that._transport.doSend(utils.quote('' + data));                                                           // 1222\n 1292      }                                                                                                             // 1223\n ....\n 1294  };                                                                                                                // 1225\n 1295                                                                                                                    // 1226\n 1296: SockJS.prototype._applyInfo = function(info, rtt, protocols_whitelist) {                                          // 1227\n 1297      var that = this;                                                                                              // 1228\n 1298      that._options.info = info;                                                                                    // 1229\n ....\n 1309      that._protocols = utils.detectProtocols(probed, protocols_whitelist, info);                                   // 1240\n 1310  // <METEOR>                                                                                                       // 1241\n 1311: // https://github.com/sockjs/sockjs-client/issues/79                                                              // 1242\n 1312      // Hack to avoid XDR when using different protocols                                                           // 1243\n 1313      // We're on IE trying to do cross-protocol. jsonp only.                                                       // 1244\n ....\n 1318  // </METEOR>                                                                                                      // 1249\n 1319  };                                                                                                                // 1250\n 1320: //         [*] End of lib/sockjs.js                                                                               // 1251\n 1321                                                                                                                    // 1252\n 1322                                                                                                                    // 1253\n ....\n 1330   */                                                                                                               // 1261\n 1331                                                                                                                    // 1262\n 1332: var WebSocketTransport = SockJS.websocket = function(ri, trans_url) {                                             // 1263\n 1333      var that = this;                                                                                              // 1264\n 1334      var url = trans_url + '/websocket';                                                                           // 1265\n ....\n 1350      // navigates away from the page. In such situation let's lie -                                                // 1281\n 1351      // let's not open the ws connection at all. See:                                                              // 1282\n 1352:     // https://github.com/sockjs/sockjs-client/issues/28                                                          // 1283\n 1353      // https://bugzilla.mozilla.org/show_bug.cgi?id=696085                                                        // 1284\n 1354      that.unload_ref = utils.unload_add(function(){that.ws.close()});                                              // 1285\n ....\n 1667                                                                                                                    // 1598\n 1668                                                                                                                    // 1599\n 1669: var JsonPTransport = SockJS['jsonp-polling'] = function(ri, trans_url) {                                          // 1600\n 1670      utils.polluteGlobalNamespace();                                                                               // 1601\n 1671      var that = this;                                                                                              // 1602\n ....\n 1789                                                                                                                    // 1720\n 1790  // xhr-streaming                                                                                                  // 1721\n 1791: var XhrStreamingTransport = SockJS['xhr-streaming'] = function(ri, trans_url) {                                   // 1722\n 1792      this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XHRCorsObject);                                  // 1723\n 1793  };                                                                                                                // 1724\n ....\n 1815                                                                                                                    // 1746\n 1816  // xdr-streaming                                                                                                  // 1747\n 1817: var XdrStreamingTransport = SockJS['xdr-streaming'] = function(ri, trans_url) {                                   // 1748\n 1818      this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XDRObject);                                      // 1749\n 1819  };                                                                                                                // 1750\n ....\n 1829                                                                                                                    // 1760\n 1830  // xhr-polling                                                                                                    // 1761\n 1831: var XhrPollingTransport = SockJS['xhr-polling'] = function(ri, trans_url) {                                       // 1762\n 1832      this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRCorsObject);                                            // 1763\n 1833  };                                                                                                                // 1764\n ....\n 1840                                                                                                                    // 1771\n 1841  // xdr-polling                                                                                                    // 1772\n 1842: var XdrPollingTransport = SockJS['xdr-polling'] = function(ri, trans_url) {                                       // 1773\n 1843      this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XDRObject);                                                // 1774\n 1844  };                                                                                                                // 1775\n ....\n 1921      case 's':                                                                                                     // 1852\n 1922          that.iframeObj.loaded();                                                                                  // 1853\n 1923:         that.postMessage('s', JSON.stringify([SockJS.version, that.protocol, that.trans_url, that.base_url]));    // 1854\n 1924          break;                                                                                                    // 1855\n 1925      case 't':                                                                                                     // 1856\n ....\n 1983  utils.parent_origin = undefined;                                                                                  // 1914\n 1984                                                                                                                    // 1915\n 1985: SockJS.bootstrap_iframe = function() {                                                                            // 1916\n 1986      var facade;                                                                                                   // 1917\n 1987      curr_window_id = _document.location.hash.slice(1);                                                            // 1918\n ....\n 2003              var trans_url = p[2];                                                                                 // 1934\n 2004              var base_url = p[3];                                                                                  // 1935\n 2005:             if (version !== SockJS.version) {                                                                     // 1936\n 2006:                 utils.log(\"Incompatibile SockJS! Main site uses:\" +                                               // 1937\n 2007                            \" \\\"\" + version + \"\\\", the iframe:\" +                                                   // 1938\n 2008:                           \" \\\"\" + SockJS.version + \"\\\".\");                                                        // 1939\n 2009              }                                                                                                     // 1940\n 2010              if (!utils.flatUrl(trans_url) || !utils.flatUrl(base_url)) {                                          // 1941\n 2011:                 utils.log(\"Only basic urls are supported in SockJS\");                                             // 1942\n 2012                  return;                                                                                           // 1943\n 2013              }                                                                                                     // 1944\n ....\n 2067                                                                                                                    // 1998\n 2068  // <METEOR>                                                                                                       // 1999\n 2069:   // https://github.com/sockjs/sockjs-client/pull/129                                                             // 2000\n 2070    // var xo = new AjaxObject('GET', base_url + '/info');                                                          // 2001\n 2071                                                                                                                    // 2002\n ....\n 2143  var createInfoReceiver = function(base_url) {                                                                     // 2074\n 2144      if (utils.isSameOriginUrl(base_url)) {                                                                        // 2075\n 2145:         // If, for some reason, we have SockJS locally - there's no                                               // 2076\n 2146          // need to start up the complex machinery. Just use ajax.                                                 // 2077\n 2147          return new InfoReceiver(base_url, utils.XHRLocalObject);                                                  // 2078\n ....\n 2153      case 2:                                                                                                       // 2084\n 2154  // <METEOR>                                                                                                       // 2085\n 2155: // https://github.com/sockjs/sockjs-client/issues/79                                                              // 2086\n 2156          // XDR doesn't work across different schemes                                                              // 2087\n 2157          // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx\n ....\n 2191   */                                                                                                               // 2122\n 2192                                                                                                                    // 2123\n 2193: var EventSourceIframeTransport = SockJS['iframe-eventsource'] = function () {                                     // 2124\n 2194      var that = this;                                                                                              // 2125\n 2195      that.protocol = 'w-iframe-eventsource';                                                                       // 2126\n ....\n 2224   */                                                                                                               // 2155\n 2225                                                                                                                    // 2156\n 2226: var XhrPollingIframeTransport = SockJS['iframe-xhr-polling'] = function () {                                      // 2157\n 2227      var that = this;                                                                                              // 2158\n 2228      that.protocol = 'w-iframe-xhr-polling';                                                                       // 2159\n ....\n 2263  // production it should be only run in IE.                                                                        // 2194\n 2264                                                                                                                    // 2195\n 2265: var HtmlFileIframeTransport = SockJS['iframe-htmlfile'] = function () {                                           // 2196\n 2266      var that = this;                                                                                              // 2197\n 2267      that.protocol = 'w-iframe-htmlfile';                                                                          // 2198\n ....\n 2506                                                                                                                    // 2437\n 2507  // For testing                                                                                                    // 2438\n 2508: SockJS.getUtils = function(){                                                                                     // 2439\n 2509      return utils;                                                                                                 // 2440\n 2510  };                                                                                                                // 2441\n 2511                                                                                                                    // 2442\n 2512: SockJS.getIframeTransport = function(){                                                                           // 2443\n 2513      return IframeTransport;                                                                                       // 2444\n 2514  };                                                                                                                // 2445\n 2515  //         [*] End of lib/test-hooks.js                                                                           // 2446\n 2516                                                                                                                    // 2447\n 2517:                   return SockJS;                                                                                  // 2448\n 2518            })();                                                                                                   // 2449\n 2519: if ('_sockjs_onload' in window) setTimeout(_sockjs_onload, 1);                                                    // 2450\n 2520                                                                                                                    // 2451\n 2521  // AMD compliance                                                                                                 // 2452\n 2522  if (typeof define === 'function' && define.amd) {                                                                 // 2453\n 2523:     define('sockjs', [], function(){return SockJS;});                                                             // 2454\n 2524  }                                                                                                                 // 2455\n 2525  //     [*] End of lib/index.js                                                                                    // 2456\n ....\n 2540  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n 2541  //                                                                                                                //\n 2542: // packages/ddp/stream_client_sockjs.js                                                                           //\n 2543  //                                                                                                                //\n 2544  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n ....\n 2546  // @param url {String} URL to Meteor app                                                                          // 1\n 2547  //   \"http://subdomain.meteor.com/\" or \"/\" or                                                                     // 2\n 2548: //   \"ddp+sockjs://foo-**.meteor.com/sockjs\"                                                                      // 3\n 2549  LivedataTest.ClientStream = function (url, options) {                                                             // 4\n 2550    var self = this;                                                                                                // 5\n ....\n 2656    _heartbeat_timeout: function () {                                                                               // 111\n 2657      var self = this;                                                                                              // 112\n 2658:     Meteor._debug(\"Connection timeout. No sockjs heartbeat received.\");                                           // 113\n 2659      self._lostConnection(new DDP.ConnectionError(\"Heartbeat timed out\"));                                         // 114\n 2660    },                                                                                                              // 115\n ....\n 2673    },                                                                                                              // 128\n 2674                                                                                                                    // 129\n 2675:   _sockjsProtocolsWhitelist: function () {                                                                        // 130\n 2676      // only allow polling protocols. no streaming.  streaming                                                     // 131\n 2677      // makes safari spin.                                                                                         // 132\n ....\n 2683      // https://github.com/LearnBoost/socket.io/issues/193#issuecomment-7308865.                                   // 138\n 2684      //                                                                                                            // 139\n 2685:     // iOS <4 doesn't support websockets at all so sockjs will just                                               // 140\n 2686      // immediately fall back to http                                                                              // 141\n 2687      var noWebsockets = navigator &&                                                                               // 142\n ....\n 2700                                                                                                                    // 155\n 2701      var options = _.extend({                                                                                      // 156\n 2702:       protocols_whitelist:self._sockjsProtocolsWhitelist()                                                        // 157\n 2703:     }, self.options._sockjsOptions);                                                                              // 158\n 2704                                                                                                                    // 159\n 2705:     // Convert raw URL to SockJS URL each time we open a connection, so that we                                   // 160\n 2706      // can connect to random hostnames and get around browser per-host                                            // 161\n 2707      // connection limits.                                                                                         // 162\n 2708:     self.socket = new SockJS(toSockjsUrl(self.rawUrl), undefined, options);                                       // 163\n 2709      self.socket.onopen = function (data) {                                                                        // 164\n 2710        self._connected();                                                                                          // 165\n ....\n 2768  // @param url {String} URL to Meteor app, eg:                                                                     // 11\n 2769  //   \"/\" or \"madewith.meteor.com\" or \"https://foo.meteor.com\"                                                     // 12\n 2770: //   or \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"                                                            // 13\n 2771  // @returns {String} URL to the endpoint with the specific scheme and subPath, e.g.                               // 14\n 2772: // for scheme \"http\" and subPath \"sockjs\"                                                                         // 15\n 2773: //   \"http://subdomain.meteor.com/sockjs\" or \"/sockjs\"                                                            // 16\n 2774: //   or \"https://ddp--1234-foo.meteor.com/sockjs\"                                                                 // 17\n 2775  var translateUrl =  function(url, newSchemeBase, subPath) {                                                       // 18\n 2776    if (! newSchemeBase) {                                                                                          // 19\n ....\n 2778    }                                                                                                               // 21\n 2779                                                                                                                    // 22\n 2780:   var ddpUrlMatch = url.match(/^ddp(i?)\\+sockjs:\\/\\//);                                                           // 23\n 2781    var httpUrlMatch = url.match(/^http(s?):\\/\\//);                                                                 // 24\n 2782    var newScheme;                                                                                                  // 25\n ....\n 2827  };                                                                                                                // 70\n 2828                                                                                                                    // 71\n 2829: toSockjsUrl = function (url) {                                                                                    // 72\n 2830:   return translateUrl(url, \"http\", \"sockjs\");                                                                     // 73\n 2831  };                                                                                                                // 74\n 2832                                                                                                                    // 75\n ....\n 2836  };                                                                                                                // 79\n 2837                                                                                                                    // 80\n 2838: LivedataTest.toSockjsUrl = toSockjsUrl;                                                                           // 81\n 2839                                                                                                                    // 82\n 2840                                                                                                                    // 83\n ....\n 2897      }                                                                                                             // 140\n 2898                                                                                                                    // 141\n 2899:     if (options._sockjsOptions) {                                                                                 // 142\n 2900:       self.options._sockjsOptions = options._sockjsOptions;                                                       // 143\n 2901      }                                                                                                             // 144\n 2902                                                                                                                    // 145\n ....\n 3481  //   headers: extra headers to send on the websockets connection, for                                             // 11\n 3482  //     server-to-server DDP only                                                                                  // 12\n 3483: //   _sockjsOptions: Specifies options to pass through to the sockjs client                                       // 13\n 3484  //   onDDPNegotiationVersionFailure: callback when version negotiation fails.                                     // 14\n 3485  //                                                                                                                // 15\n ....\n 3523        retry: options.retry,                                                                                       // 53\n 3524        headers: options.headers,                                                                                   // 54\n 3525:       _sockjsOptions: options._sockjsOptions,                                                                     // 55\n 3526        // Used to keep some tests quiet, or for other cases in which                                               // 56\n 3527        // the right thing to do with connection errors is to silently                                              // 57\n ....\n 5080  //     \"http://subdomain.meteor.com\",                                                                             // 1610\n 5081  //     \"/\",                                                                                                       // 1611\n 5082: //     \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"                                                             // 1612\n 5083                                                                                                                    // 1613\n 5084  /**                                                                                                               // 1614\n\nC:\\socialite\\.meteor\\local\\build\\programs\\web.cordova\\packages\\ddp.js.map:\n    1  )]}'\n    2: {\"version\":3,\"sources\":[\"ddp/common.js\",\"ddp/sockjs-0.3.4.js\",\"ddp/stream_client_sockjs.js\",\"ddp/stream_client_common.js\",\"ddp/heartbeat.js\",\"ddp/livedata_common.js\",\"ddp/random_stream.js\",\"ddp/livedata_connection.js\",\"ddp/client_convenience.js\"],\"names\":[],\"mappings\":\";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,G;AACA,iB;AACA,kD;AACA,G;AACA,S;AACA,kB;;;;;;;;;;;;;;;;;;;ACLA,iC;;AAEA,+D;;AAEA,oC;;AAEA,4E;AACA,6E;AACA,4E;AACA,yE;AACA,qE;AACA,wD;;AAEA,0E;AACA,mD;;AAEA,0E;AACA,wE;AACA,2E;AACA,sE;AACA,6E;AACA,yE;AACA,a;AACA,E;;AAEA,wE;AACA,yC;AACA,i5F;AACA,Y;;AAEA,iC;AACA,gB;AACA,qB;AACA,uC;AACA,mC;AACA,6B;;;AAGA,4C;AACA,E;AACA,kC;AACA,uC;AACA,E;AACA,+B;AACA,gC;AACA,G;;AAEA,iD;AACA,2E;AACA,G;AACA,iC;AACA,0E;AACA,0B;AACA,8B;AACA,K;AACA,yC;AACA,wC;AACA,K;AACA,yC;AACA,gD;AACA,2B;AACA,K;AACA,W;AACA,E;;AAEA,6E;AACA,8D;AACA,e;AACA,K;AACA,yC;AACA,8C;AACA,qB;AACA,4B;AACA,sF;AACA,gB;AACA,8C;AACA,S;AACA,e;AACA,K;AACA,W;AACA,E;;AAEA,yD;AACA,uB;AACA,wD;AACA,uB;AACA,uC;AACA,K;AACA,kD;AACA,0D;AACA,oD;AACA,S;AACA,K;AACA,E;AACA,yC;;;AAGA,2C;AACA,E;AACA,kC;AACA,uC;AACA,E;AACA,+B;AACA,gC;AACA,G;;AAEA,uC;AACA,qB;AACA,qC;AACA,2B;AACA,iD;AACA,6B;AACA,S;AACA,K;AACA,E;;AAEA,6C;AACA,e;AACA,wB;AACA,8C;AACA,wB;AACA,sD;AACA,4B;AACA,K;AACA,+C;AACA,E;AACA,wC;;;AAGA,4C;AACA,E;AACA,kC;AACA,uC;AACA,E;AACA,+B;AACA,gC;AACA,G;;AAEA,qC;AACA,oB;AACA,gC;AACA,yB;AACA,E;AACA,8C;AACA,oB;AACA,2B;AACA,4B;;AAEA,wD;AACA,0B;AACA,0C;AACA,K;AACA,kC;AACA,+D;AACA,uD;AACA,S;AACA,K;AACA,E;;AAEA,sD;AACA,oB;AACA,2B;AACA,4B;;AAEA,qC;AACA,mC;AACA,K;AACA,yC;AACA,E;;AAEA,qD;AACA,oB;AACA,sD;AACA,mD;AACA,iE;AACA,iC;AACA,K;AACA,E;;AAEA,0C;AACA,oB;AACA,uB;AACA,8C;AACA,qC;AACA,K;AACA,yB;AACA,E;AACA,yC;;;AAGA,qC;AACA,E;AACA,kC;AACA,uC;AACA,E;AACA,+B;AACA,gC;AACA,G;;AAEA,kE;AACA,6C;AACA,4C;AACA,oB;AACA,+B;AACA,kF;AACA,K;AACA,wB;AACA,E;AACA,qC;AACA,2C;AACA,E;AACA,4C;AACA,kC;AACA,iC;AACA,oD;AACA,E;;AAEA,sD;AACA,iC;AACA,e;AACA,2C;AACA,2B;AACA,E;;AAEA,gD;AACA,+D;AACA,8C;;AAEA,iD;AACA,mB;AACA,mD;AACA,E;;AAEA,W;AACA,oD;AACA,mD;AACA,8C;;AAEA,+B;AACA,mB;AACA,iC;AACA,E;AACA,Y;;;AAGA,uC;AACA,sB;AACA,0C;AACA,sB;AACA,oC;AACA,c;AACA,uC;;AAEA,wC;AACA,2B;AACA,E;;AAEA,yC;AACA,uB;AACA,oC;AACA,4B;AACA,S;AACA,K;AACA,e;AACA,E;;AAEA,oB;;AAEA,2C;AACA,gC;AACA,8B;AACA,K;AACA,E;;AAEA,4C;AACA,8C;AACA,E;;AAEA,qC;AACA,2D;AACA,E;;AAEA,yE;AACA,gB;AACA,iC;AACA,Y;AACA,oB;AACA,uC;AACA,Y;AACA,oD;AACA,K;AACA,e;AACA,C;;AAEA,wB;AACA,8D;AACA,8C;AACA,K;AACA,E;;AAEA,kC;AACA,mB;AACA,8B;AACA,Y;AACA,2B;AACA,8C;AACA,U;AACA,K;AACA,E;;AAEA,+B;AACA,8D;AACA,E;;AAEA,uE;AACA,yE;AACA,W;AACA,4C;AACA,gB;AACA,mC;AACA,mC;AACA,Y;AACA,+D;AACA,0B;AACA,sD;AACA,yD;AACA,4D;AACA,sB;AACA,kC;AACA,O;AACA,+B;AACA,8D;AACA,iB;AACA,2B;AACA,kB;AACA,Q;AACA,K;AACA,e;AACA,gD;AACA,K;AACA,8B;AACA,mE;AACA,K;;AAEA,gC;AACA,kC;AACA,qC;AACA,K;AACA,6C;AACA,iC;AACA,2D;AACA,K;AACA,gB;AACA,6B;AACA,kC;;AAEA,sE;AACA,0E;AACA,sD;AACA,+B;AACA,0D;AACA,yD;AACA,gD;AACA,E;AACA,0B;AACA,e;AACA,E;;AAEA,iC;AACA,sC;AACA,sC;AACA,2B;AACA,qB;AACA,S;AACA,K;AACA,c;AACA,E;;AAEA,oC;AACA,yC;AACA,qB;AACA,2B;AACA,Y;AACA,oC;AACA,4C;AACA,K;AACA,E;;AAEA,gF;AACA,kD;AACA,wD;AACA,E;;AAEA,gC;AACA,iC;AACA,gB;AACA,c;AACA,K;AACA,8B;AACA,E;;;AAGA,yD;AACA,4G;AACA,gJ;AACA,mB;AACA,4E;AACA,4E;AACA,0E;AACA,4E;AACA,4E;AACA,4E;AACA,4E;AACA,8D;AACA,4E;AACA,4E;AACA,4E;AACA,4E;AACA,4E;AACA,4E;AACA,4E;AACA,4E;AACA,4E;AACA,4E;AACA,4E;AACA,4E;AACA,4E;AACA,4E;AACA,4E;AACA,4E;AACA,4E;AACA,4E;AACA,4E;AACA,4E;AACA,4E;AACA,0D;;AAEA,qE;AACA,8B;AACA,ghC;AACA,iB;;AAEA,8D;AACA,8D;AACA,iC;AACA,sC;AACA,6D;AACA,kC;AACA,W;AACA,K;AACA,8B;AACA,E;;AAEA,sE;AACA,c;AACA,yC;AACA,U;AACA,qB;AACA,c;AACA,4B;AACA,yC;AACA,K;AACA,4B;AACA,gD;AACA,kF;AACA,kB;AACA,O;AACA,4B;AACA,oB;AACA,E;;AAEA,qE;AACA,4D;AACA,2E;AACA,gC;AACA,mC;;AAEA,8D;AACA,kC;AACA,uC;AACA,sB;AACA,K;;AAEA,oE;;AAEA,wD;AACA,+B;AACA,O;AACA,C;;AAEA,kC;AACA,sC;AACA,sC;AACA,2C;AACA,wC;AACA,oC;AACA,oC;AACA,2C;AACA,uC;;AAEA,mC;AACA,oB;AACA,gD;AACA,yC;AACA,iD;AACA,8C;AACA,sD;AACA,K;AACA,kB;AACA,E;;AAEA,qE;AACA,gB;AACA,uB;AACA,mE;AACA,qD;AACA,8C;AACA,wC;AACA,K;AACA,uC;AACA,mC;AACA,wB;AACA,kC;AACA,gB;AACA,oC;AACA,mC;AACA,a;AACA,S;AACA,K;;AAEA,mB;AACA,mC;AACA,kC;AACA,K;;AAEA,mB;AACA,mD;AACA,wC;AACA,Y;AACA,8E;AACA,4C;AACA,gB;AACA,6C;AACA,4C;AACA,S;AACA,K;;AAEA,iB;AACA,iD;AACA,sC;AACA,Y;AACA,4E;AACA,0C;AACA,gB;AACA,6C;AACA,0C;AACA,S;AACA,K;AACA,qB;AACA,C;AACA,kC;;;AAGA,mC;AACA,E;AACA,kC;AACA,uC;AACA,E;AACA,+B;AACA,gC;AACA,G;;AAEA,gD;AACA,+B;AACA,+B;AACA,iD;AACA,gC;AACA,qB;AACA,gD;AACA,sC;AACA,kC;AACA,kC;AACA,4D;AACA,kB;AACA,a;AACA,kC;AACA,S;AACA,K;AACA,uC;AACA,E;;;;AAIA,0C;AACA,2C;AACA,E;AACA,+C;AACA,0D;AACA,yD;AACA,Y;AACA,qB;AACA,0E;AACA,uE;AACA,sD;AACA,kC;AACA,oD;AACA,K;AACA,E;;AAEA,0C;AACA,2C;AACA,E;AACA,+C;AACA,0D;AACA,4D;AACA,Y;AACA,sD;AACA,oD;AACA,K;AACA,E;;;AAGA,mB;AACA,qE;AACA,yB;;AAEA,2C;AACA,+B;AACA,yB;AACA,8B;AACA,M;AACA,E;;AAEA,mC;AACA,4B;AACA,wB;AACA,+B;AACA,E;;AAEA,mE;AACA,gE;AACA,8C;;AAEA,uC;AACA,qC;AACA,8B;AACA,uB;AACA,8C;AACA,K;AACA,e;AACA,E;AACA,kC;AACA,yB;AACA,8B;AACA,E;;;AAGA,4D;AACA,mD;AACA,yB;AACA,+B;AACA,2B;AACA,2C;AACA,gD;AACA,8B;AACA,M;AACA,8B;AACA,qB;AACA,uB;AACA,kE;AACA,qE;AACA,wB;AACA,mC;AACA,4B;AACA,0D;AACA,iB;AACA,8B;AACA,kB;AACA,yC;AACA,S;AACA,M;AACA,+B;AACA,qB;AACA,sB;AACA,8B;AACA,S;AACA,M;AACA,sC;AACA,a;AACA,oE;AACA,kC;AACA,iD;AACA,8D;AACA,a;AACA,uB;AACA,M;;AAEA,4B;AACA,kC;AACA,uC;AACA,qD;AACA,gC;AACA,iE;AACA,gE;AACA,2B;AACA,wE;AACA,M;AACA,uC;AACA,8D;AACA,2C;AACA,Y;AACA,mB;AACA,yB;AACA,wB;AACA,M;AACA,E;;AAEA,8D;AACA,4C;AACA,yB;AACA,e;AACA,+B;AACA,2B;AACA,M;AACA,8B;AACA,kB;AACA,uB;AACA,yC;AACA,kD;AACA,gC;AACA,6B;AACA,S;AACA,M;AACA,gC;AACA,kB;AACA,sB;AACA,8B;AACA,S;AACA,M;AACA,sC;AACA,a;AACA,oE;AACA,kC;AACA,iD;AACA,8D;AACA,a;AACA,uB;AACA,M;;AAEA,e;AACA,qC;AACA,4D;AACA,uC;AACA,gB;AACA,iD;AACA,qC;AACA,4B;AACA,yC;AACA,0B;AACA,4B;AACA,8D;AACA,2C;AACA,Y;AACA,mB;AACA,yB;AACA,wB;AACA,M;AACA,E;AACA,gC;;;AAGA,oC;AACA,E;AACA,kC;AACA,uC;AACA,E;AACA,+B;AACA,gC;AACA,G;;AAEA,qC;AACA,oE;;AAEA,2E;AACA,oB;;AAEA,S;AACA,wC;AACA,kB;;AAEA,oB;AACA,a;AACA,sE;AACA,sB;AACA,K;AACA,0D;AACA,gC;AACA,0E;AACA,K;;AAEA,6D;AACA,0D;AACA,yE;AACA,S;AACA,yC;AACA,gB;AACA,gD;AACA,mC;AACA,wB;AACA,e;AACA,M;;AAEA,wC;AACA,8E;AACA,mD;AACA,0C;AACA,K;AACA,+B;AACA,sC;AACA,8D;AACA,S;AACA,K;;AAEA,8C;AACA,uB;AACA,6B;AACA,mC;AACA,mB;AACA,sE;AACA,wD;AACA,qB;AACA,0C;AACA,8C;AACA,+B;AACA,8E;AACA,kD;;AAEA,kE;AACA,8C;AACA,qD;AACA,iB;AACA,sB;AACA,mB;AACA,sC;AACA,8E;AACA,kD;;AAEA,4D;AACA,qC;AACA,sB;AACA,a;AACA,S;AACA,M;AACA,2B;AACA,E;;AAEA,wD;AACA,oB;AACA,0B;AACA,sC;;AAEA,2C;AACA,+C;;AAEA,gB;AACA,a;AACA,6B;AACA,sB;AACA,K;AACA,sC;AACA,E;;AAEA,gD;AACA,oB;AACA,gB;AACA,wB;AACA,E;;AAEA,sD;AACA,sC;AACA,4D;AACA,E;AACA,kD;;AAEA,4E;AACA,oB;AACA,2B;AACA,2C;AACA,gC;AACA,W;AACA,O;AACA,E;AACA,mD;;;;AAIA,c;AACA,sD;AACA,mE;AACA,kE;AACA,oB;AACA,gE;AACA,E;AACA,4D;AACA,6D;AACA,oB;AACA,mC;AACA,2B;AACA,sE;;AAEA,4D;AACA,mC;AACA,6B;AACA,M;AACA,iC;AACA,kD;AACA,M;AACA,6B;AACA,mD;AACA,6B;AACA,M;AACA,mB;AACA,yE;AACA,S;AACA,0D;AACA,mC;AACA,+B;AACA,gB;AACA,kB;AACA,K;AACA,E;;AAEA,gD;AACA,oB;AACA,0B;AACA,sC;;AAEA,iE;AACA,+B;AACA,gB;AACA,a;AACA,6B;AACA,sB;AACA,K;AACA,sC;AACA,E;;AAEA,wC;AACA,oB;AACA,gB;AACA,wB;AACA,E;;AAEA,yB;AACA,yB;AACA,sE;AACA,kB;AACA,qC;AACA,8E;AACA,iB;AACA,K;AACA,iE;AACA,qD;AACA,iB;AACA,K;AACA,oC;AACA,iB;AACA,K;AACA,a;AACA,E;AACA,iC;;;AAGA,sC;AACA,E;AACA,kC;AACA,uC;AACA,E;AACA,+B;AACA,gC;AACA,G;;AAEA,8D;AACA,oC;AACA,+B;AACA,iE;AACA,K;;AAEA,yC;AACA,yE;AACA,sD;AACA,kB;AACA,mD;AACA,K;AACA,yC;AACA,4E;AACA,4C;AACA,mD;AACA,gE;AACA,Y;AACA,yB;AACA,0D;AACA,iD;AACA,4D;AACA,4D;AACA,yD;AACA,gB;AACA,uC;AACA,S;AACA,kC;AACA,6E;AACA,2E;AACA,4D;AACA,S;AACA,K;AACA,yB;AACA,yB;AACA,wC;AACA,kD;AACA,6C;AACA,wB;AACA,mB;AACA,qC;AACA,uD;AACA,oE;AACA,a;AACA,oC;AACA,wC;AACA,a;AACA,4D;AACA,6B;AACA,gB;AACA,mE;AACA,S;AACA,M;AACA,E;AACA,c;AACA,sC;;AAEA,yB;;AAEA,sB;AACA,gB;AACA,mB;AACA,kB;;AAEA,sC;AACA,4B;AACA,0C;AACA,E;;AAEA,6C;AACA,oB;AACA,gD;AACA,mC;AACA,+C;AACA,wC;AACA,S;AACA,sC;AACA,oD;AACA,Y;AACA,sE;AACA,sB;AACA,oD;AACA,K;AACA,E;;AAEA,oD;AACA,oB;AACA,wC;AACA,mB;AACA,iE;AACA,E;;AAEA,sD;AACA,oB;AACA,wC;AACA,e;AACA,yD;AACA,E;;AAEA,4D;AACA,oB;AACA,gD;AACA,0C;AACA,2C;AACA,iD;AACA,mB;AACA,wB;AACA,wB;AACA,K;;AAEA,0B;AACA,oC;AACA,+B;AACA,K;;AAEA,gD;AACA,mB;AACA,uB;AACA,4C;;AAEA,mC;AACA,0D;AACA,mD;AACA,mB;AACA,S;AACA,2D;AACA,gF;AACA,gE;AACA,0E;AACA,K;AACA,oC;;AAEA,4B;AACA,mD;AACA,mB;AACA,E;;AAEA,+C;AACA,oB;AACA,gC;AACA,kB;AACA,a;AACA,6B;AACA,c;AACA,a;AACA,wD;AACA,8C;AACA,8C;AACA,S;AACA,c;AACA,a;AACA,0D;AACA,uC;AACA,c;AACA,a;AACA,wD;AACA,+C;AACA,c;AACA,a;AACA,kC;AACA,c;AACA,K;AACA,E;;AAEA,6D;AACA,oB;AACA,wB;AACA,wE;AACA,6B;AACA,K;AACA,+B;AACA,2C;AACA,oC;AACA,K;;AAEA,c;AACA,+D;AACA,wB;AACA,yB;AACA,S;AACA,mE;AACA,sB;AACA,+B;AACA,kD;AACA,+B;AACA,yD;AACA,yD;AACA,8C;AACA,+C;AACA,iD;AACA,0C;AACA,e;AACA,wB;AACA,S;;AAEA,gC;AACA,yD;AACA,yD;AACA,gB;AACA,8D;AACA,qE;AACA,+D;AACA,4D;AACA,mE;AACA,gE;AACA,8D;AACA,gE;AACA,iB;AACA,e;;AAEA,gD;AACA,+E;AACA,0E;AACA,mD;AACA,mE;AACA,mE;AACA,wB;AACA,S;AACA,K;AACA,E;;AAEA,iD;AACA,oB;AACA,yC;AACA,8C;AACA,+C;AACA,yC;AACA,qB;AACA,K;AACA,qC;AACA,6D;AACA,gB;AACA,E;;AAEA,wC;AACA,oB;AACA,8C;AACA,6C;AACA,0C;AACA,uD;AACA,K;AACA,gB;AACA,E;;AAEA,wE;AACA,oB;AACA,8B;AACA,4B;AACA,4C;AACA,uD;AACA,gF;AACA,kD;AACA,sB;AACA,iB;AACA,qE;AACA,kB;AACA,wC;AACA,+E;AACA,W;AACA,oD;AACA,uD;AACA,2D;AACA,oD;AACA,yC;AACA,4C;AACA,K;AACA,Y;AACA,E;AACA,mC;;;AAGA,+C;AACA,E;AACA,kC;AACA,uC;AACA,E;AACA,+B;AACA,gC;AACA,G;;AAEA,qE;AACA,oB;AACA,uC;AACA,sC;AACA,mC;AACA,Y;AACA,kC;AACA,K;AACA,iB;AACA,mB;AACA,gE;;AAEA,wC;AACA,qC;AACA,oC;AACA,M;AACA,mE;AACA,4D;AACA,kE;AACA,oD;AACA,wD;AACA,0D;AACA,oE;AACA,kC;AACA,mF;AACA,M;AACA,E;;AAEA,sD;AACA,mC;AACA,E;;AAEA,qD;AACA,oB;AACA,qB;AACA,a;AACA,yC;AACA,mB;AACA,0C;AACA,mD;AACA,K;AACA,E;;AAEA,yC;AACA,yD;AACA,E;;AAEA,oE;AACA,mE;AACA,8D;AACA,oB;AACA,kC;AACA,4C;;;AAGA,4C;AACA,E;AACA,kC;AACA,uC;AACA,E;AACA,+B;AACA,gC;AACA,G;;AAEA,mC;AACA,8D;AACA,oB;AACA,0B;AACA,yB;AACA,E;AACA,qD;AACA,oB;AACA,mC;AACA,0B;AACA,6B;AACA,K;AACA,E;;AAEA,sE;AACA,mE;AACA,mE;AACA,sE;AACA,iE;AACA,mE;AACA,mE;AACA,2B;AACA,0D;AACA,oB;AACA,a;AACA,iC;AACA,8B;AACA,2B;AACA,M;AACA,uC;AACA,8B;AACA,6B;AACA,O;AACA,E;;AAEA,qD;AACA,oB;AACA,sC;AACA,6D;AACA,+F;AACA,kC;AACA,oC;AACA,yE;AACA,oB;AACA,0C;AACA,a;AACA,W;AACA,8B;AACA,K;AACA,E;;AAEA,uD;AACA,oB;AACA,0B;AACA,0B;AACA,K;AACA,2B;AACA,E;;AAEA,2D;AACA,oB;;AAEA,kC;AACA,qE;AACA,yE;AACA,wB;AACA,oC;AACA,yC;AACA,6B;AACA,2D;AACA,qC;AACA,+B;AACA,yC;AACA,K;AACA,+B;AACA,+B;AACA,0C;AACA,qB;AACA,8C;;AAEA,e;AACA,S;AACA,8E;AACA,qE;AACA,gB;AACA,mD;AACA,yB;AACA,K;AACA,mB;AACA,6B;AACA,kC;;AAEA,S;AACA,6B;AACA,gB;AACA,6E;AACA,K;AACA,kB;;AAEA,iC;AACA,oC;AACA,0E;AACA,kD;AACA,0C;AACA,qC;AACA,6D;AACA,qC;AACA,sB;AACA,wB;AACA,kE;AACA,qC;AACA,uB;AACA,M;AACA,+C;AACA,6C;AACA,yD;AACA,M;AACA,qB;AACA,E;;AAEA,6C;AACA,6C;AACA,oE;AACA,8C;AACA,sD;AACA,8C;AACA,U;AACA,uC;AACA,0C;AACA,U;AACA,M;AACA,E;AACA,yC;;;AAGA,oD;AACA,E;AACA,kC;AACA,uC;AACA,E;AACA,+B;AACA,gC;AACA,G;;AAEA,gC;AACA,mG;AACA,oB;AACA,qF;AACA,oD;AACA,a;AACA,mD;AACA,kD;AACA,wC;AACA,sB;AACA,oD;AACA,2B;AACA,S;AACA,qB;AACA,+B;AACA,sE;AACA,0B;AACA,kD;AACA,wD;AACA,sD;AACA,0B;AACA,4B;AACA,4B;AACA,S;AACA,M;;AAEA,qE;AACA,4B;AACA,2B;;AAEA,6C;AACA,qB;AACA,oC;AACA,6B;AACA,kC;AACA,2B;AACA,yC;AACA,iD;AACA,mC;AACA,kD;AACA,6B;AACA,qE;AACA,iB;AACA,qB;AACA,S;AACA,M;AACA,iC;AACA,wF;AACA,M;;AAEA,6C;AACA,sD;AACA,6D;AACA,mC;AACA,qB;AACA,0D;AACA,qC;AACA,8B;AACA,a;AACA,yB;AACA,4G;AACA,a;AACA,S;AACA,M;AACA,uC;AACA,yE;AACA,iE;AACA,iE;AACA,sE;AACA,kE;AACA,8B;AACA,8E;AACA,gD;AACA,mE;AACA,uE;AACA,8E;AACA,gE;AACA,+D;AACA,kD;AACA,yC;AACA,iB;AACA,2C;AACA,yC;AACA,0B;AACA,gC;AACA,gB;AACA,6C;AACA,wD;AACA,iH;AACA,iD;AACA,S;AACA,K;AACA,8C;AACA,4B;AACA,K;;AAEA,gF;AACA,kC;AACA,2G;AACA,gC;;AAEA,yD;AACA,+C;AACA,kB;AACA,oD;AACA,K;AACA,wB;AACA,E;AACA,iD;;;AAGA,mD;AACA,E;AACA,kC;AACA,uC;AACA,E;AACA,+B;AACA,gC;AACA,G;;AAEA,oE;AACA,iE;AACA,wE;AACA,c;AACA,qB;AACA,qC;AACA,4D;;;AAGA,wE;AACA,mC;AACA,oB;AACA,iB;AACA,+B;AACA,8C;AACA,0B;AACA,E;;AAEA,c;AACA,gD;;AAEA,sD;AACA,oB;AACA,mC;AACA,+B;AACA,mB;AACA,mC;AACA,oC;AACA,0C;AACA,a;AACA,S;AACA,2E;AACA,gC;AACA,kC;AACA,S;AACA,M;AACA,qE;AACA,2E;AACA,E;;AAEA,qC;AACA,gB;AACA,E;;AAEA,gC;;;AAGA,iD;AACA,oB;AACA,4B;AACA,0B;AACA,0B;AACA,K;AACA,qC;AACA,2B;AACA,E;;;AAGA,8D;AACA,4E;AACA,0C;AACA,0D;;AAEA,+D;AACA,2D;AACA,qB;;AAEA,4C;AACA,oC;AACA,0B;AACA,e;AACA,iE;AACA,wC;AACA,iC;AACA,kB;AACA,e;AACA,6D;AACA,iC;AACA,yB;AACA,kB;AACA,e;AACA,8E;AACA,wC;AACA,kB;AACA,S;AACA,M;;AAEA,2D;AACA,wC;AACA,2B;AACA,mC;AACA,yB;AACA,oF;AACA,S;AACA,M;AACA,gB;AACA,E;AACA,gD;;;AAGA,yC;AACA,E;AACA,kC;AACA,uC;AACA,E;AACA,+B;AACA,gC;AACA,G;;AAEA,uC;AACA,oD;;AAEA,0D;AACA,+E;AACA,oB;AACA,iB;AACA,+B;AACA,wD;AACA,yC;AACA,gE;AACA,E;;AAEA,qD;AACA,oB;AACA,oB;AACA,0B;AACA,yB;AACA,K;AACA,E;;AAEA,gB;AACA,+E;AACA,gF;AACA,E;;AAEA,2D;;AAEA,4C;AACA,gE;AACA,4B;AACA,qC;AACA,wD;AACA,mD;AACA,E;AACA,wD;;AAEA,gE;AACA,sE;AACA,uC;;;AAGA,gB;AACA,uG;AACA,0E;;;AAGA,gB;AACA,+E;AACA,4E;AACA,E;;AAEA,2D;;AAEA,4C;AACA,oC;AACA,E;AACA,wD;;;;AAIA,c;AACA,2E;AACA,sE;AACA,E;;AAEA,yD;;AAEA,4D;AACA,sD;;;AAGA,c;AACA,2E;AACA,kE;AACA,E;;AAEA,yD;;AAEA,4D;AACA,sD;AACA,sC;;;AAGA,4C;AACA,E;AACA,kC;AACA,uC;AACA,E;AACA,+B;AACA,gC;AACA,G;;AAEA,qE;AACA,iE;AACA,qE;AACA,qE;AACA,wD;AACA,oE;AACA,uD;;AAEA,oC;;AAEA,6E;AACA,oB;AACA,iB;AACA,4C;AACA,6B;AACA,+B;;AAEA,+C;AACA,iC;AACA,0C;AACA,K;AACA,4C;AACA,uC;;AAEA,iE;AACA,4G;AACA,2C;;AAEA,yD;AACA,2C;AACA,E;;AAEA,kD;AACA,oB;AACA,yB;AACA,+C;AACA,a;AACA,oE;AACA,kC;AACA,sD;AACA,sC;AACA,a;AACA,sB;AACA,iC;AACA,8B;AACA,kD;AACA,K;AACA,E;;AAEA,mD;AACA,oB;AACA,yC;AACA,uC;AACA,kC;AACA,+B;;AAEA,6C;;AAEA,kB;AACA,a;AACA,gC;AACA,8G;AACA,c;AACA,a;AACA,kC;AACA,c;AACA,K;AACA,E;;AAEA,8D;AACA,oB;AACA,2E;AACA,E;;AAEA,uD;AACA,mC;AACA,E;;AAEA,sC;AACA,kF;AACA,iC;AACA,wG;AACA,yD;AACA,sE;AACA,E;AACA,yC;;;AAGA,mD;AACA,E;AACA,kC;AACA,uC;AACA,E;AACA,+B;AACA,gC;AACA,G;;AAEA,mB;;AAEA,yC;AACA,4B;AACA,sE;AACA,Y;AACA,sE;AACA,K;AACA,E;;AAEA,6B;AACA,wD;AACA,qD;AACA,E;AACA,mD;AACA,4B;AACA,E;AACA,8C;AACA,iC;AACA,E;AACA,6C;AACA,gC;AACA,E;;AAEA,gC;;AAEA,sC;AACA,e;AACA,sD;AACA,iC;AACA,uC;AACA,sD;AACA,2C;AACA,qD;;AAEA,2C;AACA,sC;AACA,mC;AACA,iD;AACA,sB;AACA,iB;AACA,qC;AACA,+B;AACA,gC;AACA,iC;AACA,gC;AACA,6C;AACA,mE;AACA,+D;AACA,0D;AACA,a;AACA,wE;AACA,qE;AACA,uB;AACA,a;;AAEA,oD;AACA,mD;AACA,+E;AACA,sG;AACA,+B;AACA,uB;AACA,a;AACA,oC;AACA,oF;AACA,kB;AACA,iB;AACA,iC;AACA,kB;AACA,iB;AACA,uB;AACA,oC;AACA,0B;AACA,kB;AACA,S;AACA,M;;AAEA,4B;AACA,+B;AACA,+G;;AAEA,mC;;AAEA,Y;AACA,qB;AACA,E;AACA,gD;;;AAGA,oC;AACA,E;AACA,kC;AACA,uC;AACA,E;AACA,+B;AACA,gC;AACA,G;;AAEA,mD;AACA,oB;AACA,+D;AACA,E;;AAEA,sD;;AAEA,+D;AACA,oB;AACA,oC;;AAEA,W;AACA,qD;AACA,wD;;AAEA,4B;AACA,uE;AACA,mE;AACA,gC;AACA,8D;AACA,Y;;AAEA,gC;AACA,wD;;AAEA,0C;AACA,2B;AACA,oB;AACA,6B;AACA,kD;AACA,wC;AACA,oD;AACA,2C;AACA,gB;AACA,gC;AACA,S;AACA,M;AACA,+B;AACA,mB;AACA,4B;AACA,M;AACA,E;;AAEA,6C;AACA,oB;AACA,yB;AACA,wC;AACA,gD;AACA,+B;AACA,iE;AACA,gD;AACA,4C;AACA,+C;AACA,oB;AACA,oC;AACA,a;AACA,4B;AACA,uB;AACA,U;AACA,uB;AACA,yB;AACA,2B;AACA,4B;AACA,U;AACA,uD;AACA,K;AACA,yB;AACA,sC;AACA,Y;AACA,a;AACA,K;AACA,E;AACA,4D;;;AAGA,mC;AACA,qE;AACA,oE;AACA,+C;AACA,oB;AACA,4B;AACA,sC;AACA,O;AACA,E;AACA,0D;;AAEA,6C;AACA,0C;AACA,mE;AACA,iE;AACA,gE;AACA,K;AACA,uC;AACA,W;AACA,gD;AACA,gE;AACA,W;AACA,W;AACA,oD;AACA,oD;AACA,8H;AACA,+C;AACA,+D;AACA,Y;AACA,0C;AACA,Y;AACA,W;AACA,gB;AACA,gD;AACA,Y;AACA,e;AACA,sC;AACA,M;AACA,E;;;AAGA,mG;AACA,8D;AACA,uC;AACA,wD;AACA,uB;AACA,K;AACA,E;AACA,wD;AACA,iC;;;AAGA,wD;AACA,E;AACA,kC;AACA,uC;AACA,E;AACA,+B;AACA,gC;AACA,G;;AAEA,6E;AACA,oB;AACA,2C;AACA,8C;AACA,E;;AAEA,6D;;AAEA,kD;AACA,mE;AACA,E;;AAEA,4C;AACA,2E;;;AAGA,uB;AACA,uF;AACA,uF;AACA,C;AACA,0D;AACA,qD;;;AAGA,wD;AACA,E;AACA,kC;AACA,uC;AACA,E;AACA,+B;AACA,gC;AACA,G;;AAEA,4E;AACA,oB;AACA,2C;AACA,8C;AACA,E;;AAEA,4D;;AAEA,iD;AACA,+D;AACA,E;;AAEA,2C;AACA,kE;;;AAGA,uB;AACA,uF;AACA,uE;AACA,E;;AAEA,0D;AACA,qD;;;AAGA,qD;AACA,E;AACA,kC;AACA,uC;AACA,E;AACA,+B;AACA,gC;AACA,G;;AAEA,kE;AACA,0D;AACA,+D;AACA,0C;;AAEA,uE;AACA,oB;AACA,wC;AACA,8C;AACA,E;;AAEA,e;AACA,0D;;AAEA,8C;AACA,qC;AACA,E;;AAEA,yC;AACA,qE;;;AAGA,oB;AACA,iF;AACA,iF;AACA,E;AACA,uD;AACA,kD;;;AAGA,6C;AACA,E;AACA,kC;AACA,uC;AACA,E;AACA,+B;AACA,gC;AACA,G;;AAEA,4D;AACA,oB;AACA,iB;AACA,6B;AACA,6B;AACA,iC;AACA,yB;AACA,E;;AAEA,8C;AACA,oB;AACA,6E;AACA,wB;AACA,kC;AACA,yB;AACA,oC;AACA,M;AACA,gC;AACA,gE;AACA,oC;AACA,2C;AACA,4E;AACA,oB;AACA,qC;AACA,a;AACA,S;AACA,M;AACA,E;;AAEA,sC;AACA,oB;AACA,gC;AACA,oB;AACA,0B;AACA,K;AACA,E;AACA,0C;;;AAGA,0D;AACA,E;AACA,kC;AACA,uC;AACA,E;AACA,+B;AACA,gC;AACA,G;;AAEA,yC;AACA,oB;AACA,kC;AACA,gC;AACA,qD;AACA,wE;AACA,M;AACA,4D;AACA,sD;AACA,2C;AACA,4C;AACA,4D;AACA,yD;AACA,gD;AACA,mB;AACA,kB;AACA,iE;AACA,uC;AACA,sE;AACA,qC;AACA,uF;AACA,uB;AACA,M;AACA,E;;AAEA,mD;;AAEA,kD;AACA,oB;AACA,wB;AACA,gC;AACA,K;AACA,E;AACA,uD;;;AAGA,uD;AACA,E;AACA,kC;AACA,uC;AACA,E;AACA,+B;AACA,gC;AACA,G;;AAEA,4B;AACA,sC;AACA,gD;AACA,yC;AACA,iB;AACA,0E;AACA,0B;AACA,gB;AACA,4C;AACA,S;AACA,K;AACA,mC;AACA,E;;;AAGA,sC;AACA,oB;AACA,mC;;AAEA,+C;AACA,oD;AACA,+C;;AAEA,6C;AACA,kD;;AAEA,kB;AACA,iC;AACA,4B;AACA,+B;AACA,U;AACA,kC;AACA,2E;AACA,U;AACA,2B;AACA,6C;AACA,S;AACA,M;AACA,mD;AACA,4B;AACA,6C;AACA,yC;AACA,6E;AACA,M;AACA,8C;AACA,mE;AACA,+B;AACA,E;;AAEA,gD;;AAEA,+C;AACA,oB;AACA,4B;AACA,sC;AACA,K;AACA,E;AACA,oD;;;AAGA,kD;AACA,E;AACA,kC;AACA,uC;AACA,E;AACA,+B;AACA,gC;AACA,G;;AAEA,6C;AACA,oB;AACA,oB;;AAEA,gD;AACA,8C;AACA,mC;AACA,mB;AACA,0C;AACA,sC;AACA,gC;AACA,2B;AACA,sC;AACA,wE;AACA,S;AACA,M;AACA,+C;AACA,sC;AACA,uB;AACA,8D;AACA,uE;AACA,K;AACA,E;;AAEA,2C;;AAEA,0C;AACA,oB;AACA,kB;AACA,wB;AACA,uE;AACA,uB;AACA,K;AACA,E;AACA,+C;;;AAGA,0C;AACA,E;AACA,kC;AACA,uC;AACA,E;AACA,+B;AACA,gC;AACA,G;;AAEA,c;AACA,6B;AACA,iB;AACA,E;;AAEA,uC;AACA,2B;AACA,E;AACA,uC;;AAEA,gC;AACA,e;AACA,8D;;AAEA,iB;AACA,iD;AACA,qD;AACA,C;AACA,8B;;AAEA,wB;;;;;;;;;;;;;;;;;;;ACz5EA,wC;AACA,6C;AACA,4C;AACA,qD;AACA,kB;AACA,2B;AACA,e;AACA,c;AACA,iC;;AAEA,gB;;;AAGA,wE;AACA,sE;AACA,I;AACA,uE;AACA,oE;AACA,qE;AACA,oE;AACA,wE;AACA,mB;AACA,oC;;AAEA,oB;AACA,qB;;AAEA,6B;;AAEA,oE;AACA,4C;AACA,+D;AACA,iE;AACA,uE;;AAEA,e;AACA,2B;AACA,E;;AAEA,+C;;AAEA,uE;AACA,oE;AACA,wB;AACA,yB;AACA,oB;AACA,uC;AACA,6B;AACA,K;AACA,I;;AAEA,yC;AACA,8B;AACA,oB;AACA,sB;AACA,I;;AAEA,2B;AACA,oB;;AAEA,+B;AACA,yC;AACA,kC;AACA,K;;AAEA,uC;AACA,uE;AACA,a;AACA,K;;AAEA,oB;AACA,4C;AACA,wC;AACA,sC;AACA,yB;;AAEA,sE;AACA,kD;AACA,2E;;AAEA,I;;AAEA,mC;AACA,oB;;AAEA,8C;AACA,sB;AACA,iD;AACA,yE;AACA,0B;AACA,yB;AACA,K;;AAEA,gE;AACA,2B;AACA,O;AACA,I;;AAEA,mD;AACA,oB;AACA,+B;AACA,yC;AACA,kC;AACA,K;AACA,8B;AACA,wC;AACA,iC;AACA,K;AACA,I;;AAEA,mC;AACA,oB;AACA,uE;AACA,yE;AACA,I;;AAEA,oC;AACA,oB;AACA,yE;AACA,0D;AACA,iC;AACA,a;AACA,4B;AACA,wC;AACA,qC;AACA,4C;AACA,8B;AACA,I;;AAEA,0C;AACA,6D;AACA,yB;AACA,8B;AACA,2E;;AAEA,qE;AACA,wD;AACA,+E;AACA,M;AACA,mE;AACA,oC;AACA,mC;AACA,yD;AACA,kD;;AAEA,sB;AACA,oE;;AAEA,8B;AACA,I;;AAEA,kC;AACA,oB;AACA,iE;;AAEA,4B;AACA,0D;AACA,oC;;AAEA,+E;AACA,sE;AACA,yB;AACA,2E;AACA,0C;AACA,wB;AACA,M;AACA,6C;AACA,iC;;AAEA,uC;AACA,iE;AACA,8B;AACA,W;AACA,M;AACA,uC;AACA,6B;AACA,M;AACA,uC;AACA,iC;AACA,uF;AACA,M;;AAEA,4C;AACA,iC;AACA,M;;AAEA,6B;AACA,yC;AACA,mD;AACA,2B;AACA,6D;AACA,6B;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACjMA,0E;AACA,wC;AACA,uC;AACA,+C;AACA,E;AACA,oC;AACA,qC;AACA,qD;AACA,E;;AAEA,6C;AACA,6D;AACA,sD;AACA,mF;AACA,yC;AACA,sD;AACA,iD;AACA,2D;AACA,wB;AACA,2B;AACA,G;;AAEA,uD;AACA,iD;AACA,gB;AACA,oB;AACA,4C;AACA,wD;AACA,6E;AACA,4C;AACA,c;AACA,0E;AACA,mE;;AAEA,0E;AACA,4E;AACA,wD;AACA,4C;AACA,8C;AACA,O;;AAEA,2C;AACA,4B;AACA,uE;AACA,0D;AACA,2C;AACA,G;;AAEA,uC;AACA,2D;AACA,sC;AACA,G;;AAEA,8D;AACA,sE;AACA,kE;AACA,sE;AACA,+B;AACA,I;AACA,kE;AACA,sE;AACA,iE;AACA,uE;AACA,2C;;AAEA,yB;AACA,yB;AACA,M;AACA,+B;AACA,E;;AAEA,8B;AACA,6C;AACA,E;;AAEA,iC;AACA,iD;AACA,a;AACA,E;;AAEA,uC;;;AAGA,+C;;AAEA,4B;AACA,iC;AACA,oB;;AAEA,wE;AACA,qD;;AAEA,mC;AACA,qC;AACA,6C;AACA,I;;;AAGA,mC;AACA,oB;AACA,4B;;AAEA,kB;;AAEA,+D;AACA,c;AACA,6D;;AAEA,mD;;AAEA,qC;;AAEA,wB;AACA,0B;AACA,2B;AACA,uB;AACA,mB;AACA,M;;;AAGA,oF;AACA,sC;AACA,+B;AACA,uC;AACA,M;;AAEA,oB;AACA,4B;AACA,gC;;AAEA,I;;AAEA,yB;AACA,iC;AACA,oB;AACA,4B;;AAEA,sB;AACA,mC;AACA,K;;AAEA,iC;AACA,2D;AACA,K;;AAEA,uC;AACA,0C;AACA,2B;AACA,2D;AACA,sB;AACA,a;AACA,K;;AAEA,wC;AACA,qD;AACA,oC;AACA,6B;AACA,K;;AAEA,wB;AACA,qE;AACA,qB;AACA,I;;AAEA,kC;AACA,oB;AACA,4B;;AAEA,qE;AACA,uD;AACA,iC;AACA,a;;AAEA,2E;AACA,mE;AACA,mE;AACA,6B;AACA,6B;AACA,sC;AACA,K;;AAEA,oB;AACA,wB;;AAEA,0B;AACA,0D;AACA,uB;AACA,mB;AACA,M;;AAEA,6C;AACA,iD;;AAEA,yB;AACA,I;;AAEA,gE;AACA,0C;AACA,oB;;AAEA,8B;AACA,wE;AACA,I;;AAEA,kE;AACA,iB;AACA,wB;AACA,0E;AACA,+C;AACA,uB;AACA,I;;AAEA,sC;AACA,oB;;AAEA,oB;AACA,6B;AACA,8E;AACA,uC;AACA,sC;AACA,oC;AACA,Q;AACA,4C;AACA,sE;AACA,Y;AACA,2C;AACA,0C;AACA,K;;AAEA,yC;AACA,yB;AACA,I;;AAEA,0B;AACA,oB;;AAEA,iC;AACA,a;;AAEA,uC;AACA,6C;AACA,yC;AACA,wC;AACA,yB;;AAEA,6B;AACA,I;;;AAGA,kC;AACA,uB;AACA,oB;AACA,6B;AACA,oC;AACA,8B;AACA,G;AACA,G;;AAEA,2C;AACA,6C;AACA,oB;AACA,2B;AACA,G;;AAEA,gD;AACA,8C;;;;;;;;;;;;;;;;;;;ACzQA,qB;AACA,gE;AACA,uE;AACA,iC;AACA,iE;AACA,yD;;AAEA,gC;AACA,kB;;AAEA,qD;AACA,mD;AACA,oC;AACA,sC;;AAEA,uC;AACA,sC;AACA,E;;AAEA,+B;AACA,qB;AACA,oB;AACA,wC;AACA,uC;AACA,I;;AAEA,sB;AACA,oB;AACA,gB;AACA,wC;AACA,I;;AAEA,6C;AACA,oB;AACA,sD;AACA,iD;AACA,4B;AACA,M;AACA,I;;AAEA,4C;AACA,oB;AACA,qD;AACA,gD;AACA,2B;AACA,M;AACA,I;;AAEA,6C;AACA,oB;AACA,wC;AACA,yD;AACA,2C;AACA,K;AACA,I;;AAEA,4C;AACA,oB;AACA,uC;AACA,wD;AACA,0C;AACA,K;AACA,I;;AAEA,sE;AACA,wC;AACA,oB;AACA,yC;AACA,qB;AACA,uB;AACA,uC;AACA,I;;AAEA,qE;AACA,oC;AACA,uC;AACA,oB;AACA,wC;AACA,sB;AACA,I;;AAEA,6B;AACA,oB;AACA,kE;AACA,sE;AACA,wC;AACA,0C;AACA,0C;AACA,K;AACA,I;;AAEA,6B;AACA,oB;;AAEA,oE;AACA,0C;AACA,uC;AACA,yC;AACA,0C;AACA,K;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACrGA,8D;AACA,2D;AACA,iD;;AAEA,6D;;AAEA,2E;AACA,oB;AACA,G;AACA,6E;AACA,8B;AACA,0B;AACA,qB;AACA,G;AACA,uC;AACA,kB;;AAEA,sE;AACA,qE;AACA,iE;AACA,gE;AACA,wE;AACA,sE;AACA,yC;;AAEA,K;AACA,mG;AACA,oB;AACA,wB;AACA,+B;AACA,c;AACA,oB;AACA,K;AACA,2C;;AAEA,mE;AACA,qE;AACA,c;AACA,oD;AACA,8B;;AAEA,oB;;AAEA,K;AACA,gG;AACA,oB;AACA,kB;AACA,+B;AACA,c;AACA,K;AACA,+B;;AAEA,gE;AACA,yB;AACA,wD;;AAEA,+D;;AAEA,K;AACA,uN;AACA,kB;AACA,sB;AACA,+B;AACA,c;AACA,K;AACA,uC;;AAEA,+C;AACA,uC;;AAEA,uE;AACA,2B;AACA,E;;AAEA,sC;AACA,K;AACA,yH;AACA,kB;AACA,+B;AACA,c;AACA,K;AACA,wB;AACA,oB;AACA,+B;AACA,oB;AACA,I;;AAEA,K;AACA,qC;AACA,kB;AACA,+B;AACA,c;AACA,oG;AACA,K;AACA,+B;AACA,oB;AACA,4B;AACA,gF;AACA,yB;AACA,4B;AACA,G;AACA,G;;AAEA,qC;AACA,O;AACA,wC;AACA,e;AACA,yE;AACA,gB;AACA,G;AACA,kC;AACA,gD;AACA,sE;AACA,gB;AACA,G;;AAEA,6E;;AAEA,qE;AACA,gB;AACA,8B;AACA,8B;AACA,sB;AACA,6C;AACA,uC;AACA,O;AACA,uB;AACA,G;;AAEA,2D;AACA,0B;AACA,+D;AACA,K;;AAEA,a;AACA,E;;AAEA,+B;AACA,8B;AACA,sE;AACA,qB;AACA,6B;AACA,qB;AACA,8C;AACA,gC;AACA,0B;AACA,gC;AACA,O;AACA,O;AACA,4B;AACA,6B;AACA,+B;AACA,yB;AACA,G;AACA,0B;AACA,2D;AACA,2B;AACA,+D;AACA,K;AACA,6C;AACA,kD;AACA,G;AACA,8B;AACA,E;;AAEA,oE;AACA,qE;AACA,gE;AACA,wD;AACA,wD;;;;;;;;;;;;;;;;;;;ACzKA,2E;AACA,E;AACA,4E;AACA,6E;AACA,mE;AACA,E;AACA,4E;AACA,+E;AACA,0E;AACA,+E;AACA,4E;AACA,6E;AACA,E;AACA,+D;AACA,6D;AACA,gE;AACA,8C;AACA,E;AACA,mC;AACA,4D;AACA,2D;AACA,iF;AACA,gF;AACA,mC;AACA,kB;;AAEA,uD;;AAEA,sB;AACA,E;;AAEA,kE;AACA,gE;AACA,wE;AACA,yC;AACA,wB;AACA,8B;AACA,E;;AAEA,6E;AACA,6E;AACA,oE;AACA,mC;AACA,wE;AACA,6E;AACA,0D;AACA,2C;AACA,c;AACA,qB;AACA,G;AACA,e;AACA,oC;AACA,mD;AACA,kB;AACA,G;AACA,wC;AACA,sB;AACA,0D;AACA,4B;AACA,O;AACA,G;AACA,sC;AACA,E;;AAEA,sD;AACA,6E;AACA,+D;AACA,oC;AACA,2C;AACA,uC;AACA,E;;AAEA,qD;AACA,8C;AACA,yD;AACA,uE;AACA,oD;AACA,yE;AACA,gD;AACA,iE;AACA,8B;AACA,E;;AAEA,kC;AACA,kF;AACA,uE;AACA,qE;AACA,8B;AACA,oB;;AAEA,gD;AACA,4B;AACA,gD;AACA,qD;AACA,4C;AACA,8C;AACA,S;AACA,O;AACA,yF;AACA,K;AACA,oB;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACtGA,sB;AACA,iC;AACA,oC;AACA,0D;AACA,C;;AAEA,gD;AACA,2C;AACA,W;AACA,gF;AACA,qE;AACA,gC;AACA,2E;AACA,6E;AACA,E;AACA,qE;AACA,oC;AACA,E;AACA,oE;AACA,iE;AACA,qE;AACA,8D;AACA,8D;AACA,mE;AACA,oE;AACA,+B;AACA,0C;AACA,kB;AACA,sB;AACA,gC;AACA,4D;AACA,iC;AACA,M;AACA,6B;AACA,4B;AACA,0C;AACA,iC;AACA,iD;AACA,gB;AACA,wB;AACA,c;;AAEA,wE;AACA,gF;AACA,gB;AACA,0B;;AAEA,6D;AACA,gC;AACA,uB;AACA,U;AACA,uD;AACA,2B;AACA,+B;AACA,6C;AACA,mE;AACA,oE;AACA,kE;AACA,gE;AACA,gB;AACA,iD;AACA,gD;AACA,O;AACA,G;;AAEA,6B;AACA,oE;AACA,4E;AACA,mD;AACA,4C;AACA,yB;AACA,4D;;AAEA,sD;AACA,oD;;AAEA,2E;AACA,gF;AACA,6E;AACA,0B;AACA,4B;;AAEA,gF;AACA,iB;AACA,I;AACA,0E;AACA,+E;AACA,4E;AACA,+E;AACA,mB;AACA,I;AACA,uD;AACA,+C;AACA,4E;AACA,8B;AACA,I;AACA,gF;AACA,+D;AACA,I;AACA,oE;AACA,+E;AACA,+E;AACA,gF;AACA,6E;AACA,+C;AACA,I;AACA,a;AACA,kC;AACA,mC;AACA,6D;AACA,0D;AACA,4D;AACA,8E;AACA,uE;AACA,6E;AACA,+E;AACA,+E;AACA,0D;AACA,qC;;AAEA,2E;AACA,yE;AACA,gF;AACA,+B;AACA,oC;AACA,8E;AACA,4D;AACA,8E;AACA,gC;AACA,8D;AACA,8E;AACA,6D;AACA,6B;;AAEA,uE;AACA,qB;AACA,uE;AACA,qC;AACA,yE;AACA,gF;AACA,4E;AACA,gB;AACA,kC;;AAEA,gF;AACA,oC;AACA,8E;AACA,8E;AACA,6D;AACA,6E;AACA,gF;AACA,uE;AACA,mD;AACA,I;AACA,iE;;AAEA,+D;AACA,6C;AACA,yE;AACA,yE;AACA,W;AACA,uC;AACA,yE;AACA,wE;AACA,0D;AACA,uE;AACA,gB;AACA,4B;;AAEA,iE;AACA,qC;AACA,kD;AACA,4B;;AAEA,sE;AACA,W;AACA,a;AACA,e;AACA,uE;AACA,uD;AACA,gE;AACA,+E;AACA,0D;AACA,2E;AACA,+E;AACA,2B;;AAEA,qB;AACA,sB;AACA,4C;;AAEA,gE;AACA,4E;AACA,uD;AACA,oC;AACA,+B;AACA,yD;AACA,mC;AACA,qB;AACA,c;AACA,sB;AACA,O;AACA,O;AACA,G;;AAEA,sC;AACA,S;AACA,kC;AACA,iB;AACA,sD;AACA,a;AACA,K;;AAEA,mC;AACA,uE;AACA,wE;AACA,qC;AACA,mC;AACA,kE;AACA,a;AACA,K;;AAEA,kC;AACA,8C;AACA,oC;AACA,4B;AACA,K;AACA,mC;AACA,gE;AACA,8C;AACA,+C;AACA,c;AACA,yB;AACA,wF;AACA,yE;AACA,4D;AACA,O;AACA,K;AACA,kC;AACA,iC;AACA,8C;AACA,0B;AACA,uC;AACA,K;AACA,kC;AACA,4B;AACA,uC;AACA,O;AACA,K;AACA,qF;AACA,+B;AACA,iC;AACA,gC;AACA,kC;AACA,iC;AACA,iC;AACA,gC;AACA,Q;AACA,qE;AACA,I;;AAEA,6B;AACA,6D;AACA,qE;AACA,2C;AACA,+B;AACA,4B;AACA,wC;AACA,2E;AACA,0C;AACA,6C;AACA,oB;;AAEA,oE;AACA,qE;AACA,oE;AACA,4D;AACA,qE;AACA,kE;AACA,0B;;AAEA,gF;AACA,wD;AACA,qD;AACA,8D;AACA,4C;AACA,K;;AAEA,uE;AACA,kB;AACA,+C;AACA,4B;AACA,O;;AAEA,oE;AACA,oE;AACA,oE;AACA,oE;AACA,oB;AACA,yB;AACA,kE;AACA,Q;AACA,qC;;AAEA,wE;AACA,6C;AACA,oD;AACA,kB;AACA,mB;AACA,e;AACA,uB;AACA,0B;AACA,S;AACA,O;AACA,I;;AAEA,kC;AACA,0B;AACA,6B;AACA,6B;AACA,K;AACA,I;;AAEA,wB;AACA,iF;AACA,6E;AACA,uF;AACA,U;AACA,0C;AACA,sC;AACA,gD;AACA,G;AACA,E;;AAEA,gF;AACA,sE;AACA,+E;AACA,2E;AACA,+C;AACA,wC;AACA,kB;;AAEA,sC;AACA,mC;AACA,2B;;AAEA,oC;AACA,wC;AACA,kC;AACA,sE;AACA,4B;AACA,4B;AACA,4B;;AAEA,kC;AACA,yD;AACA,E;AACA,mC;AACA,8E;AACA,oE;AACA,4B;AACA,oB;AACA,8E;AACA,gF;AACA,c;AACA,yB;AACA,uE;;AAEA,8E;AACA,Y;AACA,8B;;AAEA,4B;;AAEA,+E;AACA,Y;AACA,mB;AACA,wE;;AAEA,iC;AACA,0C;AACA,I;AACA,6E;AACA,qC;AACA,qC;AACA,oB;AACA,kD;AACA,4E;AACA,0B;AACA,mE;;AAEA,kC;AACA,6D;;AAEA,+E;AACA,8C;AACA,oD;AACA,K;AACA,I;AACA,2E;AACA,oE;AACA,4E;AACA,2D;AACA,yC;AACA,oB;AACA,yB;AACA,kE;AACA,uC;AACA,wC;AACA,gC;AACA,I;AACA,8E;AACA,uE;AACA,4E;AACA,sE;AACA,4B;AACA,oB;AACA,6B;AACA,gC;AACA,I;AACA,2C;AACA,0B;AACA,oB;AACA,gC;AACA,G;AACA,G;;AAEA,gC;AACA,qE;AACA,gF;AACA,gF;AACA,gD;AACA,oB;;AAEA,6B;AACA,mB;;AAEA,0E;AACA,2C;AACA,mB;AACA,kE;AACA,qD;AACA,2C;AACA,4C;AACA,6E;AACA,qC;AACA,gB;AACA,e;;AAEA,+B;;AAEA,qD;AACA,iB;AACA,8C;AACA,qC;AACA,0B;AACA,S;AACA,wB;AACA,iD;AACA,K;;AAEA,gB;AACA,I;;AAEA,K;AACA,qB;AACA,wE;AACA,oC;AACA,kB;AACA,4E;AACA,+B;AACA,uE;AACA,wB;AACA,wE;AACA,sE;AACA,2E;AACA,6C;AACA,K;AACA,2E;AACA,oB;;AAEA,0D;AACA,uB;AACA,wB;AACA,gD;AACA,oC;AACA,yC;AACA,6B;AACA,wE;AACA,iD;AACA,uE;AACA,0B;AACA,iC;AACA,O;AACA,K;;AAEA,uE;AACA,uE;AACA,4B;AACA,M;AACA,wC;AACA,M;AACA,wC;AACA,yD;AACA,yD;AACA,c;AACA,M;AACA,sE;AACA,oE;AACA,sD;AACA,M;AACA,8E;AACA,4E;AACA,uB;AACA,+D;AACA,iD;AACA,yC;AACA,O;;AAEA,W;AACA,mB;AACA,uB;AACA,8C;;AAEA,8B;AACA,+E;AACA,+E;AACA,6E;AACA,yE;AACA,8C;AACA,4B;AACA,qD;AACA,O;;AAEA,wE;AACA,+C;AACA,8B;AACA,kE;AACA,2B;AACA,mD;AACA,O;;AAEA,6B;AACA,iD;AACA,O;AACA,Y;AACA,oE;AACA,uB;AACA,iC;AACA,e;AACA,mB;AACA,oC;AACA,wB;AACA,qB;AACA,0C;AACA,yC;AACA,iD;AACA,yC;AACA,uC;AACA,yB;AACA,4B;AACA,yD;AACA,iD;AACA,U;AACA,0B;AACA,wD;AACA,wB;;AAEA,iC;AACA,+B;AACA,W;AACA,S;AACA,Q;AACA,mE;AACA,K;;AAEA,0C;AACA,kB;AACA,yB;AACA,4C;AACA,iB;;AAEA,uC;AACA,Q;AACA,0B;AACA,8C;AACA,4C;AACA,uB;AACA,6C;AACA,kC;AACA,4B;AACA,Q;AACA,wB;AACA,M;;AAEA,yB;AACA,8E;AACA,8E;AACA,6E;AACA,uE;AACA,wE;AACA,uB;AACA,yC;AACA,2C;AACA,kD;;AAEA,wC;AACA,+C;AACA,+C;AACA,0B;AACA,W;AACA,S;AACA,K;;AAEA,kB;AACA,I;;AAEA,a;AACA,2F;AACA,mE;AACA,qD;AACA,oB;AACA,yB;AACA,sB;AACA,e;AACA,sB;AACA,e;AACA,4B;AACA,qB;AACA,sB;AACA,Q;AACA,6B;AACA,mB;AACA,wB;AACA,Y;AACA,mE;AACA,O;AACA,O;;AAEA,6D;AACA,a;AACA,kB;AACA,I;;AAEA,+B;AACA,oB;AACA,2C;AACA,qC;AACA,4E;AACA,wC;AACA,O;AACA,I;;AAEA,K;AACA,qB;AACA,+D;AACA,oB;AACA,kD;AACA,gE;AACA,uN;AACA,K;AACA,0D;AACA,oE;AACA,4C;AACA,wD;AACA,mE;AACA,gC;AACA,4C;AACA,I;;AAEA,qC;AACA,4E;AACA,4E;AACA,2D;AACA,+E;AACA,4E;AACA,2E;AACA,2E;AACA,2E;AACA,6E;AACA,6E;AACA,2E;AACA,yE;AACA,4E;AACA,8E;AACA,6E;AACA,6E;AACA,2E;AACA,6D;AACA,wC;;AAEA,K;AACA,qB;AACA,4D;AACA,oB;AACA,kD;AACA,+C;AACA,8B;AACA,wM;AACA,8Q;AACA,6G;AACA,K;AACA,mD;AACA,oB;;AAEA,2E;AACA,gC;AACA,qD;AACA,yB;AACA,mB;AACA,K;AACA,4B;;AAEA,mB;AACA,oE;AACA,oC;AACA,yD;AACA,wC;AACA,iB;AACA,sD;AACA,Q;AACA,K;;AAEA,8E;AACA,uC;AACA,6B;;AAEA,mE;AACA,iC;AACA,a;AACA,0B;AACA,6B;AACA,2C;AACA,kB;AACA,Q;AACA,S;;AAEA,iD;AACA,kE;;AAEA,yE;AACA,8E;AACA,yE;AACA,8D;AACA,+E;AACA,6E;AACA,6E;AACA,wE;AACA,4E;AACA,iD;AACA,0B;AACA,2C;AACA,gC;AACA,kD;AACA,O;AACA,wB;AACA,M;;AAEA,sE;AACA,4E;AACA,0E;AACA,8E;AACA,iD;AACA,M;AACA,yE;AACA,yE;AACA,4E;AACA,wE;AACA,a;;AAEA,0C;AACA,e;AACA,wC;AACA,+B;AACA,Q;;AAEA,6C;AACA,2B;AACA,8B;AACA,6B;AACA,iE;AACA,S;;AAEA,+B;AACA,8B;;AAEA,W;AACA,4E;AACA,8C;AACA,wF;AACA,gC;AACA,4E;AACA,0C;AACA,wD;AACA,4E;AACA,+D;AACA,e;AACA,kB;AACA,6D;AACA,W;AACA,W;AACA,O;AACA,iB;AACA,0B;AACA,O;;AAEA,+B;AACA,oD;AACA,K;;AAEA,oE;AACA,+D;AACA,wC;AACA,8B;AACA,qB;AACA,6C;AACA,yB;AACA,O;AACA,oB;AACA,wB;AACA,6B;AACA,K;;AAEA,gE;AACA,iE;AACA,sD;AACA,M;AACA,oE;AACA,iB;AACA,2C;AACA,2E;AACA,4D;AACA,K;;;AAGA,sE;AACA,iD;;AAEA,+D;AACA,oB;AACA,4B;AACA,sE;AACA,sE;AACA,uE;AACA,0B;AACA,mC;AACA,uE;AACA,4C;AACA,U;AACA,c;AACA,iE;AACA,qC;AACA,gC;AACA,qC;AACA,O;AACA,K;AACA,sE;AACA,yE;AACA,+D;AACA,mB;AACA,oB;AACA,mB;AACA,mB;AACA,oB;AACA,M;;AAEA,6C;AACA,8B;AACA,sC;AACA,K;;AAEA,2C;AACA,2B;AACA,yB;AACA,uB;AACA,iD;AACA,2B;AACA,sB;AACA,O;;AAEA,uB;AACA,gE;AACA,yC;AACA,gD;AACA,Y;AACA,8E;AACA,wD;AACA,qD;AACA,qD;AACA,uE;AACA,wE;AACA,K;;AAEA,0D;AACA,mD;AACA,kC;;AAEA,yD;AACA,oC;AACA,iB;AACA,2B;AACA,K;AACA,iE;AACA,I;;AAEA,gF;AACA,uE;AACA,e;AACA,+B;AACA,oB;AACA,uC;AACA,wB;AACA,O;AACA,I;AACA,8E;AACA,gF;AACA,mE;AACA,mD;AACA,oB;AACA,+C;AACA,0E;;AAEA,yB;AACA,mD;AACA,4C;AACA,gD;AACA,qB;AACA,e;AACA,4C;AACA,2D;AACA,sD;AACA,yE;AACA,6E;AACA,uC;AACA,+E;AACA,2B;AACA,oD;AACA,gB;AACA,mE;AACA,mC;AACA,wC;AACA,wC;AACA,oD;AACA,S;AACA,S;AACA,O;AACA,kC;AACA,2D;AACA,K;AACA,I;;AAEA,kE;AACA,wD;AACA,gC;AACA,oB;AACA,6D;AACA,qE;AACA,sD;AACA,Q;AACA,mE;AACA,mE;AACA,oD;AACA,4D;AACA,uC;AACA,O;AACA,O;AACA,I;;AAEA,8D;AACA,yB;AACA,oB;AACA,yC;AACA,I;;AAEA,6D;AACA,mE;AACA,mC;AACA,qC;AACA,oB;AACA,wC;AACA,I;;AAEA,K;AACA,wE;AACA,kB;AACA,qB;AACA,K;AACA,2C;AACA,oB;AACA,8D;AACA,I;;AAEA,K;AACA,mG;;AAEA,8D;AACA,kB;AACA,qB;AACA,K;AACA,8C;AACA,oB;AACA,iE;AACA,I;;AAEA,K;AACA,oD;AACA,kB;AACA,qB;AACA,K;AACA,+C;AACA,oB;AACA,kE;AACA,I;;AAEA,sB;AACA,oB;AACA,uD;AACA,I;;AAEA,K;AACA,0B;AACA,K;AACA,uB;AACA,oB;AACA,yB;AACA,gC;AACA,wB;AACA,I;;AAEA,gC;AACA,oB;AACA,+E;AACA,gC;AACA,a;AACA,0B;AACA,yB;AACA,iC;AACA,I;;AAEA,gF;AACA,2E;AACA,6B;AACA,sC;AACA,oB;AACA,kD;AACA,0D;AACA,I;;AAEA,6E;AACA,uC;AACA,0C;AACA,oB;AACA,+D;AACA,I;;AAEA,uC;AACA,oB;;AAEA,oE;AACA,uC;AACA,mD;AACA,iD;AACA,gC;AACA,+B;AACA,gE;AACA,U;AACA,+B;AACA,oC;AACA,S;AACA,S;AACA,8B;AACA,K;;AAEA,8D;AACA,4B;AACA,+B;;AAEA,4C;AACA,+E;AACA,wC;AACA,K;;AAEA,uC;AACA,+E;AACA,4E;AACA,gF;AACA,+E;AACA,0E;AACA,a;AACA,K;;AAEA,oE;;AAEA,+E;AACA,mC;AACA,uC;;AAEA,4B;AACA,8E;AACA,gB;AACA,wC;AACA,iC;AACA,K;;AAEA,mC;AACA,oC;;AAEA,8E;AACA,gD;AACA,gF;AACA,qE;AACA,gC;AACA,oD;AACA,oB;AACA,0C;AACA,O;;AAEA,2E;AACA,uE;AACA,uC;AACA,M;AACA,wE;AACA,gF;AACA,4D;AACA,yC;AACA,4B;AACA,uD;AACA,kC;AACA,gF;AACA,0E;AACA,4E;AACA,0E;AACA,gF;AACA,yC;AACA,4E;AACA,8E;AACA,8D;AACA,Y;AACA,6E;AACA,uE;AACA,+E;AACA,2E;AACA,+B;AACA,mE;AACA,S;AACA,S;AACA,K;;AAEA,+C;;AAEA,+E;AACA,sC;AACA,wC;AACA,8B;AACA,2C;AACA,iC;AACA,wB;AACA,W;AACA,kC;AACA,O;AACA,sC;AACA,K;AACA,I;;;AAGA,mD;AACA,oB;AACA,6D;AACA,8C;AACA,I;;;AAGA,kC;AACA,oB;;AAEA,2C;AACA,qB;;AAEA,uC;AACA,sD;;AAEA,8B;AACA,8C;;AAEA,+C;AACA,6C;AACA,S;AACA,qD;AACA,yD;AACA,S;;AAEA,uC;AACA,e;;AAEA,oD;AACA,8E;AACA,oC;AACA,4E;AACA,0D;AACA,S;AACA,iD;AACA,Y;AACA,gD;AACA,K;;AAEA,mD;AACA,oD;AACA,oD;AACA,gF;AACA,yC;AACA,S;AACA,gC;;AAEA,4D;AACA,4C;AACA,oB;AACA,2D;AACA,wC;AACA,a;AACA,gB;AACA,gE;AACA,8B;AACA,oE;AACA,qE;AACA,gD;AACA,+D;AACA,0D;AACA,8E;AACA,qD;AACA,S;AACA,S;;AAEA,gC;AACA,4D;AACA,K;;AAEA,oC;AACA,I;;AAEA,2E;AACA,yE;AACA,+B;AACA,yC;AACA,oB;AACA,+C;AACA,oC;AACA,oC;AACA,U;AACA,O;AACA,I;;AAEA,oD;AACA,oB;AACA,sC;AACA,+B;AACA,K;AACA,kC;AACA,I;;AAEA,4C;AACA,oB;AACA,kD;AACA,kB;AACA,oE;AACA,mD;AACA,I;;AAEA,2C;AACA,oB;AACA,8C;AACA,2D;AACA,oB;AACA,0C;AACA,2C;AACA,sE;AACA,4C;AACA,kC;AACA,Y;AACA,qD;AACA,K;AACA,I;;AAEA,6C;AACA,oB;AACA,uC;AACA,wD;AACA,oB;AACA,2C;AACA,6E;AACA,oE;AACA,Y;AACA,qD;AACA,K;AACA,I;;AAEA,6C;AACA,oB;AACA,uC;AACA,wD;AACA,oB;AACA,0C;AACA,2C;AACA,4E;AACA,qC;AACA,Y;AACA,iD;AACA,uB;AACA,mC;AACA,kB;AACA,S;AACA,K;AACA,I;;AAEA,6C;AACA,oB;AACA,sC;AACA,6C;AACA,yE;AACA,2E;AACA,uB;AACA,2E;AACA,gD;AACA,4D;AACA,iE;AACA,kD;AACA,kD;AACA,6E;AACA,8E;AACA,+E;AACA,wC;;AAEA,yE;AACA,+E;AACA,uE;AACA,yD;AACA,2B;AACA,yD;AACA,uC;AACA,a;AACA,sC;AACA,yD;AACA,gB;AACA,a;;AAEA,2E;AACA,6E;AACA,gE;AACA,uE;AACA,S;AACA,S;AACA,oD;;AAEA,gF;AACA,iD;AACA,2D;AACA,2B;AACA,sE;AACA,2C;AACA,8D;AACA,O;AACA,I;;AAEA,2C;AACA,oB;AACA,2E;AACA,wE;AACA,4D;AACA,uC;AACA,wD;AACA,mD;AACA,sC;AACA,uB;AACA,iB;AACA,0D;AACA,4B;AACA,iB;AACA,6D;AACA,+B;AACA,sC;AACA,S;AACA,O;AACA,I;;AAEA,qE;AACA,gF;AACA,2C;AACA,iD;AACA,oB;AACA,wC;AACA,yC;AACA,M;AACA,oC;AACA,wC;AACA,gC;AACA,0C;AACA,6E;AACA,6B;AACA,2B;AACA,O;AACA,M;AACA,6D;AACA,mD;AACA,2D;AACA,gE;AACA,yD;AACA,kD;AACA,a;AACA,qD;AACA,oC;AACA,0D;AACA,S;AACA,S;AACA,O;AACA,wC;AACA,gF;AACA,qC;AACA,yB;AACA,K;AACA,I;;AAEA,mC;AACA,oB;;AAEA,2E;AACA,0B;AACA,6B;;AAEA,yD;AACA,kC;;AAEA,2D;AACA,4C;AACA,a;;AAEA,6C;AACA,kE;AACA,gE;;AAEA,yC;;AAEA,gD;AACA,wD;AACA,uE;AACA,K;;AAEA,6C;AACA,qC;AACA,6C;AACA,K;;AAEA,uB;AACA,4C;AACA,K;AACA,I;;AAEA,+B;AACA,2E;AACA,4E;AACA,sE;AACA,yE;AACA,e;AACA,I;;AAEA,oC;AACA,mE;;AAEA,oB;;AAEA,mC;AACA,uD;AACA,mD;AACA,yE;AACA,a;AACA,K;AACA,sE;AACA,U;AACA,yD;AACA,gC;AACA,gC;AACA,c;AACA,K;;AAEA,a;AACA,gF;AACA,a;AACA,K;;AAEA,+E;AACA,gF;AACA,kC;AACA,oC;;AAEA,8B;AACA,uC;AACA,0C;AACA,4B;AACA,Y;AACA,kE;AACA,c;AACA,6C;AACA,K;AACA,I;;AAEA,+E;AACA,8E;AACA,mE;AACA,2C;AACA,oB;AACA,yC;AACA,a;;AAEA,2E;AACA,0E;AACA,kD;AACA,qD;AACA,6D;AACA,0C;AACA,uE;AACA,oD;;AAEA,6D;AACA,oD;AACA,uC;AACA,K;;AAEA,oC;AACA,yB;AACA,I;;AAEA,6D;AACA,8B;AACA,uC;AACA,oB;AACA,iD;AACA,a;AACA,mE;AACA,sB;AACA,O;AACA,I;;AAEA,mC;AACA,8D;AACA,6B;AACA,mD;AACA,I;;AAEA,oE;AACA,oB;AACA,mE;AACA,uC;;AAEA,uB;;AAEA,8C;AACA,a;;AAEA,yE;AACA,4E;AACA,+D;AACA,mD;AACA,iE;AACA,qC;AACA,a;AACA,K;;AAEA,gF;AACA,6E;AACA,yC;AACA,sD;AACA,8C;AACA,kE;AACA,8D;;AAEA,0E;AACA,uD;AACA,0B;AACA,S;;AAEA,yC;AACA,K;;AAEA,kD;AACA,yD;AACA,gD;AACA,O;AACA,I;;AAEA,qE;AACA,+B;AACA,oB;AACA,2C;AACA,I;;AAEA,2E;AACA,kE;AACA,8B;AACA,oB;AACA,uD;AACA,2B;AACA,gC;AACA,K;AACA,G;AACA,G;;AAEA,qC;;AAEA,yC;AACA,Y;AACA,8B;AACA,qC;AACA,W;AACA,qD;;AAEA,G;AACA,oI;AACA,kB;AACA,6D;AACA,G;AACA,uC;AACA,yC;AACA,+C;AACA,a;AACA,E;;AAEA,kE;AACA,iC;AACA,E;AACA,oB;AACA,0C;AACA,gD;AACA,sD;AACA,uB;AACA,O;AACA,K;AACA,E;;;;;;;;;;;;;;;;;;;AClmDA,+E;AACA,oC;AACA,0C;AACA,E;;AAEA,sB;AACA,qE;AACA,qB;AACA,I;AACA,oE;AACA,kE;AACA,4C;AACA,+D;AACA,gE;AACA,kE;AACA,kE;AACA,sE;AACA,4D;AACA,sE;AACA,gD;AACA,0D;AACA,mB;AACA,yD;AACA,6D;AACA,oE;AACA,G;;AAEA,0B;;AAEA,+D;AACA,+B;AACA,yB;AACA,iF;AACA,sE;AACA,iB;AACA,gE;AACA,iE;AACA,S;AACA,8C;AACA,wC;AACA,S;AACA,K;AACA,I;;AAEA,qB;AACA,yB;AACA,oE;AACA,O;;AAEA,8D;AACA,kC;AACA,yE;AACA,wB;AACA,0B;AACA,6E;AACA,Y;AACA,Q;AACA,oE;AACA,oC;AACA,2B;AACA,C;;AAEA,sC;AACA,mE;AACA,kC;AACA,wB;AACA,8C;;AAEA,2D;AACA,wB;AACA,6B\",\"file\":\"/packages/ddp.js\",\"sourcesContent\":[\"/**\\n * @namespace DDP\\n * @summary The namespace for DDP-related methods.\\n */\\nDDP = {};\\nLivedataTest = {};\\n\",\"// XXX METEOR changes in <METEOR>\\n\\n/* SockJS client, version 0.3.4, http://sockjs.org, MIT License\\n\\nCopyright (c) 2011-2012 VMware, Inc.\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy\\nof this software and associated documentation files (the \\\"Software\\\"), to deal\\nin the Software without restriction, including without limitation the rights\\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\ncopies of the Software, and to permit persons to whom the Software is\\nfurnished to do so, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in\\nall copies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\nTHE SOFTWARE.\\n*/\\n\\n// <METEOR> Commented out JSO implementation (use json package instead).\\n// JSON2 by Douglas Crockford (minified).\\n// var JSON;JSON||(JSON={}),function(){function str(a,b){var c,d,e,f,g=gap,h,i=b[a];i&&typeof i==\\\"object\\\"&&typeof i.toJSON==\\\"function\\\"&&(i=i.toJSON(a)),typeof rep==\\\"function\\\"&&(i=rep.call(b,a,i));switch(typeof i){case\\\"string\\\":return quote(i);case\\\"number\\\":return isFinite(i)?String(i):\\\"null\\\";case\\\"boolean\\\":case\\\"null\\\":return String(i);case\\\"object\\\":if(!i)return\\\"null\\\";gap+=indent,h=[];if(Object.prototype.toString.apply(i)===\\\"[object Array]\\\"){f=i.length;for(c=0;c<f;c+=1)h[c]=str(c,i)||\\\"null\\\";e=h.length===0?\\\"[]\\\":gap?\\\"[\\\\n\\\"+gap+h.join(\\\",\\\\n\\\"+gap)+\\\"\\\\n\\\"+g+\\\"]\\\":\\\"[\\\"+h.join(\\\",\\\")+\\\"]\\\",gap=g;return e}if(rep&&typeof rep==\\\"object\\\"){f=rep.length;for(c=0;c<f;c+=1)typeof rep[c]==\\\"string\\\"&&(d=rep[c],e=str(d,i),e&&h.push(quote(d)+(gap?\\\": \\\":\\\":\\\")+e))}else for(d in i)Object.prototype.hasOwnProperty.call(i,d)&&(e=str(d,i),e&&h.push(quote(d)+(gap?\\\": \\\":\\\":\\\")+e));e=h.length===0?\\\"{}\\\":gap?\\\"{\\\\n\\\"+gap+h.join(\\\",\\\\n\\\"+gap)+\\\"\\\\n\\\"+g+\\\"}\\\":\\\"{\\\"+h.join(\\\",\\\")+\\\"}\\\",gap=g;return e}}function quote(a){escapable.lastIndex=0;return escapable.test(a)?'\\\"'+a.replace(escapable,function(a){var b=meta[a];return typeof b==\\\"string\\\"?b:\\\"\\\\\\\\u\\\"+(\\\"0000\\\"+a.charCodeAt(0).toString(16)).slice(-4)})+'\\\"':'\\\"'+a+'\\\"'}function f(a){return a<10?\\\"0\\\"+a:a}\\\"use strict\\\",typeof Date.prototype.toJSON!=\\\"function\\\"&&(Date.prototype.toJSON=function(a){return isFinite(this.valueOf())?this.getUTCFullYear()+\\\"-\\\"+f(this.getUTCMonth()+1)+\\\"-\\\"+f(this.getUTCDate())+\\\"T\\\"+f(this.getUTCHours())+\\\":\\\"+f(this.getUTCMinutes())+\\\":\\\"+f(this.getUTCSeconds())+\\\"Z\\\":null},String.prototype.toJSON=Number.prototype.toJSON=Boolean.prototype.toJSON=function(a){return this.valueOf()});var cx=/[\\\\u0000\\\\u00ad\\\\u0600-\\\\u0604\\\\u070f\\\\u17b4\\\\u17b5\\\\u200c-\\\\u200f\\\\u2028-\\\\u202f\\\\u2060-\\\\u206f\\\\ufeff\\\\ufff0-\\\\uffff]/g,escapable=/[\\\\\\\\\\\\\\\"\\\\x00-\\\\x1f\\\\x7f-\\\\x9f\\\\u00ad\\\\u0600-\\\\u0604\\\\u070f\\\\u17b4\\\\u17b5\\\\u200c-\\\\u200f\\\\u2028-\\\\u202f\\\\u2060-\\\\u206f\\\\ufeff\\\\ufff0-\\\\uffff]/g,gap,indent,meta={\\\"\\\\b\\\":\\\"\\\\\\\\b\\\",\\\"\\\\t\\\":\\\"\\\\\\\\t\\\",\\\"\\\\n\\\":\\\"\\\\\\\\n\\\",\\\"\\\\f\\\":\\\"\\\\\\\\f\\\",\\\"\\\\r\\\":\\\"\\\\\\\\r\\\",'\\\"':'\\\\\\\\\\\"',\\\"\\\\\\\\\\\":\\\"\\\\\\\\\\\\\\\\\\\"},rep;typeof JSON.stringify!=\\\"function\\\"&&(JSON.stringify=function(a,b,c){var d;gap=\\\"\\\",indent=\\\"\\\";if(typeof c==\\\"number\\\")for(d=0;d<c;d+=1)indent+=\\\" \\\";else typeof c==\\\"string\\\"&&(indent=c);rep=b;if(!b||typeof b==\\\"function\\\"||typeof b==\\\"object\\\"&&typeof b.length==\\\"number\\\")return str(\\\"\\\",{\\\"\\\":a});throw new Error(\\\"JSON.stringify\\\")}),typeof JSON.parse!=\\\"function\\\"&&(JSON.parse=function(text,reviver){function walk(a,b){var c,d,e=a[b];if(e&&typeof e==\\\"object\\\")for(c in e)Object.prototype.hasOwnProperty.call(e,c)&&(d=walk(e,c),d!==undefined?e[c]=d:delete e[c]);return reviver.call(a,b,e)}var j;text=String(text),cx.lastIndex=0,cx.test(text)&&(text=text.replace(cx,function(a){return\\\"\\\\\\\\u\\\"+(\\\"0000\\\"+a.charCodeAt(0).toString(16)).slice(-4)}));if(/^[\\\\],:{}\\\\s]*$/.test(text.replace(/\\\\\\\\(?:[\\\"\\\\\\\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g,\\\"@\\\").replace(/\\\"[^\\\"\\\\\\\\\\\\n\\\\r]*\\\"|true|false|null|-?\\\\d+(?:\\\\.\\\\d*)?(?:[eE][+\\\\-]?\\\\d+)?/g,\\\"]\\\").replace(/(?:^|:|,)(?:\\\\s*\\\\[)+/g,\\\"\\\"))){j=eval(\\\"(\\\"+text+\\\")\\\");return typeof reviver==\\\"function\\\"?walk({\\\"\\\":j},\\\"\\\"):j}throw new SyntaxError(\\\"JSON.parse\\\")})}()\\n// </METEOR>\\n\\n//     [*] Including lib/index.js\\n// Public object\\nSockJS = (function(){\\n              var _document = document;\\n              var _window = window;\\n              var utils = {};\\n\\n\\n//         [*] Including lib/reventtarget.js\\n/*\\n * ***** BEGIN LICENSE BLOCK *****\\n * Copyright (c) 2011-2012 VMware, Inc.\\n *\\n * For the license see COPYING.\\n * ***** END LICENSE BLOCK *****\\n */\\n\\n/* Simplified implementation of DOM2 EventTarget.\\n *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget\\n */\\nvar REventTarget = function() {};\\nREventTarget.prototype.addEventListener = function (eventType, listener) {\\n    if(!this._listeners) {\\n         this._listeners = {};\\n    }\\n    if(!(eventType in this._listeners)) {\\n        this._listeners[eventType] = [];\\n    }\\n    var arr = this._listeners[eventType];\\n    if(utils.arrIndexOf(arr, listener) === -1) {\\n        arr.push(listener);\\n    }\\n    return;\\n};\\n\\nREventTarget.prototype.removeEventListener = function (eventType, listener) {\\n    if(!(this._listeners && (eventType in this._listeners))) {\\n        return;\\n    }\\n    var arr = this._listeners[eventType];\\n    var idx = utils.arrIndexOf(arr, listener);\\n    if (idx !== -1) {\\n        if(arr.length > 1) {\\n            this._listeners[eventType] = arr.slice(0, idx).concat( arr.slice(idx+1) );\\n        } else {\\n            delete this._listeners[eventType];\\n        }\\n        return;\\n    }\\n    return;\\n};\\n\\nREventTarget.prototype.dispatchEvent = function (event) {\\n    var t = event.type;\\n    var args = Array.prototype.slice.call(arguments, 0);\\n    if (this['on'+t]) {\\n        this['on'+t].apply(this, args);\\n    }\\n    if (this._listeners && t in this._listeners) {\\n        for(var i=0; i < this._listeners[t].length; i++) {\\n            this._listeners[t][i].apply(this, args);\\n        }\\n    }\\n};\\n//         [*] End of lib/reventtarget.js\\n\\n\\n//         [*] Including lib/simpleevent.js\\n/*\\n * ***** BEGIN LICENSE BLOCK *****\\n * Copyright (c) 2011-2012 VMware, Inc.\\n *\\n * For the license see COPYING.\\n * ***** END LICENSE BLOCK *****\\n */\\n\\nvar SimpleEvent = function(type, obj) {\\n    this.type = type;\\n    if (typeof obj !== 'undefined') {\\n        for(var k in obj) {\\n            if (!obj.hasOwnProperty(k)) continue;\\n            this[k] = obj[k];\\n        }\\n    }\\n};\\n\\nSimpleEvent.prototype.toString = function() {\\n    var r = [];\\n    for(var k in this) {\\n        if (!this.hasOwnProperty(k)) continue;\\n        var v = this[k];\\n        if (typeof v === 'function') v = '[function]';\\n        r.push(k + '=' + v);\\n    }\\n    return 'SimpleEvent(' + r.join(', ') + ')';\\n};\\n//         [*] End of lib/simpleevent.js\\n\\n\\n//         [*] Including lib/eventemitter.js\\n/*\\n * ***** BEGIN LICENSE BLOCK *****\\n * Copyright (c) 2011-2012 VMware, Inc.\\n *\\n * For the license see COPYING.\\n * ***** END LICENSE BLOCK *****\\n */\\n\\nvar EventEmitter = function(events) {\\n    var that = this;\\n    that._events = events || [];\\n    that._listeners = {};\\n};\\nEventEmitter.prototype.emit = function(type) {\\n    var that = this;\\n    that._verifyType(type);\\n    if (that._nuked) return;\\n\\n    var args = Array.prototype.slice.call(arguments, 1);\\n    if (that['on'+type]) {\\n        that['on'+type].apply(that, args);\\n    }\\n    if (type in that._listeners) {\\n        for(var i = 0; i < that._listeners[type].length; i++) {\\n            that._listeners[type][i].apply(that, args);\\n        }\\n    }\\n};\\n\\nEventEmitter.prototype.on = function(type, callback) {\\n    var that = this;\\n    that._verifyType(type);\\n    if (that._nuked) return;\\n\\n    if (!(type in that._listeners)) {\\n        that._listeners[type] = [];\\n    }\\n    that._listeners[type].push(callback);\\n};\\n\\nEventEmitter.prototype._verifyType = function(type) {\\n    var that = this;\\n    if (utils.arrIndexOf(that._events, type) === -1) {\\n        utils.log('Event ' + JSON.stringify(type) +\\n                  ' not listed ' + JSON.stringify(that._events) +\\n                  ' in ' + that);\\n    }\\n};\\n\\nEventEmitter.prototype.nuke = function() {\\n    var that = this;\\n    that._nuked = true;\\n    for(var i=0; i<that._events.length; i++) {\\n        delete that[that._events[i]];\\n    }\\n    that._listeners = {};\\n};\\n//         [*] End of lib/eventemitter.js\\n\\n\\n//         [*] Including lib/utils.js\\n/*\\n * ***** BEGIN LICENSE BLOCK *****\\n * Copyright (c) 2011-2012 VMware, Inc.\\n *\\n * For the license see COPYING.\\n * ***** END LICENSE BLOCK *****\\n */\\n\\nvar random_string_chars = 'abcdefghijklmnopqrstuvwxyz0123456789_';\\nutils.random_string = function(length, max) {\\n    max = max || random_string_chars.length;\\n    var i, ret = [];\\n    for(i=0; i < length; i++) {\\n        ret.push( random_string_chars.substr(Math.floor(Math.random() * max),1) );\\n    }\\n    return ret.join('');\\n};\\nutils.random_number = function(max) {\\n    return Math.floor(Math.random() * max);\\n};\\nutils.random_number_string = function(max) {\\n    var t = (''+(max - 1)).length;\\n    var p = Array(t+1).join('0');\\n    return (p + utils.random_number(max)).slice(-t);\\n};\\n\\n// Assuming that url looks like: http://asdasd:111/asd\\nutils.getOrigin = function(url) {\\n    url += '/';\\n    var parts = url.split('/').slice(0, 3);\\n    return parts.join('/');\\n};\\n\\nutils.isSameOriginUrl = function(url_a, url_b) {\\n    // location.origin would do, but it's not always available.\\n    if (!url_b) url_b = _window.location.href;\\n\\n    return (url_a.split('/').slice(0,3).join('/')\\n                ===\\n            url_b.split('/').slice(0,3).join('/'));\\n};\\n\\n// <METEOR>\\n// https://github.com/sockjs/sockjs-client/issues/79\\nutils.isSameOriginScheme = function(url_a, url_b) {\\n    if (!url_b) url_b = _window.location.href;\\n\\n    return (url_a.split(':')[0]\\n                ===\\n            url_b.split(':')[0]);\\n};\\n// </METEOR>\\n\\n\\nutils.getParentDomain = function(url) {\\n    // ipv4 ip address\\n    if (/^[0-9.]*$/.test(url)) return url;\\n    // ipv6 ip address\\n    if (/^\\\\[/.test(url)) return url;\\n    // no dots\\n    if (!(/[.]/.test(url))) return url;\\n\\n    var parts = url.split('.').slice(1);\\n    return parts.join('.');\\n};\\n\\nutils.objectExtend = function(dst, src) {\\n    for(var k in src) {\\n        if (src.hasOwnProperty(k)) {\\n            dst[k] = src[k];\\n        }\\n    }\\n    return dst;\\n};\\n\\nvar WPrefix = '_jp';\\n\\nutils.polluteGlobalNamespace = function() {\\n    if (!(WPrefix in _window)) {\\n        _window[WPrefix] = {};\\n    }\\n};\\n\\nutils.closeFrame = function (code, reason) {\\n    return 'c'+JSON.stringify([code, reason]);\\n};\\n\\nutils.userSetCode = function (code) {\\n    return code === 1000 || (code >= 3000 && code <= 4999);\\n};\\n\\n// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/\\n// and RFC 2988.\\nutils.countRTO = function (rtt) {\\n    var rto;\\n    if (rtt > 100) {\\n        rto = 3 * rtt; // rto > 300msec\\n    } else {\\n        rto = rtt + 200; // 200msec < rto <= 300msec\\n    }\\n    return rto;\\n}\\n\\nutils.log = function() {\\n    if (_window.console && console.log && console.log.apply) {\\n        console.log.apply(console, arguments);\\n    }\\n};\\n\\nutils.bind = function(fun, that) {\\n    if (fun.bind) {\\n        return fun.bind(that);\\n    } else {\\n        return function() {\\n            return fun.apply(that, arguments);\\n        };\\n    }\\n};\\n\\nutils.flatUrl = function(url) {\\n    return url.indexOf('?') === -1 && url.indexOf('#') === -1;\\n};\\n\\n// `relativeTo` is an optional absolute URL. If provided, `url` will be\\n// interpreted relative to `relativeTo`. Defaults to `document.location`.\\n// <METEOR>\\nutils.amendUrl = function(url, relativeTo) {\\n    var baseUrl;\\n    if (relativeTo === undefined) {\\n      baseUrl = _document.location;\\n    } else {\\n      var protocolMatch = /^([a-z0-9.+-]+:)/i.exec(relativeTo);\\n      if (protocolMatch) {\\n        var protocol = protocolMatch[0].toLowerCase();\\n        var rest = relativeTo.substring(protocol.length);\\n        var hostMatch = /[a-z0-9\\\\.-]+(:[0-9]+)?/.exec(rest);\\n        if (hostMatch)\\n          var host = hostMatch[0];\\n      }\\n      if (! protocol || ! host)\\n        throw new Error(\\\"relativeTo must be an absolute url\\\");\\n      baseUrl = {\\n        protocol: protocol,\\n        host: host\\n      };\\n    }\\n    if (!url) {\\n        throw new Error('Wrong url for SockJS');\\n    }\\n    if (!utils.flatUrl(url)) {\\n        throw new Error('Only basic urls are supported in SockJS');\\n    }\\n\\n    //  '//abc' --> 'http://abc'\\n    if (url.indexOf('//') === 0) {\\n        url = baseUrl.protocol + url;\\n    }\\n    // '/abc' --> 'http://localhost:1234/abc'\\n    if (url.indexOf('/') === 0) {\\n        url = baseUrl.protocol + '//' + baseUrl.host + url;\\n    }\\n    // </METEOR>\\n    // strip trailing slashes\\n    url = url.replace(/[/]+$/,'');\\n\\n    // We have a full url here, with proto and host. For some browsers\\n    // http://localhost:80/ is not in the same origin as http://localhost/\\n\\t// Remove explicit :80 or :443 in such cases. See #74\\n    var parts = url.split(\\\"/\\\");\\n    if ((parts[0] === \\\"http:\\\" && /:80$/.test(parts[2])) ||\\n\\t    (parts[0] === \\\"https:\\\" && /:443$/.test(parts[2]))) {\\n\\t\\tparts[2] = parts[2].replace(/:(80|443)$/, \\\"\\\");\\n\\t}\\n    url = parts.join(\\\"/\\\");\\n    return url;\\n};\\n\\n// IE doesn't support [].indexOf.\\nutils.arrIndexOf = function(arr, obj){\\n    for(var i=0; i < arr.length; i++){\\n        if(arr[i] === obj){\\n            return i;\\n        }\\n    }\\n    return -1;\\n};\\n\\nutils.arrSkip = function(arr, obj) {\\n    var idx = utils.arrIndexOf(arr, obj);\\n    if (idx === -1) {\\n        return arr.slice();\\n    } else {\\n        var dst = arr.slice(0, idx);\\n        return dst.concat(arr.slice(idx+1));\\n    }\\n};\\n\\n// Via: https://gist.github.com/1133122/2121c601c5549155483f50be3da5305e83b8c5df\\nutils.isArray = Array.isArray || function(value) {\\n    return {}.toString.call(value).indexOf('Array') >= 0\\n};\\n\\nutils.delay = function(t, fun) {\\n    if(typeof t === 'function') {\\n        fun = t;\\n        t = 0;\\n    }\\n    return setTimeout(fun, t);\\n};\\n\\n\\n// Chars worth escaping, as defined by Douglas Crockford:\\n//   https://github.com/douglascrockford/JSON-js/blob/47a9882cddeb1e8529e07af9736218075372b8ac/json2.js#L196\\nvar json_escapable = /[\\\\\\\\\\\\\\\"\\\\x00-\\\\x1f\\\\x7f-\\\\x9f\\\\u00ad\\\\u0600-\\\\u0604\\\\u070f\\\\u17b4\\\\u17b5\\\\u200c-\\\\u200f\\\\u2028-\\\\u202f\\\\u2060-\\\\u206f\\\\ufeff\\\\ufff0-\\\\uffff]/g,\\n    json_lookup = {\\n\\\"\\\\u0000\\\":\\\"\\\\\\\\u0000\\\",\\\"\\\\u0001\\\":\\\"\\\\\\\\u0001\\\",\\\"\\\\u0002\\\":\\\"\\\\\\\\u0002\\\",\\\"\\\\u0003\\\":\\\"\\\\\\\\u0003\\\",\\n\\\"\\\\u0004\\\":\\\"\\\\\\\\u0004\\\",\\\"\\\\u0005\\\":\\\"\\\\\\\\u0005\\\",\\\"\\\\u0006\\\":\\\"\\\\\\\\u0006\\\",\\\"\\\\u0007\\\":\\\"\\\\\\\\u0007\\\",\\n\\\"\\\\b\\\":\\\"\\\\\\\\b\\\",\\\"\\\\t\\\":\\\"\\\\\\\\t\\\",\\\"\\\\n\\\":\\\"\\\\\\\\n\\\",\\\"\\\\u000b\\\":\\\"\\\\\\\\u000b\\\",\\\"\\\\f\\\":\\\"\\\\\\\\f\\\",\\\"\\\\r\\\":\\\"\\\\\\\\r\\\",\\n\\\"\\\\u000e\\\":\\\"\\\\\\\\u000e\\\",\\\"\\\\u000f\\\":\\\"\\\\\\\\u000f\\\",\\\"\\\\u0010\\\":\\\"\\\\\\\\u0010\\\",\\\"\\\\u0011\\\":\\\"\\\\\\\\u0011\\\",\\n\\\"\\\\u0012\\\":\\\"\\\\\\\\u0012\\\",\\\"\\\\u0013\\\":\\\"\\\\\\\\u0013\\\",\\\"\\\\u0014\\\":\\\"\\\\\\\\u0014\\\",\\\"\\\\u0015\\\":\\\"\\\\\\\\u0015\\\",\\n\\\"\\\\u0016\\\":\\\"\\\\\\\\u0016\\\",\\\"\\\\u0017\\\":\\\"\\\\\\\\u0017\\\",\\\"\\\\u0018\\\":\\\"\\\\\\\\u0018\\\",\\\"\\\\u0019\\\":\\\"\\\\\\\\u0019\\\",\\n\\\"\\\\u001a\\\":\\\"\\\\\\\\u001a\\\",\\\"\\\\u001b\\\":\\\"\\\\\\\\u001b\\\",\\\"\\\\u001c\\\":\\\"\\\\\\\\u001c\\\",\\\"\\\\u001d\\\":\\\"\\\\\\\\u001d\\\",\\n\\\"\\\\u001e\\\":\\\"\\\\\\\\u001e\\\",\\\"\\\\u001f\\\":\\\"\\\\\\\\u001f\\\",\\\"\\\\\\\"\\\":\\\"\\\\\\\\\\\\\\\"\\\",\\\"\\\\\\\\\\\":\\\"\\\\\\\\\\\\\\\\\\\",\\n\\\"\\\\u007f\\\":\\\"\\\\\\\\u007f\\\",\\\"\\\\u0080\\\":\\\"\\\\\\\\u0080\\\",\\\"\\\\u0081\\\":\\\"\\\\\\\\u0081\\\",\\\"\\\\u0082\\\":\\\"\\\\\\\\u0082\\\",\\n\\\"\\\\u0083\\\":\\\"\\\\\\\\u0083\\\",\\\"\\\\u0084\\\":\\\"\\\\\\\\u0084\\\",\\\"\\\\u0085\\\":\\\"\\\\\\\\u0085\\\",\\\"\\\\u0086\\\":\\\"\\\\\\\\u0086\\\",\\n\\\"\\\\u0087\\\":\\\"\\\\\\\\u0087\\\",\\\"\\\\u0088\\\":\\\"\\\\\\\\u0088\\\",\\\"\\\\u0089\\\":\\\"\\\\\\\\u0089\\\",\\\"\\\\u008a\\\":\\\"\\\\\\\\u008a\\\",\\n\\\"\\\\u008b\\\":\\\"\\\\\\\\u008b\\\",\\\"\\\\u008c\\\":\\\"\\\\\\\\u008c\\\",\\\"\\\\u008d\\\":\\\"\\\\\\\\u008d\\\",\\\"\\\\u008e\\\":\\\"\\\\\\\\u008e\\\",\\n\\\"\\\\u008f\\\":\\\"\\\\\\\\u008f\\\",\\\"\\\\u0090\\\":\\\"\\\\\\\\u0090\\\",\\\"\\\\u0091\\\":\\\"\\\\\\\\u0091\\\",\\\"\\\\u0092\\\":\\\"\\\\\\\\u0092\\\",\\n\\\"\\\\u0093\\\":\\\"\\\\\\\\u0093\\\",\\\"\\\\u0094\\\":\\\"\\\\\\\\u0094\\\",\\\"\\\\u0095\\\":\\\"\\\\\\\\u0095\\\",\\\"\\\\u0096\\\":\\\"\\\\\\\\u0096\\\",\\n\\\"\\\\u0097\\\":\\\"\\\\\\\\u0097\\\",\\\"\\\\u0098\\\":\\\"\\\\\\\\u0098\\\",\\\"\\\\u0099\\\":\\\"\\\\\\\\u0099\\\",\\\"\\\\u009a\\\":\\\"\\\\\\\\u009a\\\",\\n\\\"\\\\u009b\\\":\\\"\\\\\\\\u009b\\\",\\\"\\\\u009c\\\":\\\"\\\\\\\\u009c\\\",\\\"\\\\u009d\\\":\\\"\\\\\\\\u009d\\\",\\\"\\\\u009e\\\":\\\"\\\\\\\\u009e\\\",\\n\\\"\\\\u009f\\\":\\\"\\\\\\\\u009f\\\",\\\"\\\\u00ad\\\":\\\"\\\\\\\\u00ad\\\",\\\"\\\\u0600\\\":\\\"\\\\\\\\u0600\\\",\\\"\\\\u0601\\\":\\\"\\\\\\\\u0601\\\",\\n\\\"\\\\u0602\\\":\\\"\\\\\\\\u0602\\\",\\\"\\\\u0603\\\":\\\"\\\\\\\\u0603\\\",\\\"\\\\u0604\\\":\\\"\\\\\\\\u0604\\\",\\\"\\\\u070f\\\":\\\"\\\\\\\\u070f\\\",\\n\\\"\\\\u17b4\\\":\\\"\\\\\\\\u17b4\\\",\\\"\\\\u17b5\\\":\\\"\\\\\\\\u17b5\\\",\\\"\\\\u200c\\\":\\\"\\\\\\\\u200c\\\",\\\"\\\\u200d\\\":\\\"\\\\\\\\u200d\\\",\\n\\\"\\\\u200e\\\":\\\"\\\\\\\\u200e\\\",\\\"\\\\u200f\\\":\\\"\\\\\\\\u200f\\\",\\\"\\\\u2028\\\":\\\"\\\\\\\\u2028\\\",\\\"\\\\u2029\\\":\\\"\\\\\\\\u2029\\\",\\n\\\"\\\\u202a\\\":\\\"\\\\\\\\u202a\\\",\\\"\\\\u202b\\\":\\\"\\\\\\\\u202b\\\",\\\"\\\\u202c\\\":\\\"\\\\\\\\u202c\\\",\\\"\\\\u202d\\\":\\\"\\\\\\\\u202d\\\",\\n\\\"\\\\u202e\\\":\\\"\\\\\\\\u202e\\\",\\\"\\\\u202f\\\":\\\"\\\\\\\\u202f\\\",\\\"\\\\u2060\\\":\\\"\\\\\\\\u2060\\\",\\\"\\\\u2061\\\":\\\"\\\\\\\\u2061\\\",\\n\\\"\\\\u2062\\\":\\\"\\\\\\\\u2062\\\",\\\"\\\\u2063\\\":\\\"\\\\\\\\u2063\\\",\\\"\\\\u2064\\\":\\\"\\\\\\\\u2064\\\",\\\"\\\\u2065\\\":\\\"\\\\\\\\u2065\\\",\\n\\\"\\\\u2066\\\":\\\"\\\\\\\\u2066\\\",\\\"\\\\u2067\\\":\\\"\\\\\\\\u2067\\\",\\\"\\\\u2068\\\":\\\"\\\\\\\\u2068\\\",\\\"\\\\u2069\\\":\\\"\\\\\\\\u2069\\\",\\n\\\"\\\\u206a\\\":\\\"\\\\\\\\u206a\\\",\\\"\\\\u206b\\\":\\\"\\\\\\\\u206b\\\",\\\"\\\\u206c\\\":\\\"\\\\\\\\u206c\\\",\\\"\\\\u206d\\\":\\\"\\\\\\\\u206d\\\",\\n\\\"\\\\u206e\\\":\\\"\\\\\\\\u206e\\\",\\\"\\\\u206f\\\":\\\"\\\\\\\\u206f\\\",\\\"\\\\ufeff\\\":\\\"\\\\\\\\ufeff\\\",\\\"\\\\ufff0\\\":\\\"\\\\\\\\ufff0\\\",\\n\\\"\\\\ufff1\\\":\\\"\\\\\\\\ufff1\\\",\\\"\\\\ufff2\\\":\\\"\\\\\\\\ufff2\\\",\\\"\\\\ufff3\\\":\\\"\\\\\\\\ufff3\\\",\\\"\\\\ufff4\\\":\\\"\\\\\\\\ufff4\\\",\\n\\\"\\\\ufff5\\\":\\\"\\\\\\\\ufff5\\\",\\\"\\\\ufff6\\\":\\\"\\\\\\\\ufff6\\\",\\\"\\\\ufff7\\\":\\\"\\\\\\\\ufff7\\\",\\\"\\\\ufff8\\\":\\\"\\\\\\\\ufff8\\\",\\n\\\"\\\\ufff9\\\":\\\"\\\\\\\\ufff9\\\",\\\"\\\\ufffa\\\":\\\"\\\\\\\\ufffa\\\",\\\"\\\\ufffb\\\":\\\"\\\\\\\\ufffb\\\",\\\"\\\\ufffc\\\":\\\"\\\\\\\\ufffc\\\",\\n\\\"\\\\ufffd\\\":\\\"\\\\\\\\ufffd\\\",\\\"\\\\ufffe\\\":\\\"\\\\\\\\ufffe\\\",\\\"\\\\uffff\\\":\\\"\\\\\\\\uffff\\\"};\\n\\n// Some extra characters that Chrome gets wrong, and substitutes with\\n// something else on the wire.\\nvar extra_escapable = /[\\\\x00-\\\\x1f\\\\ud800-\\\\udfff\\\\ufffe\\\\uffff\\\\u0300-\\\\u0333\\\\u033d-\\\\u0346\\\\u034a-\\\\u034c\\\\u0350-\\\\u0352\\\\u0357-\\\\u0358\\\\u035c-\\\\u0362\\\\u0374\\\\u037e\\\\u0387\\\\u0591-\\\\u05af\\\\u05c4\\\\u0610-\\\\u0617\\\\u0653-\\\\u0654\\\\u0657-\\\\u065b\\\\u065d-\\\\u065e\\\\u06df-\\\\u06e2\\\\u06eb-\\\\u06ec\\\\u0730\\\\u0732-\\\\u0733\\\\u0735-\\\\u0736\\\\u073a\\\\u073d\\\\u073f-\\\\u0741\\\\u0743\\\\u0745\\\\u0747\\\\u07eb-\\\\u07f1\\\\u0951\\\\u0958-\\\\u095f\\\\u09dc-\\\\u09dd\\\\u09df\\\\u0a33\\\\u0a36\\\\u0a59-\\\\u0a5b\\\\u0a5e\\\\u0b5c-\\\\u0b5d\\\\u0e38-\\\\u0e39\\\\u0f43\\\\u0f4d\\\\u0f52\\\\u0f57\\\\u0f5c\\\\u0f69\\\\u0f72-\\\\u0f76\\\\u0f78\\\\u0f80-\\\\u0f83\\\\u0f93\\\\u0f9d\\\\u0fa2\\\\u0fa7\\\\u0fac\\\\u0fb9\\\\u1939-\\\\u193a\\\\u1a17\\\\u1b6b\\\\u1cda-\\\\u1cdb\\\\u1dc0-\\\\u1dcf\\\\u1dfc\\\\u1dfe\\\\u1f71\\\\u1f73\\\\u1f75\\\\u1f77\\\\u1f79\\\\u1f7b\\\\u1f7d\\\\u1fbb\\\\u1fbe\\\\u1fc9\\\\u1fcb\\\\u1fd3\\\\u1fdb\\\\u1fe3\\\\u1feb\\\\u1fee-\\\\u1fef\\\\u1ff9\\\\u1ffb\\\\u1ffd\\\\u2000-\\\\u2001\\\\u20d0-\\\\u20d1\\\\u20d4-\\\\u20d7\\\\u20e7-\\\\u20e9\\\\u2126\\\\u212a-\\\\u212b\\\\u2329-\\\\u232a\\\\u2adc\\\\u302b-\\\\u302c\\\\uaab2-\\\\uaab3\\\\uf900-\\\\ufa0d\\\\ufa10\\\\ufa12\\\\ufa15-\\\\ufa1e\\\\ufa20\\\\ufa22\\\\ufa25-\\\\ufa26\\\\ufa2a-\\\\ufa2d\\\\ufa30-\\\\ufa6d\\\\ufa70-\\\\ufad9\\\\ufb1d\\\\ufb1f\\\\ufb2a-\\\\ufb36\\\\ufb38-\\\\ufb3c\\\\ufb3e\\\\ufb40-\\\\ufb41\\\\ufb43-\\\\ufb44\\\\ufb46-\\\\ufb4e\\\\ufff0-\\\\uffff]/g,\\n    extra_lookup;\\n\\n// JSON Quote string. Use native implementation when possible.\\nvar JSONQuote = (JSON && JSON.stringify) || function(string) {\\n    json_escapable.lastIndex = 0;\\n    if (json_escapable.test(string)) {\\n        string = string.replace(json_escapable, function(a) {\\n            return json_lookup[a];\\n        });\\n    }\\n    return '\\\"' + string + '\\\"';\\n};\\n\\n// This may be quite slow, so let's delay until user actually uses bad\\n// characters.\\nvar unroll_lookup = function(escapable) {\\n    var i;\\n    var unrolled = {}\\n    var c = []\\n    for(i=0; i<65536; i++) {\\n        c.push( String.fromCharCode(i) );\\n    }\\n    escapable.lastIndex = 0;\\n    c.join('').replace(escapable, function (a) {\\n        unrolled[ a ] = '\\\\\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\\n        return '';\\n    });\\n    escapable.lastIndex = 0;\\n    return unrolled;\\n};\\n\\n// Quote string, also taking care of unicode characters that browsers\\n// often break. Especially, take care of unicode surrogates:\\n//    http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates\\nutils.quote = function(string) {\\n    var quoted = JSONQuote(string);\\n\\n    // In most cases this should be very fast and good enough.\\n    extra_escapable.lastIndex = 0;\\n    if(!extra_escapable.test(quoted)) {\\n        return quoted;\\n    }\\n\\n    if(!extra_lookup) extra_lookup = unroll_lookup(extra_escapable);\\n\\n    return quoted.replace(extra_escapable, function(a) {\\n        return extra_lookup[a];\\n    });\\n}\\n\\nvar _all_protocols = ['websocket',\\n                      'xdr-streaming',\\n                      'xhr-streaming',\\n                      'iframe-eventsource',\\n                      'iframe-htmlfile',\\n                      'xdr-polling',\\n                      'xhr-polling',\\n                      'iframe-xhr-polling',\\n                      'jsonp-polling'];\\n\\nutils.probeProtocols = function() {\\n    var probed = {};\\n    for(var i=0; i<_all_protocols.length; i++) {\\n        var protocol = _all_protocols[i];\\n        // User can have a typo in protocol name.\\n        probed[protocol] = SockJS[protocol] &&\\n                           SockJS[protocol].enabled();\\n    }\\n    return probed;\\n};\\n\\nutils.detectProtocols = function(probed, protocols_whitelist, info) {\\n    var pe = {},\\n        protocols = [];\\n    if (!protocols_whitelist) protocols_whitelist = _all_protocols;\\n    for(var i=0; i<protocols_whitelist.length; i++) {\\n        var protocol = protocols_whitelist[i];\\n        pe[protocol] = probed[protocol];\\n    }\\n    var maybe_push = function(protos) {\\n        var proto = protos.shift();\\n        if (pe[proto]) {\\n            protocols.push(proto);\\n        } else {\\n            if (protos.length > 0) {\\n                maybe_push(protos);\\n            }\\n        }\\n    }\\n\\n    // 1. Websocket\\n    if (info.websocket !== false) {\\n        maybe_push(['websocket']);\\n    }\\n\\n    // 2. Streaming\\n    if (pe['xhr-streaming'] && !info.null_origin) {\\n        protocols.push('xhr-streaming');\\n    } else {\\n        if (pe['xdr-streaming'] && !info.cookie_needed && !info.null_origin) {\\n            protocols.push('xdr-streaming');\\n        } else {\\n            maybe_push(['iframe-eventsource',\\n                        'iframe-htmlfile']);\\n        }\\n    }\\n\\n    // 3. Polling\\n    if (pe['xhr-polling'] && !info.null_origin) {\\n        protocols.push('xhr-polling');\\n    } else {\\n        if (pe['xdr-polling'] && !info.cookie_needed && !info.null_origin) {\\n            protocols.push('xdr-polling');\\n        } else {\\n            maybe_push(['iframe-xhr-polling',\\n                        'jsonp-polling']);\\n        }\\n    }\\n    return protocols;\\n}\\n//         [*] End of lib/utils.js\\n\\n\\n//         [*] Including lib/dom.js\\n/*\\n * ***** BEGIN LICENSE BLOCK *****\\n * Copyright (c) 2011-2012 VMware, Inc.\\n *\\n * For the license see COPYING.\\n * ***** END LICENSE BLOCK *****\\n */\\n\\n// May be used by htmlfile jsonp and transports.\\nvar MPrefix = '_sockjs_global';\\nutils.createHook = function() {\\n    var window_id = 'a' + utils.random_string(8);\\n    if (!(MPrefix in _window)) {\\n        var map = {};\\n        _window[MPrefix] = function(window_id) {\\n            if (!(window_id in map)) {\\n                map[window_id] = {\\n                    id: window_id,\\n                    del: function() {delete map[window_id];}\\n                };\\n            }\\n            return map[window_id];\\n        }\\n    }\\n    return _window[MPrefix](window_id);\\n};\\n\\n\\n\\nutils.attachMessage = function(listener) {\\n    utils.attachEvent('message', listener);\\n};\\nutils.attachEvent = function(event, listener) {\\n    if (typeof _window.addEventListener !== 'undefined') {\\n        _window.addEventListener(event, listener, false);\\n    } else {\\n        // IE quirks.\\n        // According to: http://stevesouders.com/misc/test-postmessage.php\\n        // the message gets delivered only to 'document', not 'window'.\\n        _document.attachEvent(\\\"on\\\" + event, listener);\\n        // I get 'window' for ie8.\\n        _window.attachEvent(\\\"on\\\" + event, listener);\\n    }\\n};\\n\\nutils.detachMessage = function(listener) {\\n    utils.detachEvent('message', listener);\\n};\\nutils.detachEvent = function(event, listener) {\\n    if (typeof _window.addEventListener !== 'undefined') {\\n        _window.removeEventListener(event, listener, false);\\n    } else {\\n        _document.detachEvent(\\\"on\\\" + event, listener);\\n        _window.detachEvent(\\\"on\\\" + event, listener);\\n    }\\n};\\n\\n\\nvar on_unload = {};\\n// Things registered after beforeunload are to be called immediately.\\nvar after_unload = false;\\n\\nvar trigger_unload_callbacks = function() {\\n    for(var ref in on_unload) {\\n        on_unload[ref]();\\n        delete on_unload[ref];\\n    };\\n};\\n\\nvar unload_triggered = function() {\\n    if(after_unload) return;\\n    after_unload = true;\\n    trigger_unload_callbacks();\\n};\\n\\n// 'unload' alone is not reliable in opera within an iframe, but we\\n// can't use `beforeunload` as IE fires it on javascript: links.\\nutils.attachEvent('unload', unload_triggered);\\n\\nutils.unload_add = function(listener) {\\n    var ref = utils.random_string(8);\\n    on_unload[ref] = listener;\\n    if (after_unload) {\\n        utils.delay(trigger_unload_callbacks);\\n    }\\n    return ref;\\n};\\nutils.unload_del = function(ref) {\\n    if (ref in on_unload)\\n        delete on_unload[ref];\\n};\\n\\n\\nutils.createIframe = function (iframe_url, error_callback) {\\n    var iframe = _document.createElement('iframe');\\n    var tref, unload_ref;\\n    var unattach = function() {\\n        clearTimeout(tref);\\n        // Explorer had problems with that.\\n        try {iframe.onload = null;} catch (x) {}\\n        iframe.onerror = null;\\n    };\\n    var cleanup = function() {\\n        if (iframe) {\\n            unattach();\\n            // This timeout makes chrome fire onbeforeunload event\\n            // within iframe. Without the timeout it goes straight to\\n            // onunload.\\n            setTimeout(function() {\\n                if(iframe) {\\n                    iframe.parentNode.removeChild(iframe);\\n                }\\n                iframe = null;\\n            }, 0);\\n            utils.unload_del(unload_ref);\\n        }\\n    };\\n    var onerror = function(r) {\\n        if (iframe) {\\n            cleanup();\\n            error_callback(r);\\n        }\\n    };\\n    var post = function(msg, origin) {\\n        try {\\n            // When the iframe is not loaded, IE raises an exception\\n            // on 'contentWindow'.\\n            if (iframe && iframe.contentWindow) {\\n                iframe.contentWindow.postMessage(msg, origin);\\n            }\\n        } catch (x) {};\\n    };\\n\\n    iframe.src = iframe_url;\\n    iframe.style.display = 'none';\\n    iframe.style.position = 'absolute';\\n    iframe.onerror = function(){onerror('onerror');};\\n    iframe.onload = function() {\\n        // `onload` is triggered before scripts on the iframe are\\n        // executed. Give it few seconds to actually load stuff.\\n        clearTimeout(tref);\\n        tref = setTimeout(function(){onerror('onload timeout');}, 2000);\\n    };\\n    _document.body.appendChild(iframe);\\n    tref = setTimeout(function(){onerror('timeout');}, 15000);\\n    unload_ref = utils.unload_add(cleanup);\\n    return {\\n        post: post,\\n        cleanup: cleanup,\\n        loaded: unattach\\n    };\\n};\\n\\nutils.createHtmlfile = function (iframe_url, error_callback) {\\n    var doc = new ActiveXObject('htmlfile');\\n    var tref, unload_ref;\\n    var iframe;\\n    var unattach = function() {\\n        clearTimeout(tref);\\n    };\\n    var cleanup = function() {\\n        if (doc) {\\n            unattach();\\n            utils.unload_del(unload_ref);\\n            iframe.parentNode.removeChild(iframe);\\n            iframe = doc = null;\\n            CollectGarbage();\\n        }\\n    };\\n    var onerror = function(r)  {\\n        if (doc) {\\n            cleanup();\\n            error_callback(r);\\n        }\\n    };\\n    var post = function(msg, origin) {\\n        try {\\n            // When the iframe is not loaded, IE raises an exception\\n            // on 'contentWindow'.\\n            if (iframe && iframe.contentWindow) {\\n                iframe.contentWindow.postMessage(msg, origin);\\n            }\\n        } catch (x) {};\\n    };\\n\\n    doc.open();\\n    doc.write('<html><s' + 'cript>' +\\n              'document.domain=\\\"' + document.domain + '\\\";' +\\n              '</s' + 'cript></html>');\\n    doc.close();\\n    doc.parentWindow[WPrefix] = _window[WPrefix];\\n    var c = doc.createElement('div');\\n    doc.body.appendChild(c);\\n    iframe = doc.createElement('iframe');\\n    c.appendChild(iframe);\\n    iframe.src = iframe_url;\\n    tref = setTimeout(function(){onerror('timeout');}, 15000);\\n    unload_ref = utils.unload_add(cleanup);\\n    return {\\n        post: post,\\n        cleanup: cleanup,\\n        loaded: unattach\\n    };\\n};\\n//         [*] End of lib/dom.js\\n\\n\\n//         [*] Including lib/dom2.js\\n/*\\n * ***** BEGIN LICENSE BLOCK *****\\n * Copyright (c) 2011-2012 VMware, Inc.\\n *\\n * For the license see COPYING.\\n * ***** END LICENSE BLOCK *****\\n */\\n\\nvar AbstractXHRObject = function(){};\\nAbstractXHRObject.prototype = new EventEmitter(['chunk', 'finish']);\\n\\nAbstractXHRObject.prototype._start = function(method, url, payload, opts) {\\n    var that = this;\\n\\n    try {\\n        that.xhr = new XMLHttpRequest();\\n    } catch(x) {};\\n\\n    if (!that.xhr) {\\n        try {\\n            that.xhr = new _window.ActiveXObject('Microsoft.XMLHTTP');\\n        } catch(x) {};\\n    }\\n    if (_window.ActiveXObject || _window.XDomainRequest) {\\n        // IE8 caches even POSTs\\n        url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);\\n    }\\n\\n    // Explorer tends to keep connection open, even after the\\n    // tab gets closed: http://bugs.jquery.com/ticket/5280\\n    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});\\n    try {\\n        that.xhr.open(method, url, true);\\n    } catch(e) {\\n        // IE raises an exception on wrong port.\\n        that.emit('finish', 0, '');\\n        that._cleanup();\\n        return;\\n    };\\n\\n    if (!opts || !opts.no_credentials) {\\n        // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :\\n        // \\\"This never affects same-site requests.\\\"\\n        that.xhr.withCredentials = 'true';\\n    }\\n    if (opts && opts.headers) {\\n        for(var key in opts.headers) {\\n            that.xhr.setRequestHeader(key, opts.headers[key]);\\n        }\\n    }\\n\\n    that.xhr.onreadystatechange = function() {\\n        if (that.xhr) {\\n            var x = that.xhr;\\n            switch (x.readyState) {\\n            case 3:\\n                // IE doesn't like peeking into responseText or status\\n                // on Microsoft.XMLHTTP and readystate=3\\n                try {\\n                    var status = x.status;\\n                    var text = x.responseText;\\n                } catch (x) {};\\n                // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450\\n                if (status === 1223) status = 204;\\n\\n                // IE does return readystate == 3 for 404 answers.\\n                if (text && text.length > 0) {\\n                    that.emit('chunk', status, text);\\n                }\\n                break;\\n            case 4:\\n                var status = x.status;\\n                // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450\\n                if (status === 1223) status = 204;\\n\\n                that.emit('finish', status, x.responseText);\\n                that._cleanup(false);\\n                break;\\n            }\\n        }\\n    };\\n    that.xhr.send(payload);\\n};\\n\\nAbstractXHRObject.prototype._cleanup = function(abort) {\\n    var that = this;\\n    if (!that.xhr) return;\\n    utils.unload_del(that.unload_ref);\\n\\n    // IE needs this field to be a function\\n    that.xhr.onreadystatechange = function(){};\\n\\n    if (abort) {\\n        try {\\n            that.xhr.abort();\\n        } catch(x) {};\\n    }\\n    that.unload_ref = that.xhr = null;\\n};\\n\\nAbstractXHRObject.prototype.close = function() {\\n    var that = this;\\n    that.nuke();\\n    that._cleanup(true);\\n};\\n\\nvar XHRCorsObject = utils.XHRCorsObject = function() {\\n    var that = this, args = arguments;\\n    utils.delay(function(){that._start.apply(that, args);});\\n};\\nXHRCorsObject.prototype = new AbstractXHRObject();\\n\\nvar XHRLocalObject = utils.XHRLocalObject = function(method, url, payload) {\\n    var that = this;\\n    utils.delay(function(){\\n        that._start(method, url, payload, {\\n            no_credentials: true\\n        });\\n    });\\n};\\nXHRLocalObject.prototype = new AbstractXHRObject();\\n\\n\\n\\n// References:\\n//   http://ajaxian.com/archives/100-line-ajax-wrapper\\n//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx\\nvar XDRObject = utils.XDRObject = function(method, url, payload) {\\n    var that = this;\\n    utils.delay(function(){that._start(method, url, payload);});\\n};\\nXDRObject.prototype = new EventEmitter(['chunk', 'finish']);\\nXDRObject.prototype._start = function(method, url, payload) {\\n    var that = this;\\n    var xdr = new XDomainRequest();\\n    // IE caches even POSTs\\n    url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);\\n\\n    var onerror = xdr.ontimeout = xdr.onerror = function() {\\n        that.emit('finish', 0, '');\\n        that._cleanup(false);\\n    };\\n    xdr.onprogress = function() {\\n        that.emit('chunk', 200, xdr.responseText);\\n    };\\n    xdr.onload = function() {\\n        that.emit('finish', 200, xdr.responseText);\\n        that._cleanup(false);\\n    };\\n    that.xdr = xdr;\\n    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});\\n    try {\\n        // Fails with AccessDenied if port number is bogus\\n        that.xdr.open(method, url);\\n        that.xdr.send(payload);\\n    } catch(x) {\\n        onerror();\\n    }\\n};\\n\\nXDRObject.prototype._cleanup = function(abort) {\\n    var that = this;\\n    if (!that.xdr) return;\\n    utils.unload_del(that.unload_ref);\\n\\n    that.xdr.ontimeout = that.xdr.onerror = that.xdr.onprogress =\\n        that.xdr.onload = null;\\n    if (abort) {\\n        try {\\n            that.xdr.abort();\\n        } catch(x) {};\\n    }\\n    that.unload_ref = that.xdr = null;\\n};\\n\\nXDRObject.prototype.close = function() {\\n    var that = this;\\n    that.nuke();\\n    that._cleanup(true);\\n};\\n\\n// 1. Is natively via XHR\\n// 2. Is natively via XDR\\n// 3. Nope, but postMessage is there so it should work via the Iframe.\\n// 4. Nope, sorry.\\nutils.isXHRCorsCapable = function() {\\n    if (_window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest()) {\\n        return 1;\\n    }\\n    // XDomainRequest doesn't work if page is served from file://\\n    if (_window.XDomainRequest && _document.domain) {\\n        return 2;\\n    }\\n    if (IframeTransport.enabled()) {\\n        return 3;\\n    }\\n    return 4;\\n};\\n//         [*] End of lib/dom2.js\\n\\n\\n//         [*] Including lib/sockjs.js\\n/*\\n * ***** BEGIN LICENSE BLOCK *****\\n * Copyright (c) 2011-2012 VMware, Inc.\\n *\\n * For the license see COPYING.\\n * ***** END LICENSE BLOCK *****\\n */\\n\\nvar SockJS = function(url, dep_protocols_whitelist, options) {\\n    if (!(this instanceof SockJS)) {\\n        // makes `new` optional\\n        return new SockJS(url, dep_protocols_whitelist, options);\\n    }\\n\\n    var that = this, protocols_whitelist;\\n    that._options = {devel: false, debug: false, protocols_whitelist: [],\\n                     info: undefined, rtt: undefined};\\n    if (options) {\\n        utils.objectExtend(that._options, options);\\n    }\\n    that._base_url = utils.amendUrl(url);\\n    that._server = that._options.server || utils.random_number_string(1000);\\n    if (that._options.protocols_whitelist &&\\n        that._options.protocols_whitelist.length) {\\n        protocols_whitelist = that._options.protocols_whitelist;\\n    } else {\\n        // Deprecated API\\n        if (typeof dep_protocols_whitelist === 'string' &&\\n            dep_protocols_whitelist.length > 0) {\\n            protocols_whitelist = [dep_protocols_whitelist];\\n        } else if (utils.isArray(dep_protocols_whitelist)) {\\n            protocols_whitelist = dep_protocols_whitelist\\n        } else {\\n            protocols_whitelist = null;\\n        }\\n        if (protocols_whitelist) {\\n            that._debug('Deprecated API: Use \\\"protocols_whitelist\\\" option ' +\\n                        'instead of supplying protocol list as a second ' +\\n                        'parameter to SockJS constructor.');\\n        }\\n    }\\n    that._protocols = [];\\n    that.protocol = null;\\n    that.readyState = SockJS.CONNECTING;\\n    that._ir = createInfoReceiver(that._base_url);\\n    that._ir.onfinish = function(info, rtt) {\\n        that._ir = null;\\n        if (info) {\\n            if (that._options.info) {\\n                // Override if user supplies the option\\n                info = utils.objectExtend(info, that._options.info);\\n            }\\n            if (that._options.rtt) {\\n                rtt = that._options.rtt;\\n            }\\n            that._applyInfo(info, rtt, protocols_whitelist);\\n            that._didClose();\\n        } else {\\n            that._didClose(1002, 'Can\\\\'t connect to server', true);\\n        }\\n    };\\n};\\n// Inheritance\\nSockJS.prototype = new REventTarget();\\n\\nSockJS.version = \\\"0.3.4\\\";\\n\\nSockJS.CONNECTING = 0;\\nSockJS.OPEN = 1;\\nSockJS.CLOSING = 2;\\nSockJS.CLOSED = 3;\\n\\nSockJS.prototype._debug = function() {\\n    if (this._options.debug)\\n        utils.log.apply(utils, arguments);\\n};\\n\\nSockJS.prototype._dispatchOpen = function() {\\n    var that = this;\\n    if (that.readyState === SockJS.CONNECTING) {\\n        if (that._transport_tref) {\\n            clearTimeout(that._transport_tref);\\n            that._transport_tref = null;\\n        }\\n        that.readyState = SockJS.OPEN;\\n        that.dispatchEvent(new SimpleEvent(\\\"open\\\"));\\n    } else {\\n        // The server might have been restarted, and lost track of our\\n        // connection.\\n        that._didClose(1006, \\\"Server lost session\\\");\\n    }\\n};\\n\\nSockJS.prototype._dispatchMessage = function(data) {\\n    var that = this;\\n    if (that.readyState !== SockJS.OPEN)\\n            return;\\n    that.dispatchEvent(new SimpleEvent(\\\"message\\\", {data: data}));\\n};\\n\\nSockJS.prototype._dispatchHeartbeat = function(data) {\\n    var that = this;\\n    if (that.readyState !== SockJS.OPEN)\\n        return;\\n    that.dispatchEvent(new SimpleEvent('heartbeat', {}));\\n};\\n\\nSockJS.prototype._didClose = function(code, reason, force) {\\n    var that = this;\\n    if (that.readyState !== SockJS.CONNECTING &&\\n        that.readyState !== SockJS.OPEN &&\\n        that.readyState !== SockJS.CLOSING)\\n            throw new Error('INVALID_STATE_ERR');\\n    if (that._ir) {\\n        that._ir.nuke();\\n        that._ir = null;\\n    }\\n\\n    if (that._transport) {\\n        that._transport.doCleanup();\\n        that._transport = null;\\n    }\\n\\n    var close_event = new SimpleEvent(\\\"close\\\", {\\n        code: code,\\n        reason: reason,\\n        wasClean: utils.userSetCode(code)});\\n\\n    if (!utils.userSetCode(code) &&\\n        that.readyState === SockJS.CONNECTING && !force) {\\n        if (that._try_next_protocol(close_event)) {\\n            return;\\n        }\\n        close_event = new SimpleEvent(\\\"close\\\", {code: 2000,\\n                                                reason: \\\"All transports failed\\\",\\n                                                wasClean: false,\\n                                                last_event: close_event});\\n    }\\n    that.readyState = SockJS.CLOSED;\\n\\n    utils.delay(function() {\\n                   that.dispatchEvent(close_event);\\n                });\\n};\\n\\nSockJS.prototype._didMessage = function(data) {\\n    var that = this;\\n    var type = data.slice(0, 1);\\n    switch(type) {\\n    case 'o':\\n        that._dispatchOpen();\\n        break;\\n    case 'a':\\n        var payload = JSON.parse(data.slice(1) || '[]');\\n        for(var i=0; i < payload.length; i++){\\n            that._dispatchMessage(payload[i]);\\n        }\\n        break;\\n    case 'm':\\n        var payload = JSON.parse(data.slice(1) || 'null');\\n        that._dispatchMessage(payload);\\n        break;\\n    case 'c':\\n        var payload = JSON.parse(data.slice(1) || '[]');\\n        that._didClose(payload[0], payload[1]);\\n        break;\\n    case 'h':\\n        that._dispatchHeartbeat();\\n        break;\\n    }\\n};\\n\\nSockJS.prototype._try_next_protocol = function(close_event) {\\n    var that = this;\\n    if (that.protocol) {\\n        that._debug('Closed transport:', that.protocol, ''+close_event);\\n        that.protocol = null;\\n    }\\n    if (that._transport_tref) {\\n        clearTimeout(that._transport_tref);\\n        that._transport_tref = null;\\n    }\\n\\n    while(1) {\\n        var protocol = that.protocol = that._protocols.shift();\\n        if (!protocol) {\\n            return false;\\n        }\\n        // Some protocols require access to `body`, what if were in\\n        // the `head`?\\n        if (SockJS[protocol] &&\\n            SockJS[protocol].need_body === true &&\\n            (!_document.body ||\\n             (typeof _document.readyState !== 'undefined'\\n              && _document.readyState !== 'complete'))) {\\n            that._protocols.unshift(protocol);\\n            that.protocol = 'waiting-for-load';\\n            utils.attachEvent('load', function(){\\n                that._try_next_protocol();\\n            });\\n            return true;\\n        }\\n\\n        if (!SockJS[protocol] ||\\n              !SockJS[protocol].enabled(that._options)) {\\n            that._debug('Skipping transport:', protocol);\\n        } else {\\n            var roundTrips = SockJS[protocol].roundTrips || 1;\\n            var to = ((that._options.rto || 0) * roundTrips) || 5000;\\n            that._transport_tref = utils.delay(to, function() {\\n                if (that.readyState === SockJS.CONNECTING) {\\n                    // I can't understand how it is possible to run\\n                    // this timer, when the state is CLOSED, but\\n                    // apparently in IE everythin is possible.\\n                    that._didClose(2007, \\\"Transport timeouted\\\");\\n                }\\n            });\\n\\n            var connid = utils.random_string(8);\\n            var trans_url = that._base_url + '/' + that._server + '/' + connid;\\n            that._debug('Opening transport:', protocol, ' url:'+trans_url,\\n                        ' RTO:'+that._options.rto);\\n            that._transport = new SockJS[protocol](that, trans_url,\\n                                                   that._base_url);\\n            return true;\\n        }\\n    }\\n};\\n\\nSockJS.prototype.close = function(code, reason) {\\n    var that = this;\\n    if (code && !utils.userSetCode(code))\\n        throw new Error(\\\"INVALID_ACCESS_ERR\\\");\\n    if(that.readyState !== SockJS.CONNECTING &&\\n       that.readyState !== SockJS.OPEN) {\\n        return false;\\n    }\\n    that.readyState = SockJS.CLOSING;\\n    that._didClose(code || 1000, reason || \\\"Normal closure\\\");\\n    return true;\\n};\\n\\nSockJS.prototype.send = function(data) {\\n    var that = this;\\n    if (that.readyState === SockJS.CONNECTING)\\n        throw new Error('INVALID_STATE_ERR');\\n    if (that.readyState === SockJS.OPEN) {\\n        that._transport.doSend(utils.quote('' + data));\\n    }\\n    return true;\\n};\\n\\nSockJS.prototype._applyInfo = function(info, rtt, protocols_whitelist) {\\n    var that = this;\\n    that._options.info = info;\\n    that._options.rtt = rtt;\\n    that._options.rto = utils.countRTO(rtt);\\n    that._options.info.null_origin = !_document.domain;\\n    // Servers can override base_url, eg to provide a randomized domain name and\\n    // avoid browser per-domain connection limits.\\n    if (info.base_url)\\n      // <METEOR>\\n      that._base_url = utils.amendUrl(info.base_url, that._base_url);\\n      // </METEOR>\\n    var probed = utils.probeProtocols();\\n    that._protocols = utils.detectProtocols(probed, protocols_whitelist, info);\\n// <METEOR>\\n// https://github.com/sockjs/sockjs-client/issues/79\\n    // Hack to avoid XDR when using different protocols\\n    // We're on IE trying to do cross-protocol. jsonp only.\\n    if (!utils.isSameOriginScheme(that._base_url) &&\\n        2 === utils.isXHRCorsCapable()) {\\n        that._protocols = ['jsonp-polling'];\\n    }\\n// </METEOR>\\n};\\n//         [*] End of lib/sockjs.js\\n\\n\\n//         [*] Including lib/trans-websocket.js\\n/*\\n * ***** BEGIN LICENSE BLOCK *****\\n * Copyright (c) 2011-2012 VMware, Inc.\\n *\\n * For the license see COPYING.\\n * ***** END LICENSE BLOCK *****\\n */\\n\\nvar WebSocketTransport = SockJS.websocket = function(ri, trans_url) {\\n    var that = this;\\n    var url = trans_url + '/websocket';\\n    if (url.slice(0, 5) === 'https') {\\n        url = 'wss' + url.slice(5);\\n    } else {\\n        url = 'ws' + url.slice(4);\\n    }\\n    that.ri = ri;\\n    that.url = url;\\n    var Constructor = _window.WebSocket || _window.MozWebSocket;\\n\\n    that.ws = new Constructor(that.url);\\n    that.ws.onmessage = function(e) {\\n        that.ri._didMessage(e.data);\\n    };\\n    // Firefox has an interesting bug. If a websocket connection is\\n    // created after onunload, it stays alive even when user\\n    // navigates away from the page. In such situation let's lie -\\n    // let's not open the ws connection at all. See:\\n    // https://github.com/sockjs/sockjs-client/issues/28\\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=696085\\n    that.unload_ref = utils.unload_add(function(){that.ws.close()});\\n    that.ws.onclose = function() {\\n        that.ri._didMessage(utils.closeFrame(1006, \\\"WebSocket connection broken\\\"));\\n    };\\n};\\n\\nWebSocketTransport.prototype.doSend = function(data) {\\n    this.ws.send('[' + data + ']');\\n};\\n\\nWebSocketTransport.prototype.doCleanup = function() {\\n    var that = this;\\n    var ws = that.ws;\\n    if (ws) {\\n        ws.onmessage = ws.onclose = null;\\n        ws.close();\\n        utils.unload_del(that.unload_ref);\\n        that.unload_ref = that.ri = that.ws = null;\\n    }\\n};\\n\\nWebSocketTransport.enabled = function() {\\n    return !!(_window.WebSocket || _window.MozWebSocket);\\n};\\n\\n// In theory, ws should require 1 round trip. But in chrome, this is\\n// not very stable over SSL. Most likely a ws connection requires a\\n// separate SSL connection, in which case 2 round trips are an\\n// absolute minumum.\\nWebSocketTransport.roundTrips = 2;\\n//         [*] End of lib/trans-websocket.js\\n\\n\\n//         [*] Including lib/trans-sender.js\\n/*\\n * ***** BEGIN LICENSE BLOCK *****\\n * Copyright (c) 2011-2012 VMware, Inc.\\n *\\n * For the license see COPYING.\\n * ***** END LICENSE BLOCK *****\\n */\\n\\nvar BufferedSender = function() {};\\nBufferedSender.prototype.send_constructor = function(sender) {\\n    var that = this;\\n    that.send_buffer = [];\\n    that.sender = sender;\\n};\\nBufferedSender.prototype.doSend = function(message) {\\n    var that = this;\\n    that.send_buffer.push(message);\\n    if (!that.send_stop) {\\n        that.send_schedule();\\n    }\\n};\\n\\n// For polling transports in a situation when in the message callback,\\n// new message is being send. If the sending connection was started\\n// before receiving one, it is possible to saturate the network and\\n// timeout due to the lack of receiving socket. To avoid that we delay\\n// sending messages by some small time, in order to let receiving\\n// connection be started beforehand. This is only a halfmeasure and\\n// does not fix the big problem, but it does make the tests go more\\n// stable on slow networks.\\nBufferedSender.prototype.send_schedule_wait = function() {\\n    var that = this;\\n    var tref;\\n    that.send_stop = function() {\\n        that.send_stop = null;\\n        clearTimeout(tref);\\n    };\\n    tref = utils.delay(25, function() {\\n        that.send_stop = null;\\n        that.send_schedule();\\n    });\\n};\\n\\nBufferedSender.prototype.send_schedule = function() {\\n    var that = this;\\n    if (that.send_buffer.length > 0) {\\n        var payload = '[' + that.send_buffer.join(',') + ']';\\n        that.send_stop = that.sender(that.trans_url, payload, function(success, abort_reason) {\\n            that.send_stop = null;\\n            if (success === false) {\\n                that.ri._didClose(1006, 'Sending error ' + abort_reason);\\n            } else {\\n                that.send_schedule_wait();\\n            }\\n        });\\n        that.send_buffer = [];\\n    }\\n};\\n\\nBufferedSender.prototype.send_destructor = function() {\\n    var that = this;\\n    if (that._send_stop) {\\n        that._send_stop();\\n    }\\n    that._send_stop = null;\\n};\\n\\nvar jsonPGenericSender = function(url, payload, callback) {\\n    var that = this;\\n\\n    if (!('_send_form' in that)) {\\n        var form = that._send_form = _document.createElement('form');\\n        var area = that._send_area = _document.createElement('textarea');\\n        area.name = 'd';\\n        form.style.display = 'none';\\n        form.style.position = 'absolute';\\n        form.method = 'POST';\\n        form.enctype = 'application/x-www-form-urlencoded';\\n        form.acceptCharset = \\\"UTF-8\\\";\\n        form.appendChild(area);\\n        _document.body.appendChild(form);\\n    }\\n    var form = that._send_form;\\n    var area = that._send_area;\\n    var id = 'a' + utils.random_string(8);\\n    form.target = id;\\n    form.action = url + '/jsonp_send?i=' + id;\\n\\n    var iframe;\\n    try {\\n        // ie6 dynamic iframes with target=\\\"\\\" support (thanks Chris Lambacher)\\n        iframe = _document.createElement('<iframe name=\\\"'+ id +'\\\">');\\n    } catch(x) {\\n        iframe = _document.createElement('iframe');\\n        iframe.name = id;\\n    }\\n    iframe.id = id;\\n    form.appendChild(iframe);\\n    iframe.style.display = 'none';\\n\\n    try {\\n        area.value = payload;\\n    } catch(e) {\\n        utils.log('Your browser is seriously broken. Go home! ' + e.message);\\n    }\\n    form.submit();\\n\\n    var completed = function(e) {\\n        if (!iframe.onerror) return;\\n        iframe.onreadystatechange = iframe.onerror = iframe.onload = null;\\n        // Opera mini doesn't like if we GC iframe\\n        // immediately, thus this timeout.\\n        utils.delay(500, function() {\\n                       iframe.parentNode.removeChild(iframe);\\n                       iframe = null;\\n                   });\\n        area.value = '';\\n        // It is not possible to detect if the iframe succeeded or\\n        // failed to submit our form.\\n        callback(true);\\n    };\\n    iframe.onerror = iframe.onload = completed;\\n    iframe.onreadystatechange = function(e) {\\n        if (iframe.readyState == 'complete') completed();\\n    };\\n    return completed;\\n};\\n\\nvar createAjaxSender = function(AjaxObject) {\\n    return function(url, payload, callback) {\\n        var xo = new AjaxObject('POST', url + '/xhr_send', payload);\\n        xo.onfinish = function(status, text) {\\n            callback(status === 200 || status === 204,\\n                     'http status ' + status);\\n        };\\n        return function(abort_reason) {\\n            callback(false, abort_reason);\\n        };\\n    };\\n};\\n//         [*] End of lib/trans-sender.js\\n\\n\\n//         [*] Including lib/trans-jsonp-receiver.js\\n/*\\n * ***** BEGIN LICENSE BLOCK *****\\n * Copyright (c) 2011-2012 VMware, Inc.\\n *\\n * For the license see COPYING.\\n * ***** END LICENSE BLOCK *****\\n */\\n\\n// Parts derived from Socket.io:\\n//    https://github.com/LearnBoost/socket.io/blob/0.6.17/lib/socket.io/transports/jsonp-polling.js\\n// and jQuery-JSONP:\\n//    https://code.google.com/p/jquery-jsonp/source/browse/trunk/core/jquery.jsonp.js\\nvar jsonPGenericReceiver = function(url, callback) {\\n    var tref;\\n    var script = _document.createElement('script');\\n    var script2;  // Opera synchronous load trick.\\n    var close_script = function(frame) {\\n        if (script2) {\\n            script2.parentNode.removeChild(script2);\\n            script2 = null;\\n        }\\n        if (script) {\\n            clearTimeout(tref);\\n            // Unfortunately, you can't really abort script loading of\\n            // the script.\\n            script.parentNode.removeChild(script);\\n            script.onreadystatechange = script.onerror =\\n                script.onload = script.onclick = null;\\n            script = null;\\n            callback(frame);\\n            callback = null;\\n        }\\n    };\\n\\n    // IE9 fires 'error' event after orsc or before, in random order.\\n    var loaded_okay = false;\\n    var error_timer = null;\\n\\n    script.id = 'a' + utils.random_string(8);\\n    script.src = url;\\n    script.type = 'text/javascript';\\n    script.charset = 'UTF-8';\\n    script.onerror = function(e) {\\n        if (!error_timer) {\\n            // Delay firing close_script.\\n            error_timer = setTimeout(function() {\\n                if (!loaded_okay) {\\n                    close_script(utils.closeFrame(\\n                        1006,\\n                        \\\"JSONP script loaded abnormally (onerror)\\\"));\\n                }\\n            }, 1000);\\n        }\\n    };\\n    script.onload = function(e) {\\n        close_script(utils.closeFrame(1006, \\\"JSONP script loaded abnormally (onload)\\\"));\\n    };\\n\\n    script.onreadystatechange = function(e) {\\n        if (/loaded|closed/.test(script.readyState)) {\\n            if (script && script.htmlFor && script.onclick) {\\n                loaded_okay = true;\\n                try {\\n                    // In IE, actually execute the script.\\n                    script.onclick();\\n                } catch (x) {}\\n            }\\n            if (script) {\\n                close_script(utils.closeFrame(1006, \\\"JSONP script loaded abnormally (onreadystatechange)\\\"));\\n            }\\n        }\\n    };\\n    // IE: event/htmlFor/onclick trick.\\n    // One can't rely on proper order for onreadystatechange. In order to\\n    // make sure, set a 'htmlFor' and 'event' properties, so that\\n    // script code will be installed as 'onclick' handler for the\\n    // script object. Later, onreadystatechange, manually execute this\\n    // code. FF and Chrome doesn't work with 'event' and 'htmlFor'\\n    // set. For reference see:\\n    //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html\\n    // Also, read on that about script ordering:\\n    //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order\\n    if (typeof script.async === 'undefined' && _document.attachEvent) {\\n        // According to mozilla docs, in recent browsers script.async defaults\\n        // to 'true', so we may use it to detect a good browser:\\n        // https://developer.mozilla.org/en/HTML/Element/script\\n        if (!/opera/i.test(navigator.userAgent)) {\\n            // Naively assume we're in IE\\n            try {\\n                script.htmlFor = script.id;\\n                script.event = \\\"onclick\\\";\\n            } catch (x) {}\\n            script.async = true;\\n        } else {\\n            // Opera, second sync script hack\\n            script2 = _document.createElement('script');\\n            script2.text = \\\"try{var a = document.getElementById('\\\"+script.id+\\\"'); if(a)a.onerror();}catch(x){};\\\";\\n            script.async = script2.async = false;\\n        }\\n    }\\n    if (typeof script.async !== 'undefined') {\\n        script.async = true;\\n    }\\n\\n    // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.\\n    tref = setTimeout(function() {\\n                          close_script(utils.closeFrame(1006, \\\"JSONP script loaded abnormally (timeout)\\\"));\\n                      }, 35000);\\n\\n    var head = _document.getElementsByTagName('head')[0];\\n    head.insertBefore(script, head.firstChild);\\n    if (script2) {\\n        head.insertBefore(script2, head.firstChild);\\n    }\\n    return close_script;\\n};\\n//         [*] End of lib/trans-jsonp-receiver.js\\n\\n\\n//         [*] Including lib/trans-jsonp-polling.js\\n/*\\n * ***** BEGIN LICENSE BLOCK *****\\n * Copyright (c) 2011-2012 VMware, Inc.\\n *\\n * For the license see COPYING.\\n * ***** END LICENSE BLOCK *****\\n */\\n\\n// The simplest and most robust transport, using the well-know cross\\n// domain hack - JSONP. This transport is quite inefficient - one\\n// mssage could use up to one http request. But at least it works almost\\n// everywhere.\\n// Known limitations:\\n//   o you will get a spinning cursor\\n//   o for Konqueror a dumb timer is needed to detect errors\\n\\n\\nvar JsonPTransport = SockJS['jsonp-polling'] = function(ri, trans_url) {\\n    utils.polluteGlobalNamespace();\\n    var that = this;\\n    that.ri = ri;\\n    that.trans_url = trans_url;\\n    that.send_constructor(jsonPGenericSender);\\n    that._schedule_recv();\\n};\\n\\n// Inheritnace\\nJsonPTransport.prototype = new BufferedSender();\\n\\nJsonPTransport.prototype._schedule_recv = function() {\\n    var that = this;\\n    var callback = function(data) {\\n        that._recv_stop = null;\\n        if (data) {\\n            // no data - heartbeat;\\n            if (!that._is_closing) {\\n                that.ri._didMessage(data);\\n            }\\n        }\\n        // The message can be a close message, and change is_closing state.\\n        if (!that._is_closing) {\\n            that._schedule_recv();\\n        }\\n    };\\n    that._recv_stop = jsonPReceiverWrapper(that.trans_url + '/jsonp',\\n                                           jsonPGenericReceiver, callback);\\n};\\n\\nJsonPTransport.enabled = function() {\\n    return true;\\n};\\n\\nJsonPTransport.need_body = true;\\n\\n\\nJsonPTransport.prototype.doCleanup = function() {\\n    var that = this;\\n    that._is_closing = true;\\n    if (that._recv_stop) {\\n        that._recv_stop();\\n    }\\n    that.ri = that._recv_stop = null;\\n    that.send_destructor();\\n};\\n\\n\\n// Abstract away code that handles global namespace pollution.\\nvar jsonPReceiverWrapper = function(url, constructReceiver, user_callback) {\\n    var id = 'a' + utils.random_string(6);\\n    var url_id = url + '?c=' + escape(WPrefix + '.' + id);\\n\\n    // Unfortunately it is not possible to abort loading of the\\n    // script. We need to keep track of frake close frames.\\n    var aborting = 0;\\n\\n    // Callback will be called exactly once.\\n    var callback = function(frame) {\\n        switch(aborting) {\\n        case 0:\\n            // Normal behaviour - delete hook _and_ emit message.\\n            delete _window[WPrefix][id];\\n            user_callback(frame);\\n            break;\\n        case 1:\\n            // Fake close frame - emit but don't delete hook.\\n            user_callback(frame);\\n            aborting = 2;\\n            break;\\n        case 2:\\n            // Got frame after connection was closed, delete hook, don't emit.\\n            delete _window[WPrefix][id];\\n            break;\\n        }\\n    };\\n\\n    var close_script = constructReceiver(url_id, callback);\\n    _window[WPrefix][id] = close_script;\\n    var stop = function() {\\n        if (_window[WPrefix][id]) {\\n            aborting = 1;\\n            _window[WPrefix][id](utils.closeFrame(1000, \\\"JSONP user aborted read\\\"));\\n        }\\n    };\\n    return stop;\\n};\\n//         [*] End of lib/trans-jsonp-polling.js\\n\\n\\n//         [*] Including lib/trans-xhr.js\\n/*\\n * ***** BEGIN LICENSE BLOCK *****\\n * Copyright (c) 2011-2012 VMware, Inc.\\n *\\n * For the license see COPYING.\\n * ***** END LICENSE BLOCK *****\\n */\\n\\nvar AjaxBasedTransport = function() {};\\nAjaxBasedTransport.prototype = new BufferedSender();\\n\\nAjaxBasedTransport.prototype.run = function(ri, trans_url,\\n                                            url_suffix, Receiver, AjaxObject) {\\n    var that = this;\\n    that.ri = ri;\\n    that.trans_url = trans_url;\\n    that.send_constructor(createAjaxSender(AjaxObject));\\n    that.poll = new Polling(ri, Receiver,\\n                            trans_url + url_suffix, AjaxObject);\\n};\\n\\nAjaxBasedTransport.prototype.doCleanup = function() {\\n    var that = this;\\n    if (that.poll) {\\n        that.poll.abort();\\n        that.poll = null;\\n    }\\n};\\n\\n// xhr-streaming\\nvar XhrStreamingTransport = SockJS['xhr-streaming'] = function(ri, trans_url) {\\n    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XHRCorsObject);\\n};\\n\\nXhrStreamingTransport.prototype = new AjaxBasedTransport();\\n\\nXhrStreamingTransport.enabled = function() {\\n    // Support for CORS Ajax aka Ajax2? Opera 12 claims CORS but\\n    // doesn't do streaming.\\n    return (_window.XMLHttpRequest &&\\n            'withCredentials' in new XMLHttpRequest() &&\\n            (!/opera/i.test(navigator.userAgent)));\\n};\\nXhrStreamingTransport.roundTrips = 2; // preflight, ajax\\n\\n// Safari gets confused when a streaming ajax request is started\\n// before onload. This causes the load indicator to spin indefinetely.\\nXhrStreamingTransport.need_body = true;\\n\\n\\n// According to:\\n//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests\\n//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/\\n\\n\\n// xdr-streaming\\nvar XdrStreamingTransport = SockJS['xdr-streaming'] = function(ri, trans_url) {\\n    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XDRObject);\\n};\\n\\nXdrStreamingTransport.prototype = new AjaxBasedTransport();\\n\\nXdrStreamingTransport.enabled = function() {\\n    return !!_window.XDomainRequest;\\n};\\nXdrStreamingTransport.roundTrips = 2; // preflight, ajax\\n\\n\\n\\n// xhr-polling\\nvar XhrPollingTransport = SockJS['xhr-polling'] = function(ri, trans_url) {\\n    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRCorsObject);\\n};\\n\\nXhrPollingTransport.prototype = new AjaxBasedTransport();\\n\\nXhrPollingTransport.enabled = XhrStreamingTransport.enabled;\\nXhrPollingTransport.roundTrips = 2; // preflight, ajax\\n\\n\\n// xdr-polling\\nvar XdrPollingTransport = SockJS['xdr-polling'] = function(ri, trans_url) {\\n    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XDRObject);\\n};\\n\\nXdrPollingTransport.prototype = new AjaxBasedTransport();\\n\\nXdrPollingTransport.enabled = XdrStreamingTransport.enabled;\\nXdrPollingTransport.roundTrips = 2; // preflight, ajax\\n//         [*] End of lib/trans-xhr.js\\n\\n\\n//         [*] Including lib/trans-iframe.js\\n/*\\n * ***** BEGIN LICENSE BLOCK *****\\n * Copyright (c) 2011-2012 VMware, Inc.\\n *\\n * For the license see COPYING.\\n * ***** END LICENSE BLOCK *****\\n */\\n\\n// Few cool transports do work only for same-origin. In order to make\\n// them working cross-domain we shall use iframe, served form the\\n// remote domain. New browsers, have capabilities to communicate with\\n// cross domain iframe, using postMessage(). In IE it was implemented\\n// from IE 8+, but of course, IE got some details wrong:\\n//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx\\n//    http://stevesouders.com/misc/test-postmessage.php\\n\\nvar IframeTransport = function() {};\\n\\nIframeTransport.prototype.i_constructor = function(ri, trans_url, base_url) {\\n    var that = this;\\n    that.ri = ri;\\n    that.origin = utils.getOrigin(base_url);\\n    that.base_url = base_url;\\n    that.trans_url = trans_url;\\n\\n    var iframe_url = base_url + '/iframe.html';\\n    if (that.ri._options.devel) {\\n        iframe_url += '?t=' + (+new Date);\\n    }\\n    that.window_id = utils.random_string(8);\\n    iframe_url += '#' + that.window_id;\\n\\n    that.iframeObj = utils.createIframe(iframe_url, function(r) {\\n                                            that.ri._didClose(1006, \\\"Unable to load an iframe (\\\" + r + \\\")\\\");\\n                                        });\\n\\n    that.onmessage_cb = utils.bind(that.onmessage, that);\\n    utils.attachMessage(that.onmessage_cb);\\n};\\n\\nIframeTransport.prototype.doCleanup = function() {\\n    var that = this;\\n    if (that.iframeObj) {\\n        utils.detachMessage(that.onmessage_cb);\\n        try {\\n            // When the iframe is not loaded, IE raises an exception\\n            // on 'contentWindow'.\\n            if (that.iframeObj.iframe.contentWindow) {\\n                that.postMessage('c');\\n            }\\n        } catch (x) {}\\n        that.iframeObj.cleanup();\\n        that.iframeObj = null;\\n        that.onmessage_cb = that.iframeObj = null;\\n    }\\n};\\n\\nIframeTransport.prototype.onmessage = function(e) {\\n    var that = this;\\n    if (e.origin !== that.origin) return;\\n    var window_id = e.data.slice(0, 8);\\n    var type = e.data.slice(8, 9);\\n    var data = e.data.slice(9);\\n\\n    if (window_id !== that.window_id) return;\\n\\n    switch(type) {\\n    case 's':\\n        that.iframeObj.loaded();\\n        that.postMessage('s', JSON.stringify([SockJS.version, that.protocol, that.trans_url, that.base_url]));\\n        break;\\n    case 't':\\n        that.ri._didMessage(data);\\n        break;\\n    }\\n};\\n\\nIframeTransport.prototype.postMessage = function(type, data) {\\n    var that = this;\\n    that.iframeObj.post(that.window_id + type + (data || ''), that.origin);\\n};\\n\\nIframeTransport.prototype.doSend = function (message) {\\n    this.postMessage('m', message);\\n};\\n\\nIframeTransport.enabled = function() {\\n    // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with\\n    // huge delay, or not at all.\\n    var konqueror = navigator && navigator.userAgent && navigator.userAgent.indexOf('Konqueror') !== -1;\\n    return ((typeof _window.postMessage === 'function' ||\\n            typeof _window.postMessage === 'object') && (!konqueror));\\n};\\n//         [*] End of lib/trans-iframe.js\\n\\n\\n//         [*] Including lib/trans-iframe-within.js\\n/*\\n * ***** BEGIN LICENSE BLOCK *****\\n * Copyright (c) 2011-2012 VMware, Inc.\\n *\\n * For the license see COPYING.\\n * ***** END LICENSE BLOCK *****\\n */\\n\\nvar curr_window_id;\\n\\nvar postMessage = function (type, data) {\\n    if(parent !== _window) {\\n        parent.postMessage(curr_window_id + type + (data || ''), '*');\\n    } else {\\n        utils.log(\\\"Can't postMessage, no parent window.\\\", type, data);\\n    }\\n};\\n\\nvar FacadeJS = function() {};\\nFacadeJS.prototype._didClose = function (code, reason) {\\n    postMessage('t', utils.closeFrame(code, reason));\\n};\\nFacadeJS.prototype._didMessage = function (frame) {\\n    postMessage('t', frame);\\n};\\nFacadeJS.prototype._doSend = function (data) {\\n    this._transport.doSend(data);\\n};\\nFacadeJS.prototype._doCleanup = function () {\\n    this._transport.doCleanup();\\n};\\n\\nutils.parent_origin = undefined;\\n\\nSockJS.bootstrap_iframe = function() {\\n    var facade;\\n    curr_window_id = _document.location.hash.slice(1);\\n    var onMessage = function(e) {\\n        if(e.source !== parent) return;\\n        if(typeof utils.parent_origin === 'undefined')\\n            utils.parent_origin = e.origin;\\n        if (e.origin !== utils.parent_origin) return;\\n\\n        var window_id = e.data.slice(0, 8);\\n        var type = e.data.slice(8, 9);\\n        var data = e.data.slice(9);\\n        if (window_id !== curr_window_id) return;\\n        switch(type) {\\n        case 's':\\n            var p = JSON.parse(data);\\n            var version = p[0];\\n            var protocol = p[1];\\n            var trans_url = p[2];\\n            var base_url = p[3];\\n            if (version !== SockJS.version) {\\n                utils.log(\\\"Incompatibile SockJS! Main site uses:\\\" +\\n                          \\\" \\\\\\\"\\\" + version + \\\"\\\\\\\", the iframe:\\\" +\\n                          \\\" \\\\\\\"\\\" + SockJS.version + \\\"\\\\\\\".\\\");\\n            }\\n            if (!utils.flatUrl(trans_url) || !utils.flatUrl(base_url)) {\\n                utils.log(\\\"Only basic urls are supported in SockJS\\\");\\n                return;\\n            }\\n\\n            if (!utils.isSameOriginUrl(trans_url) ||\\n                !utils.isSameOriginUrl(base_url)) {\\n                utils.log(\\\"Can't connect to different domain from within an \\\" +\\n                          \\\"iframe. (\\\" + JSON.stringify([_window.location.href, trans_url, base_url]) +\\n                          \\\")\\\");\\n                return;\\n            }\\n            facade = new FacadeJS();\\n            facade._transport = new FacadeJS[protocol](facade, trans_url, base_url);\\n            break;\\n        case 'm':\\n            facade._doSend(data);\\n            break;\\n        case 'c':\\n            if (facade)\\n                facade._doCleanup();\\n            facade = null;\\n            break;\\n        }\\n    };\\n\\n    // alert('test ticker');\\n    // facade = new FacadeJS();\\n    // facade._transport = new FacadeJS['w-iframe-xhr-polling'](facade, 'http://host.com:9999/ticker/12/basd');\\n\\n    utils.attachMessage(onMessage);\\n\\n    // Start\\n    postMessage('s');\\n};\\n//         [*] End of lib/trans-iframe-within.js\\n\\n\\n//         [*] Including lib/info.js\\n/*\\n * ***** BEGIN LICENSE BLOCK *****\\n * Copyright (c) 2011-2012 VMware, Inc.\\n *\\n * For the license see COPYING.\\n * ***** END LICENSE BLOCK *****\\n */\\n\\nvar InfoReceiver = function(base_url, AjaxObject) {\\n    var that = this;\\n    utils.delay(function(){that.doXhr(base_url, AjaxObject);});\\n};\\n\\nInfoReceiver.prototype = new EventEmitter(['finish']);\\n\\nInfoReceiver.prototype.doXhr = function(base_url, AjaxObject) {\\n    var that = this;\\n    var t0 = (new Date()).getTime();\\n\\n// <METEOR>\\n  // https://github.com/sockjs/sockjs-client/pull/129\\n  // var xo = new AjaxObject('GET', base_url + '/info');\\n\\n    var xo = new AjaxObject(\\n      // add cachebusting parameter to url to work around a chrome bug:\\n      // https://code.google.com/p/chromium/issues/detail?id=263981\\n      // or misbehaving proxies.\\n      'GET', base_url + '/info?cb=' + utils.random_string(10))\\n// </METEOR>\\n\\n    var tref = utils.delay(8000,\\n                           function(){xo.ontimeout();});\\n\\n    xo.onfinish = function(status, text) {\\n        clearTimeout(tref);\\n        tref = null;\\n        if (status === 200) {\\n            var rtt = (new Date()).getTime() - t0;\\n            var info = JSON.parse(text);\\n            if (typeof info !== 'object') info = {};\\n            that.emit('finish', info, rtt);\\n        } else {\\n            that.emit('finish');\\n        }\\n    };\\n    xo.ontimeout = function() {\\n        xo.close();\\n        that.emit('finish');\\n    };\\n};\\n\\nvar InfoReceiverIframe = function(base_url) {\\n    var that = this;\\n    var go = function() {\\n        var ifr = new IframeTransport();\\n        ifr.protocol = 'w-iframe-info-receiver';\\n        var fun = function(r) {\\n            if (typeof r === 'string' && r.substr(0,1) === 'm') {\\n                var d = JSON.parse(r.substr(1));\\n                var info = d[0], rtt = d[1];\\n                that.emit('finish', info, rtt);\\n            } else {\\n                that.emit('finish');\\n            }\\n            ifr.doCleanup();\\n            ifr = null;\\n        };\\n        var mock_ri = {\\n            _options: {},\\n            _didClose: fun,\\n            _didMessage: fun\\n        };\\n        ifr.i_constructor(mock_ri, base_url, base_url);\\n    }\\n    if(!_document.body) {\\n        utils.attachEvent('load', go);\\n    } else {\\n        go();\\n    }\\n};\\nInfoReceiverIframe.prototype = new EventEmitter(['finish']);\\n\\n\\nvar InfoReceiverFake = function() {\\n    // It may not be possible to do cross domain AJAX to get the info\\n    // data, for example for IE7. But we want to run JSONP, so let's\\n    // fake the response, with rtt=2s (rto=6s).\\n    var that = this;\\n    utils.delay(function() {\\n        that.emit('finish', {}, 2000);\\n    });\\n};\\nInfoReceiverFake.prototype = new EventEmitter(['finish']);\\n\\nvar createInfoReceiver = function(base_url) {\\n    if (utils.isSameOriginUrl(base_url)) {\\n        // If, for some reason, we have SockJS locally - there's no\\n        // need to start up the complex machinery. Just use ajax.\\n        return new InfoReceiver(base_url, utils.XHRLocalObject);\\n    }\\n    switch (utils.isXHRCorsCapable()) {\\n    case 1:\\n        // XHRLocalObject -> no_credentials=true\\n        return new InfoReceiver(base_url, utils.XHRLocalObject);\\n    case 2:\\n// <METEOR>\\n// https://github.com/sockjs/sockjs-client/issues/79\\n        // XDR doesn't work across different schemes\\n        // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx\\n        if (utils.isSameOriginScheme(base_url))\\n            return new InfoReceiver(base_url, utils.XDRObject);\\n        else\\n            return new InfoReceiverFake();\\n// </METEOR>\\n    case 3:\\n        // Opera\\n        return new InfoReceiverIframe(base_url);\\n    default:\\n        // IE 7\\n        return new InfoReceiverFake();\\n    };\\n};\\n\\n\\nvar WInfoReceiverIframe = FacadeJS['w-iframe-info-receiver'] = function(ri, _trans_url, base_url) {\\n    var ir = new InfoReceiver(base_url, utils.XHRLocalObject);\\n    ir.onfinish = function(info, rtt) {\\n        ri._didMessage('m'+JSON.stringify([info, rtt]));\\n        ri._didClose();\\n    }\\n};\\nWInfoReceiverIframe.prototype.doCleanup = function() {};\\n//         [*] End of lib/info.js\\n\\n\\n//         [*] Including lib/trans-iframe-eventsource.js\\n/*\\n * ***** BEGIN LICENSE BLOCK *****\\n * Copyright (c) 2011-2012 VMware, Inc.\\n *\\n * For the license see COPYING.\\n * ***** END LICENSE BLOCK *****\\n */\\n\\nvar EventSourceIframeTransport = SockJS['iframe-eventsource'] = function () {\\n    var that = this;\\n    that.protocol = 'w-iframe-eventsource';\\n    that.i_constructor.apply(that, arguments);\\n};\\n\\nEventSourceIframeTransport.prototype = new IframeTransport();\\n\\nEventSourceIframeTransport.enabled = function () {\\n    return ('EventSource' in _window) && IframeTransport.enabled();\\n};\\n\\nEventSourceIframeTransport.need_body = true;\\nEventSourceIframeTransport.roundTrips = 3; // html, javascript, eventsource\\n\\n\\n// w-iframe-eventsource\\nvar EventSourceTransport = FacadeJS['w-iframe-eventsource'] = function(ri, trans_url) {\\n    this.run(ri, trans_url, '/eventsource', EventSourceReceiver, utils.XHRLocalObject);\\n}\\nEventSourceTransport.prototype = new AjaxBasedTransport();\\n//         [*] End of lib/trans-iframe-eventsource.js\\n\\n\\n//         [*] Including lib/trans-iframe-xhr-polling.js\\n/*\\n * ***** BEGIN LICENSE BLOCK *****\\n * Copyright (c) 2011-2012 VMware, Inc.\\n *\\n * For the license see COPYING.\\n * ***** END LICENSE BLOCK *****\\n */\\n\\nvar XhrPollingIframeTransport = SockJS['iframe-xhr-polling'] = function () {\\n    var that = this;\\n    that.protocol = 'w-iframe-xhr-polling';\\n    that.i_constructor.apply(that, arguments);\\n};\\n\\nXhrPollingIframeTransport.prototype = new IframeTransport();\\n\\nXhrPollingIframeTransport.enabled = function () {\\n    return _window.XMLHttpRequest && IframeTransport.enabled();\\n};\\n\\nXhrPollingIframeTransport.need_body = true;\\nXhrPollingIframeTransport.roundTrips = 3; // html, javascript, xhr\\n\\n\\n// w-iframe-xhr-polling\\nvar XhrPollingITransport = FacadeJS['w-iframe-xhr-polling'] = function(ri, trans_url) {\\n    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRLocalObject);\\n};\\n\\nXhrPollingITransport.prototype = new AjaxBasedTransport();\\n//         [*] End of lib/trans-iframe-xhr-polling.js\\n\\n\\n//         [*] Including lib/trans-iframe-htmlfile.js\\n/*\\n * ***** BEGIN LICENSE BLOCK *****\\n * Copyright (c) 2011-2012 VMware, Inc.\\n *\\n * For the license see COPYING.\\n * ***** END LICENSE BLOCK *****\\n */\\n\\n// This transport generally works in any browser, but will cause a\\n// spinning cursor to appear in any browser other than IE.\\n// We may test this transport in all browsers - why not, but in\\n// production it should be only run in IE.\\n\\nvar HtmlFileIframeTransport = SockJS['iframe-htmlfile'] = function () {\\n    var that = this;\\n    that.protocol = 'w-iframe-htmlfile';\\n    that.i_constructor.apply(that, arguments);\\n};\\n\\n// Inheritance.\\nHtmlFileIframeTransport.prototype = new IframeTransport();\\n\\nHtmlFileIframeTransport.enabled = function() {\\n    return IframeTransport.enabled();\\n};\\n\\nHtmlFileIframeTransport.need_body = true;\\nHtmlFileIframeTransport.roundTrips = 3; // html, javascript, htmlfile\\n\\n\\n// w-iframe-htmlfile\\nvar HtmlFileTransport = FacadeJS['w-iframe-htmlfile'] = function(ri, trans_url) {\\n    this.run(ri, trans_url, '/htmlfile', HtmlfileReceiver, utils.XHRLocalObject);\\n};\\nHtmlFileTransport.prototype = new AjaxBasedTransport();\\n//         [*] End of lib/trans-iframe-htmlfile.js\\n\\n\\n//         [*] Including lib/trans-polling.js\\n/*\\n * ***** BEGIN LICENSE BLOCK *****\\n * Copyright (c) 2011-2012 VMware, Inc.\\n *\\n * For the license see COPYING.\\n * ***** END LICENSE BLOCK *****\\n */\\n\\nvar Polling = function(ri, Receiver, recv_url, AjaxObject) {\\n    var that = this;\\n    that.ri = ri;\\n    that.Receiver = Receiver;\\n    that.recv_url = recv_url;\\n    that.AjaxObject = AjaxObject;\\n    that._scheduleRecv();\\n};\\n\\nPolling.prototype._scheduleRecv = function() {\\n    var that = this;\\n    var poll = that.poll = new that.Receiver(that.recv_url, that.AjaxObject);\\n    var msg_counter = 0;\\n    poll.onmessage = function(e) {\\n        msg_counter += 1;\\n        that.ri._didMessage(e.data);\\n    };\\n    poll.onclose = function(e) {\\n        that.poll = poll = poll.onmessage = poll.onclose = null;\\n        if (!that.poll_is_closing) {\\n            if (e.reason === 'permanent') {\\n                that.ri._didClose(1006, 'Polling error (' + e.reason + ')');\\n            } else {\\n                that._scheduleRecv();\\n            }\\n        }\\n    };\\n};\\n\\nPolling.prototype.abort = function() {\\n    var that = this;\\n    that.poll_is_closing = true;\\n    if (that.poll) {\\n        that.poll.abort();\\n    }\\n};\\n//         [*] End of lib/trans-polling.js\\n\\n\\n//         [*] Including lib/trans-receiver-eventsource.js\\n/*\\n * ***** BEGIN LICENSE BLOCK *****\\n * Copyright (c) 2011-2012 VMware, Inc.\\n *\\n * For the license see COPYING.\\n * ***** END LICENSE BLOCK *****\\n */\\n\\nvar EventSourceReceiver = function(url) {\\n    var that = this;\\n    var es = new EventSource(url);\\n    es.onmessage = function(e) {\\n        that.dispatchEvent(new SimpleEvent('message',\\n                                           {'data': unescape(e.data)}));\\n    };\\n    that.es_close = es.onerror = function(e, abort_reason) {\\n        // ES on reconnection has readyState = 0 or 1.\\n        // on network error it's CLOSED = 2\\n        var reason = abort_reason ? 'user' :\\n            (es.readyState !== 2 ? 'network' : 'permanent');\\n        that.es_close = es.onmessage = es.onerror = null;\\n        // EventSource reconnects automatically.\\n        es.close();\\n        es = null;\\n        // Safari and chrome < 15 crash if we close window before\\n        // waiting for ES cleanup. See:\\n        //   https://code.google.com/p/chromium/issues/detail?id=89155\\n        utils.delay(200, function() {\\n                        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));\\n                    });\\n    };\\n};\\n\\nEventSourceReceiver.prototype = new REventTarget();\\n\\nEventSourceReceiver.prototype.abort = function() {\\n    var that = this;\\n    if (that.es_close) {\\n        that.es_close({}, true);\\n    }\\n};\\n//         [*] End of lib/trans-receiver-eventsource.js\\n\\n\\n//         [*] Including lib/trans-receiver-htmlfile.js\\n/*\\n * ***** BEGIN LICENSE BLOCK *****\\n * Copyright (c) 2011-2012 VMware, Inc.\\n *\\n * For the license see COPYING.\\n * ***** END LICENSE BLOCK *****\\n */\\n\\nvar _is_ie_htmlfile_capable;\\nvar isIeHtmlfileCapable = function() {\\n    if (_is_ie_htmlfile_capable === undefined) {\\n        if ('ActiveXObject' in _window) {\\n            try {\\n                _is_ie_htmlfile_capable = !!new ActiveXObject('htmlfile');\\n            } catch (x) {}\\n        } else {\\n            _is_ie_htmlfile_capable = false;\\n        }\\n    }\\n    return _is_ie_htmlfile_capable;\\n};\\n\\n\\nvar HtmlfileReceiver = function(url) {\\n    var that = this;\\n    utils.polluteGlobalNamespace();\\n\\n    that.id = 'a' + utils.random_string(6, 26);\\n    url += ((url.indexOf('?') === -1) ? '?' : '&') +\\n        'c=' + escape(WPrefix + '.' + that.id);\\n\\n    var constructor = isIeHtmlfileCapable() ?\\n        utils.createHtmlfile : utils.createIframe;\\n\\n    var iframeObj;\\n    _window[WPrefix][that.id] = {\\n        start: function () {\\n            iframeObj.loaded();\\n        },\\n        message: function (data) {\\n            that.dispatchEvent(new SimpleEvent('message', {'data': data}));\\n        },\\n        stop: function () {\\n            that.iframe_close({}, 'network');\\n        }\\n    };\\n    that.iframe_close = function(e, abort_reason) {\\n        iframeObj.cleanup();\\n        that.iframe_close = iframeObj = null;\\n        delete _window[WPrefix][that.id];\\n        that.dispatchEvent(new SimpleEvent('close', {reason: abort_reason}));\\n    };\\n    iframeObj = constructor(url, function(e) {\\n                                that.iframe_close({}, 'permanent');\\n                            });\\n};\\n\\nHtmlfileReceiver.prototype = new REventTarget();\\n\\nHtmlfileReceiver.prototype.abort = function() {\\n    var that = this;\\n    if (that.iframe_close) {\\n        that.iframe_close({}, 'user');\\n    }\\n};\\n//         [*] End of lib/trans-receiver-htmlfile.js\\n\\n\\n//         [*] Including lib/trans-receiver-xhr.js\\n/*\\n * ***** BEGIN LICENSE BLOCK *****\\n * Copyright (c) 2011-2012 VMware, Inc.\\n *\\n * For the license see COPYING.\\n * ***** END LICENSE BLOCK *****\\n */\\n\\nvar XhrReceiver = function(url, AjaxObject) {\\n    var that = this;\\n    var buf_pos = 0;\\n\\n    that.xo = new AjaxObject('POST', url, null);\\n    that.xo.onchunk = function(status, text) {\\n        if (status !== 200) return;\\n        while (1) {\\n            var buf = text.slice(buf_pos);\\n            var p = buf.indexOf('\\\\n');\\n            if (p === -1) break;\\n            buf_pos += p+1;\\n            var msg = buf.slice(0, p);\\n            that.dispatchEvent(new SimpleEvent('message', {data: msg}));\\n        }\\n    };\\n    that.xo.onfinish = function(status, text) {\\n        that.xo.onchunk(status, text);\\n        that.xo = null;\\n        var reason = status === 200 ? 'network' : 'permanent';\\n        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));\\n    }\\n};\\n\\nXhrReceiver.prototype = new REventTarget();\\n\\nXhrReceiver.prototype.abort = function() {\\n    var that = this;\\n    if (that.xo) {\\n        that.xo.close();\\n        that.dispatchEvent(new SimpleEvent('close', {reason: 'user'}));\\n        that.xo = null;\\n    }\\n};\\n//         [*] End of lib/trans-receiver-xhr.js\\n\\n\\n//         [*] Including lib/test-hooks.js\\n/*\\n * ***** BEGIN LICENSE BLOCK *****\\n * Copyright (c) 2011-2012 VMware, Inc.\\n *\\n * For the license see COPYING.\\n * ***** END LICENSE BLOCK *****\\n */\\n\\n// For testing\\nSockJS.getUtils = function(){\\n    return utils;\\n};\\n\\nSockJS.getIframeTransport = function(){\\n    return IframeTransport;\\n};\\n//         [*] End of lib/test-hooks.js\\n\\n                  return SockJS;\\n          })();\\nif ('_sockjs_onload' in window) setTimeout(_sockjs_onload, 1);\\n\\n// AMD compliance\\nif (typeof define === 'function' && define.amd) {\\n    define('sockjs', [], function(){return SockJS;});\\n}\\n//     [*] End of lib/index.js\\n\\n// [*] End of lib/all.js\\n\",\"// @param url {String} URL to Meteor app\\n//   \\\"http://subdomain.meteor.com/\\\" or \\\"/\\\" or\\n//   \\\"ddp+sockjs://foo-**.meteor.com/sockjs\\\"\\nLivedataTest.ClientStream = function (url, options) {\\n  var self = this;\\n  self.options = _.extend({\\n    retry: true\\n  }, options);\\n  self._initCommon(self.options);\\n\\n  //// Constants\\n\\n\\n  // how long between hearing heartbeat from the server until we declare\\n  // the connection dead. heartbeats come every 45s (stream_server.js)\\n  //\\n  // NOTE: this is a older timeout mechanism. We now send heartbeats at\\n  // the DDP level (https://github.com/meteor/meteor/pull/1865), and\\n  // expect those timeouts to kill a non-responsive connection before\\n  // this timeout fires. This is kept around for compatibility (when\\n  // talking to a server that doesn't support DDP heartbeats) and can be\\n  // removed later.\\n  self.HEARTBEAT_TIMEOUT = 100*1000;\\n\\n  self.rawUrl = url;\\n  self.socket = null;\\n\\n  self.heartbeatTimer = null;\\n\\n  // Listen to global 'online' event if we are running in a browser.\\n  // (IE8 does not support addEventListener)\\n  if (typeof window !== 'undefined' && window.addEventListener)\\n    window.addEventListener(\\\"online\\\", _.bind(self._online, self),\\n                            false /* useCapture. make FF3.6 happy. */);\\n\\n  //// Kickoff!\\n  self._launchConnection();\\n};\\n\\n_.extend(LivedataTest.ClientStream.prototype, {\\n\\n  // data is a utf8 string. Data sent while not connected is dropped on\\n  // the floor, and it is up the user of this API to retransmit lost\\n  // messages on 'reset'\\n  send: function (data) {\\n    var self = this;\\n    if (self.currentStatus.connected) {\\n      self.socket.send(data);\\n    }\\n  },\\n\\n  // Changes where this connection points\\n  _changeUrl: function (url) {\\n    var self = this;\\n    self.rawUrl = url;\\n  },\\n\\n  _connected: function () {\\n    var self = this;\\n\\n    if (self.connectionTimer) {\\n      clearTimeout(self.connectionTimer);\\n      self.connectionTimer = null;\\n    }\\n\\n    if (self.currentStatus.connected) {\\n      // already connected. do nothing. this probably shouldn't happen.\\n      return;\\n    }\\n\\n    // update status\\n    self.currentStatus.status = \\\"connected\\\";\\n    self.currentStatus.connected = true;\\n    self.currentStatus.retryCount = 0;\\n    self.statusChanged();\\n\\n    // fire resets. This must come after status change so that clients\\n    // can call send from within a reset callback.\\n    _.each(self.eventCallbacks.reset, function (callback) { callback(); });\\n\\n  },\\n\\n  _cleanup: function (maybeError) {\\n    var self = this;\\n\\n    self._clearConnectionAndHeartbeatTimers();\\n    if (self.socket) {\\n      self.socket.onmessage = self.socket.onclose\\n        = self.socket.onerror = self.socket.onheartbeat = function () {};\\n      self.socket.close();\\n      self.socket = null;\\n    }\\n\\n    _.each(self.eventCallbacks.disconnect, function (callback) {\\n      callback(maybeError);\\n    });\\n  },\\n\\n  _clearConnectionAndHeartbeatTimers: function () {\\n    var self = this;\\n    if (self.connectionTimer) {\\n      clearTimeout(self.connectionTimer);\\n      self.connectionTimer = null;\\n    }\\n    if (self.heartbeatTimer) {\\n      clearTimeout(self.heartbeatTimer);\\n      self.heartbeatTimer = null;\\n    }\\n  },\\n\\n  _heartbeat_timeout: function () {\\n    var self = this;\\n    Meteor._debug(\\\"Connection timeout. No sockjs heartbeat received.\\\");\\n    self._lostConnection(new DDP.ConnectionError(\\\"Heartbeat timed out\\\"));\\n  },\\n\\n  _heartbeat_received: function () {\\n    var self = this;\\n    // If we've already permanently shut down this stream, the timeout is\\n    // already cleared, and we don't need to set it again.\\n    if (self._forcedToDisconnect)\\n      return;\\n    if (self.heartbeatTimer)\\n      clearTimeout(self.heartbeatTimer);\\n    self.heartbeatTimer = setTimeout(\\n      _.bind(self._heartbeat_timeout, self),\\n      self.HEARTBEAT_TIMEOUT);\\n  },\\n\\n  _sockjsProtocolsWhitelist: function () {\\n    // only allow polling protocols. no streaming.  streaming\\n    // makes safari spin.\\n    var protocolsWhitelist = [\\n      'xdr-polling', 'xhr-polling', 'iframe-xhr-polling', 'jsonp-polling'];\\n\\n    // iOS 4 and 5 and below crash when using websockets over certain\\n    // proxies. this seems to be resolved with iOS 6. eg\\n    // https://github.com/LearnBoost/socket.io/issues/193#issuecomment-7308865.\\n    //\\n    // iOS <4 doesn't support websockets at all so sockjs will just\\n    // immediately fall back to http\\n    var noWebsockets = navigator &&\\n          /iPhone|iPad|iPod/.test(navigator.userAgent) &&\\n          /OS 4_|OS 5_/.test(navigator.userAgent);\\n\\n    if (!noWebsockets)\\n      protocolsWhitelist = ['websocket'].concat(protocolsWhitelist);\\n\\n    return protocolsWhitelist;\\n  },\\n\\n  _launchConnection: function () {\\n    var self = this;\\n    self._cleanup(); // cleanup the old socket, if there was one.\\n\\n    var options = _.extend({\\n      protocols_whitelist:self._sockjsProtocolsWhitelist()\\n    }, self.options._sockjsOptions);\\n\\n    // Convert raw URL to SockJS URL each time we open a connection, so that we\\n    // can connect to random hostnames and get around browser per-host\\n    // connection limits.\\n    self.socket = new SockJS(toSockjsUrl(self.rawUrl), undefined, options);\\n    self.socket.onopen = function (data) {\\n      self._connected();\\n    };\\n    self.socket.onmessage = function (data) {\\n      self._heartbeat_received();\\n\\n      if (self.currentStatus.connected)\\n        _.each(self.eventCallbacks.message, function (callback) {\\n          callback(data.data);\\n        });\\n    };\\n    self.socket.onclose = function () {\\n      self._lostConnection();\\n    };\\n    self.socket.onerror = function () {\\n      // XXX is this ever called?\\n      Meteor._debug(\\\"stream error\\\", _.toArray(arguments), (new Date()).toDateString());\\n    };\\n\\n    self.socket.onheartbeat =  function () {\\n      self._heartbeat_received();\\n    };\\n\\n    if (self.connectionTimer)\\n      clearTimeout(self.connectionTimer);\\n    self.connectionTimer = setTimeout(function () {\\n      self._lostConnection(\\n        new DDP.ConnectionError(\\\"DDP connection timed out\\\"));\\n    }, self.CONNECT_TIMEOUT);\\n  }\\n});\\n\",\"// XXX from Underscore.String (http://epeli.github.com/underscore.string/)\\nvar startsWith = function(str, starts) {\\n  return str.length >= starts.length &&\\n    str.substring(0, starts.length) === starts;\\n};\\nvar endsWith = function(str, ends) {\\n  return str.length >= ends.length &&\\n    str.substring(str.length - ends.length) === ends;\\n};\\n\\n// @param url {String} URL to Meteor app, eg:\\n//   \\\"/\\\" or \\\"madewith.meteor.com\\\" or \\\"https://foo.meteor.com\\\"\\n//   or \\\"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\\\"\\n// @returns {String} URL to the endpoint with the specific scheme and subPath, e.g.\\n// for scheme \\\"http\\\" and subPath \\\"sockjs\\\"\\n//   \\\"http://subdomain.meteor.com/sockjs\\\" or \\\"/sockjs\\\"\\n//   or \\\"https://ddp--1234-foo.meteor.com/sockjs\\\"\\nvar translateUrl =  function(url, newSchemeBase, subPath) {\\n  if (! newSchemeBase) {\\n    newSchemeBase = \\\"http\\\";\\n  }\\n\\n  var ddpUrlMatch = url.match(/^ddp(i?)\\\\+sockjs:\\\\/\\\\//);\\n  var httpUrlMatch = url.match(/^http(s?):\\\\/\\\\//);\\n  var newScheme;\\n  if (ddpUrlMatch) {\\n    // Remove scheme and split off the host.\\n    var urlAfterDDP = url.substr(ddpUrlMatch[0].length);\\n    newScheme = ddpUrlMatch[1] === \\\"i\\\" ? newSchemeBase : newSchemeBase + \\\"s\\\";\\n    var slashPos = urlAfterDDP.indexOf('/');\\n    var host =\\n          slashPos === -1 ? urlAfterDDP : urlAfterDDP.substr(0, slashPos);\\n    var rest = slashPos === -1 ? '' : urlAfterDDP.substr(slashPos);\\n\\n    // In the host (ONLY!), change '*' characters into random digits. This\\n    // allows different stream connections to connect to different hostnames\\n    // and avoid browser per-hostname connection limits.\\n    host = host.replace(/\\\\*/g, function () {\\n      return Math.floor(Random.fraction()*10);\\n    });\\n\\n    return newScheme + '://' + host + rest;\\n  } else if (httpUrlMatch) {\\n    newScheme = !httpUrlMatch[1] ? newSchemeBase : newSchemeBase + \\\"s\\\";\\n    var urlAfterHttp = url.substr(httpUrlMatch[0].length);\\n    url = newScheme + \\\"://\\\" + urlAfterHttp;\\n  }\\n\\n  // Prefix FQDNs but not relative URLs\\n  if (url.indexOf(\\\"://\\\") === -1 && !startsWith(url, \\\"/\\\")) {\\n    url = newSchemeBase + \\\"://\\\" + url;\\n  }\\n\\n  // XXX This is not what we should be doing: if I have a site\\n  // deployed at \\\"/foo\\\", then DDP.connect(\\\"/\\\") should actually connect\\n  // to \\\"/\\\", not to \\\"/foo\\\". \\\"/\\\" is an absolute path. (Contrast: if\\n  // deployed at \\\"/foo\\\", it would be reasonable for DDP.connect(\\\"bar\\\")\\n  // to connect to \\\"/foo/bar\\\").\\n  //\\n  // We should make this properly honor absolute paths rather than\\n  // forcing the path to be relative to the site root. Simultaneously,\\n  // we should set DDP_DEFAULT_CONNECTION_URL to include the site\\n  // root. See also client_convenience.js #RationalizingRelativeDDPURLs\\n  url = Meteor._relativeToSiteRootUrl(url);\\n\\n  if (endsWith(url, \\\"/\\\"))\\n    return url + subPath;\\n  else\\n    return url + \\\"/\\\" + subPath;\\n};\\n\\ntoSockjsUrl = function (url) {\\n  return translateUrl(url, \\\"http\\\", \\\"sockjs\\\");\\n};\\n\\ntoWebsocketUrl = function (url) {\\n  var ret = translateUrl(url, \\\"ws\\\", \\\"websocket\\\");\\n  return ret;\\n};\\n\\nLivedataTest.toSockjsUrl = toSockjsUrl;\\n\\n\\n_.extend(LivedataTest.ClientStream.prototype, {\\n\\n  // Register for callbacks.\\n  on: function (name, callback) {\\n    var self = this;\\n\\n    if (name !== 'message' && name !== 'reset' && name !== 'disconnect')\\n      throw new Error(\\\"unknown event type: \\\" + name);\\n\\n    if (!self.eventCallbacks[name])\\n      self.eventCallbacks[name] = [];\\n    self.eventCallbacks[name].push(callback);\\n  },\\n\\n\\n  _initCommon: function (options) {\\n    var self = this;\\n    options = options || {};\\n\\n    //// Constants\\n\\n    // how long to wait until we declare the connection attempt\\n    // failed.\\n    self.CONNECT_TIMEOUT = options.connectTimeoutMs || 10000;\\n\\n    self.eventCallbacks = {}; // name -> [callback]\\n\\n    self._forcedToDisconnect = false;\\n\\n    //// Reactive status\\n    self.currentStatus = {\\n      status: \\\"connecting\\\",\\n      connected: false,\\n      retryCount: 0\\n    };\\n\\n\\n    self.statusListeners = typeof Tracker !== 'undefined' && new Tracker.Dependency;\\n    self.statusChanged = function () {\\n      if (self.statusListeners)\\n        self.statusListeners.changed();\\n    };\\n\\n    //// Retry logic\\n    self._retry = new Retry;\\n    self.connectionTimer = null;\\n\\n  },\\n\\n  // Trigger a reconnect.\\n  reconnect: function (options) {\\n    var self = this;\\n    options = options || {};\\n\\n    if (options.url) {\\n      self._changeUrl(options.url);\\n    }\\n\\n    if (options._sockjsOptions) {\\n      self.options._sockjsOptions = options._sockjsOptions;\\n    }\\n\\n    if (self.currentStatus.connected) {\\n      if (options._force || options.url) {\\n        // force reconnect.\\n        self._lostConnection(new DDP.ForcedReconnectError);\\n      } // else, noop.\\n      return;\\n    }\\n\\n    // if we're mid-connection, stop it.\\n    if (self.currentStatus.status === \\\"connecting\\\") {\\n      // Pretend it's a clean close.\\n      self._lostConnection();\\n    }\\n\\n    self._retry.clear();\\n    self.currentStatus.retryCount -= 1; // don't count manual retries\\n    self._retryNow();\\n  },\\n\\n  disconnect: function (options) {\\n    var self = this;\\n    options = options || {};\\n\\n    // Failed is permanent. If we're failed, don't let people go back\\n    // online by calling 'disconnect' then 'reconnect'.\\n    if (self._forcedToDisconnect)\\n      return;\\n\\n    // If _permanent is set, permanently disconnect a stream. Once a stream\\n    // is forced to disconnect, it can never reconnect. This is for\\n    // error cases such as ddp version mismatch, where trying again\\n    // won't fix the problem.\\n    if (options._permanent) {\\n      self._forcedToDisconnect = true;\\n    }\\n\\n    self._cleanup();\\n    self._retry.clear();\\n\\n    self.currentStatus = {\\n      status: (options._permanent ? \\\"failed\\\" : \\\"offline\\\"),\\n      connected: false,\\n      retryCount: 0\\n    };\\n\\n    if (options._permanent && options._error)\\n      self.currentStatus.reason = options._error;\\n\\n    self.statusChanged();\\n  },\\n\\n  // maybeError is set unless it's a clean protocol-level close.\\n  _lostConnection: function (maybeError) {\\n    var self = this;\\n\\n    self._cleanup(maybeError);\\n    self._retryLater(maybeError); // sets status. no need to do it here.\\n  },\\n\\n  // fired when we detect that we've gone online. try to reconnect\\n  // immediately.\\n  _online: function () {\\n    // if we've requested to be offline by disconnecting, don't reconnect.\\n    if (this.currentStatus.status != \\\"offline\\\")\\n      this.reconnect();\\n  },\\n\\n  _retryLater: function (maybeError) {\\n    var self = this;\\n\\n    var timeout = 0;\\n    if (self.options.retry ||\\n        (maybeError && maybeError.errorType === \\\"DDP.ForcedReconnectError\\\")) {\\n      timeout = self._retry.retryLater(\\n        self.currentStatus.retryCount,\\n        _.bind(self._retryNow, self)\\n      );\\n      self.currentStatus.status = \\\"waiting\\\";\\n      self.currentStatus.retryTime = (new Date()).getTime() + timeout;\\n    } else {\\n      self.currentStatus.status = \\\"failed\\\";\\n      delete self.currentStatus.retryTime;\\n    }\\n\\n    self.currentStatus.connected = false;\\n    self.statusChanged();\\n  },\\n\\n  _retryNow: function () {\\n    var self = this;\\n\\n    if (self._forcedToDisconnect)\\n      return;\\n\\n    self.currentStatus.retryCount += 1;\\n    self.currentStatus.status = \\\"connecting\\\";\\n    self.currentStatus.connected = false;\\n    delete self.currentStatus.retryTime;\\n    self.statusChanged();\\n\\n    self._launchConnection();\\n  },\\n\\n\\n  // Get current status. Reactive.\\n  status: function () {\\n    var self = this;\\n    if (self.statusListeners)\\n      self.statusListeners.depend();\\n    return self.currentStatus;\\n  }\\n});\\n\\nDDP.ConnectionError = Meteor.makeErrorType(\\n  \\\"DDP.ConnectionError\\\", function (message) {\\n    var self = this;\\n    self.message = message;\\n});\\n\\nDDP.ForcedReconnectError = Meteor.makeErrorType(\\n  \\\"DDP.ForcedReconnectError\\\", function () {});\\n\",\"// Heartbeat options:\\n//   heartbeatInterval: interval to send pings, in milliseconds.\\n//   heartbeatTimeout: timeout to close the connection if a reply isn't\\n//     received, in milliseconds.\\n//   sendPing: function to call to send a ping on the connection.\\n//   onTimeout: function to call to close the connection.\\n\\nHeartbeat = function (options) {\\n  var self = this;\\n\\n  self.heartbeatInterval = options.heartbeatInterval;\\n  self.heartbeatTimeout = options.heartbeatTimeout;\\n  self._sendPing = options.sendPing;\\n  self._onTimeout = options.onTimeout;\\n\\n  self._heartbeatIntervalHandle = null;\\n  self._heartbeatTimeoutHandle = null;\\n};\\n\\n_.extend(Heartbeat.prototype, {\\n  stop: function () {\\n    var self = this;\\n    self._clearHeartbeatIntervalTimer();\\n    self._clearHeartbeatTimeoutTimer();\\n  },\\n\\n  start: function () {\\n    var self = this;\\n    self.stop();\\n    self._startHeartbeatIntervalTimer();\\n  },\\n\\n  _startHeartbeatIntervalTimer: function () {\\n    var self = this;\\n    self._heartbeatIntervalHandle = Meteor.setTimeout(\\n      _.bind(self._heartbeatIntervalFired, self),\\n      self.heartbeatInterval\\n    );\\n  },\\n\\n  _startHeartbeatTimeoutTimer: function () {\\n    var self = this;\\n    self._heartbeatTimeoutHandle = Meteor.setTimeout(\\n      _.bind(self._heartbeatTimeoutFired, self),\\n      self.heartbeatTimeout\\n    );\\n  },\\n\\n  _clearHeartbeatIntervalTimer: function () {\\n    var self = this;\\n    if (self._heartbeatIntervalHandle) {\\n      Meteor.clearTimeout(self._heartbeatIntervalHandle);\\n      self._heartbeatIntervalHandle = null;\\n    }\\n  },\\n\\n  _clearHeartbeatTimeoutTimer: function () {\\n    var self = this;\\n    if (self._heartbeatTimeoutHandle) {\\n      Meteor.clearTimeout(self._heartbeatTimeoutHandle);\\n      self._heartbeatTimeoutHandle = null;\\n    }\\n  },\\n\\n  // The heartbeat interval timer is fired when we should send a ping.\\n  _heartbeatIntervalFired: function () {\\n    var self = this;\\n    self._heartbeatIntervalHandle = null;\\n    self._sendPing();\\n    // Wait for a pong.\\n    self._startHeartbeatTimeoutTimer();\\n  },\\n\\n  // The heartbeat timeout timer is fired when we sent a ping, but we\\n  // timed out waiting for the pong.\\n  _heartbeatTimeoutFired: function () {\\n    var self = this;\\n    self._heartbeatTimeoutHandle = null;\\n    self._onTimeout();\\n  },\\n\\n  pingReceived: function () {\\n    var self = this;\\n    // We know the connection is alive if we receive a ping, so we\\n    // don't need to send a ping ourselves.  Reset the interval timer.\\n    if (self._heartbeatIntervalHandle) {\\n      self._clearHeartbeatIntervalTimer();\\n      self._startHeartbeatIntervalTimer();\\n    }\\n  },\\n\\n  pongReceived: function () {\\n    var self = this;\\n\\n    // Receiving a pong means we won't timeout, so clear the timeout\\n    // timer and start the interval again.\\n    if (self._heartbeatTimeoutHandle) {\\n      self._clearHeartbeatTimeoutTimer();\\n      self._startHeartbeatIntervalTimer();\\n    }\\n  }\\n});\\n\",\"// All the supported versions (for both the client and server)\\n// These must be in order of preference; most favored-first\\nSUPPORTED_DDP_VERSIONS = [ '1', 'pre2', 'pre1' ];\\n\\nLivedataTest.SUPPORTED_DDP_VERSIONS = SUPPORTED_DDP_VERSIONS;\\n\\n// Instance name is this because it is usually referred to as this inside a\\n// method definition\\n/**\\n * @summary The state for a single invocation of a method, referenced by this\\n * inside a method definition.\\n * @param {Object} options\\n * @instanceName this\\n */\\nMethodInvocation = function (options) {\\n  var self = this;\\n\\n  // true if we're running not the actual method, but a stub (that is,\\n  // if we're on a client (which may be a browser, or in the future a\\n  // server connecting to another server) and presently running a\\n  // simulation of a server-side method for latency compensation\\n  // purposes). not currently true except in a client such as a browser,\\n  // since there's usually no point in running stubs unless you have a\\n  // zero-latency connection to the user.\\n\\n  /**\\n   * @summary Access inside a method invocation.  Boolean value, true if this invocation is a stub.\\n   * @locus Anywhere\\n   * @name  isSimulation\\n   * @memberOf MethodInvocation\\n   * @instance\\n   * @type {Boolean}\\n   */\\n  this.isSimulation = options.isSimulation;\\n\\n  // call this function to allow other method invocations (from the\\n  // same client) to continue running without waiting for this one to\\n  // complete.\\n  this._unblock = options.unblock || function () {};\\n  this._calledUnblock = false;\\n\\n  // current user id\\n\\n  /**\\n   * @summary The id of the user that made this method call, or `null` if no user was logged in.\\n   * @locus Anywhere\\n   * @name  userId\\n   * @memberOf MethodInvocation\\n   * @instance\\n   */\\n  this.userId = options.userId;\\n\\n  // sets current user id in all appropriate server contexts and\\n  // reruns subscriptions\\n  this._setUserId = options.setUserId || function () {};\\n\\n  // On the server, the connection this method call came in on.\\n\\n  /**\\n   * @summary Access inside a method invocation. The [connection](#meteor_onconnection) that this method was received on. `null` if the method is not associated with a connection, eg. a server initiated method call.\\n   * @locus Server\\n   * @name  connection\\n   * @memberOf MethodInvocation\\n   * @instance\\n   */\\n  this.connection = options.connection;\\n\\n  // The seed for randomStream value generation\\n  this.randomSeed = options.randomSeed;\\n\\n  // This is set by RandomStream.get; and holds the random stream state\\n  this.randomStream = null;\\n};\\n\\n_.extend(MethodInvocation.prototype, {\\n  /**\\n   * @summary Call inside a method invocation.  Allow subsequent method from this client to begin running in a new fiber.\\n   * @locus Server\\n   * @memberOf MethodInvocation\\n   * @instance\\n   */\\n  unblock: function () {\\n    var self = this;\\n    self._calledUnblock = true;\\n    self._unblock();\\n  },\\n\\n  /**\\n   * @summary Set the logged in user.\\n   * @locus Server\\n   * @memberOf MethodInvocation\\n   * @instance\\n   * @param {String | null} userId The value that should be returned by `userId` on this connection.\\n   */\\n  setUserId: function(userId) {\\n    var self = this;\\n    if (self._calledUnblock)\\n      throw new Error(\\\"Can't call setUserId in a method after calling unblock\\\");\\n    self.userId = userId;\\n    self._setUserId(userId);\\n  }\\n});\\n\\nparseDDP = function (stringMessage) {\\n  try {\\n    var msg = JSON.parse(stringMessage);\\n  } catch (e) {\\n    Meteor._debug(\\\"Discarding message with invalid JSON\\\", stringMessage);\\n    return null;\\n  }\\n  // DDP messages must be objects.\\n  if (msg === null || typeof msg !== 'object') {\\n    Meteor._debug(\\\"Discarding non-object DDP message\\\", stringMessage);\\n    return null;\\n  }\\n\\n  // massage msg to get it into \\\"abstract ddp\\\" rather than \\\"wire ddp\\\" format.\\n\\n  // switch between \\\"cleared\\\" rep of unsetting fields and \\\"undefined\\\"\\n  // rep of same\\n  if (_.has(msg, 'cleared')) {\\n    if (!_.has(msg, 'fields'))\\n      msg.fields = {};\\n    _.each(msg.cleared, function (clearKey) {\\n      msg.fields[clearKey] = undefined;\\n    });\\n    delete msg.cleared;\\n  }\\n\\n  _.each(['fields', 'params', 'result'], function (field) {\\n    if (_.has(msg, field))\\n      msg[field] = EJSON._adjustTypesFromJSONValue(msg[field]);\\n  });\\n\\n  return msg;\\n};\\n\\nstringifyDDP = function (msg) {\\n  var copy = EJSON.clone(msg);\\n  // swizzle 'changed' messages from 'fields undefined' rep to 'fields\\n  // and cleared' rep\\n  if (_.has(msg, 'fields')) {\\n    var cleared = [];\\n    _.each(msg.fields, function (value, key) {\\n      if (value === undefined) {\\n        cleared.push(key);\\n        delete copy.fields[key];\\n      }\\n    });\\n    if (!_.isEmpty(cleared))\\n      copy.cleared = cleared;\\n    if (_.isEmpty(copy.fields))\\n      delete copy.fields;\\n  }\\n  // adjust types to basic\\n  _.each(['fields', 'params', 'result'], function (field) {\\n    if (_.has(copy, field))\\n      copy[field] = EJSON._adjustTypesToJSONValue(copy[field]);\\n  });\\n  if (msg.id && typeof msg.id !== 'string') {\\n    throw new Error(\\\"Message id is not a string\\\");\\n  }\\n  return JSON.stringify(copy);\\n};\\n\\n// This is private but it's used in a few places. accounts-base uses\\n// it to get the current user. accounts-password uses it to stash SRP\\n// state in the DDP session. Meteor.setTimeout and friends clear\\n// it. We can probably find a better way to factor this.\\nDDP._CurrentInvocation = new Meteor.EnvironmentVariable;\\n\",\"// RandomStream allows for generation of pseudo-random values, from a seed.\\n//\\n// We use this for consistent 'random' numbers across the client and server.\\n// We want to generate probably-unique IDs on the client, and we ideally want\\n// the server to generate the same IDs when it executes the method.\\n//\\n// For generated values to be the same, we must seed ourselves the same way,\\n// and we must keep track of the current state of our pseudo-random generators.\\n// We call this state the scope. By default, we use the current DDP method\\n// invocation as our scope.  DDP now allows the client to specify a randomSeed.\\n// If a randomSeed is provided it will be used to seed our random sequences.\\n// In this way, client and server method calls will generate the same values.\\n//\\n// We expose multiple named streams; each stream is independent\\n// and is seeded differently (but predictably from the name).\\n// By using multiple streams, we support reordering of requests,\\n// as long as they occur on different streams.\\n//\\n// @param options {Optional Object}\\n//   seed: Array or value - Seed value(s) for the generator.\\n//                          If an array, will be used as-is\\n//                          If a value, will be converted to a single-value array\\n//                          If omitted, a random array will be used as the seed.\\nRandomStream = function (options) {\\n  var self = this;\\n\\n  this.seed = [].concat(options.seed || randomToken());\\n\\n  this.sequences = {};\\n};\\n\\n// Returns a random string of sufficient length for a random seed.\\n// This is a placeholder function; a similar function is planned\\n// for Random itself; when that is added we should remove this function,\\n// and call Random's randomToken instead.\\nfunction randomToken() {\\n  return Random.hexString(20);\\n};\\n\\n// Returns the random stream with the specified name, in the specified scope.\\n// If scope is null (or otherwise falsey) then we will use Random, which will\\n// give us as random numbers as possible, but won't produce the same\\n// values across client and server.\\n// However, scope will normally be the current DDP method invocation, so\\n// we'll use the stream with the specified name, and we should get consistent\\n// values on the client and server sides of a method call.\\nRandomStream.get = function (scope, name) {\\n  if (!name) {\\n    name = \\\"default\\\";\\n  }\\n  if (!scope) {\\n    // There was no scope passed in;\\n    // the sequence won't actually be reproducible.\\n    return Random;\\n  }\\n  var randomStream = scope.randomStream;\\n  if (!randomStream) {\\n    scope.randomStream = randomStream = new RandomStream({\\n      seed: scope.randomSeed\\n    });\\n  }\\n  return randomStream._sequence(name);\\n};\\n\\n// Returns the named sequence of pseudo-random values.\\n// The scope will be DDP._CurrentInvocation.get(), so the stream will produce\\n// consistent values for method calls on the client and server.\\nDDP.randomStream = function (name) {\\n  var scope = DDP._CurrentInvocation.get();\\n  return RandomStream.get(scope, name);\\n};\\n\\n// Creates a randomSeed for passing to a method call.\\n// Note that we take enclosing as an argument,\\n// though we expect it to be DDP._CurrentInvocation.get()\\n// However, we often evaluate makeRpcSeed lazily, and thus the relevant\\n// invocation may not be the one currently in scope.\\n// If enclosing is null, we'll use Random and values won't be repeatable.\\nmakeRpcSeed = function (enclosing, methodName) {\\n  var stream = RandomStream.get(enclosing, '/rpc/' + methodName);\\n  return stream.hexString(20);\\n};\\n\\n_.extend(RandomStream.prototype, {\\n  // Get a random sequence with the specified name, creating it if does not exist.\\n  // New sequences are seeded with the seed concatenated with the name.\\n  // By passing a seed into Random.create, we use the Alea generator.\\n  _sequence: function (name) {\\n    var self = this;\\n\\n    var sequence = self.sequences[name] || null;\\n    if (sequence === null) {\\n      var sequenceSeed = self.seed.concat(name);\\n      for (var i = 0; i < sequenceSeed.length; i++) {\\n        if (_.isFunction(sequenceSeed[i])) {\\n          sequenceSeed[i] = sequenceSeed[i]();\\n        }\\n      }\\n      self.sequences[name] = sequence = Random.createWithSeeds.apply(null, sequenceSeed);\\n    }\\n    return sequence;\\n  }\\n});\\n\",\"if (Meteor.isServer) {\\n  var path = Npm.require('path');\\n  var Fiber = Npm.require('fibers');\\n  var Future = Npm.require(path.join('fibers', 'future'));\\n}\\n\\n// @param url {String|Object} URL to Meteor app,\\n//   or an object as a test hook (see code)\\n// Options:\\n//   reloadWithOutstanding: is it OK to reload if there are outstanding methods?\\n//   headers: extra headers to send on the websockets connection, for\\n//     server-to-server DDP only\\n//   _sockjsOptions: Specifies options to pass through to the sockjs client\\n//   onDDPNegotiationVersionFailure: callback when version negotiation fails.\\n//\\n// XXX There should be a way to destroy a DDP connection, causing all\\n// outstanding method calls to fail.\\n//\\n// XXX Our current way of handling failure and reconnection is great\\n// for an app (where we want to tolerate being disconnected as an\\n// expect state, and keep trying forever to reconnect) but cumbersome\\n// for something like a command line tool that wants to make a\\n// connection, call a method, and print an error if connection\\n// fails. We should have better usability in the latter case (while\\n// still transparently reconnecting if it's just a transient failure\\n// or the server migrating us).\\nvar Connection = function (url, options) {\\n  var self = this;\\n  options = _.extend({\\n    onConnected: function () {},\\n    onDDPVersionNegotiationFailure: function (description) {\\n      Meteor._debug(description);\\n    },\\n    heartbeatInterval: 35000,\\n    heartbeatTimeout: 15000,\\n    // These options are only for testing.\\n    reloadWithOutstanding: false,\\n    supportedDDPVersions: SUPPORTED_DDP_VERSIONS,\\n    retry: true,\\n    respondToPings: true\\n  }, options);\\n\\n  // If set, called when we reconnect, queuing method calls _before_ the\\n  // existing outstanding ones. This is the only data member that is part of the\\n  // public API!\\n  self.onReconnect = null;\\n\\n  // as a test hook, allow passing a stream instead of a url.\\n  if (typeof url === \\\"object\\\") {\\n    self._stream = url;\\n  } else {\\n    self._stream = new LivedataTest.ClientStream(url, {\\n      retry: options.retry,\\n      headers: options.headers,\\n      _sockjsOptions: options._sockjsOptions,\\n      // Used to keep some tests quiet, or for other cases in which\\n      // the right thing to do with connection errors is to silently\\n      // fail (e.g. sending package usage stats). At some point we\\n      // should have a real API for handling client-stream-level\\n      // errors.\\n      _dontPrintErrors: options._dontPrintErrors,\\n      connectTimeoutMs: options.connectTimeoutMs\\n    });\\n  }\\n\\n  self._lastSessionId = null;\\n  self._versionSuggestion = null;  // The last proposed DDP version.\\n  self._version = null;   // The DDP version agreed on by client and server.\\n  self._stores = {}; // name -> object with methods\\n  self._methodHandlers = {}; // name -> func\\n  self._nextMethodId = 1;\\n  self._supportedDDPVersions = options.supportedDDPVersions;\\n\\n  self._heartbeatInterval = options.heartbeatInterval;\\n  self._heartbeatTimeout = options.heartbeatTimeout;\\n\\n  // Tracks methods which the user has tried to call but which have not yet\\n  // called their user callback (ie, they are waiting on their result or for all\\n  // of their writes to be written to the local cache). Map from method ID to\\n  // MethodInvoker object.\\n  self._methodInvokers = {};\\n\\n  // Tracks methods which the user has called but whose result messages have not\\n  // arrived yet.\\n  //\\n  // _outstandingMethodBlocks is an array of blocks of methods. Each block\\n  // represents a set of methods that can run at the same time. The first block\\n  // represents the methods which are currently in flight; subsequent blocks\\n  // must wait for previous blocks to be fully finished before they can be sent\\n  // to the server.\\n  //\\n  // Each block is an object with the following fields:\\n  // - methods: a list of MethodInvoker objects\\n  // - wait: a boolean; if true, this block had a single method invoked with\\n  //         the \\\"wait\\\" option\\n  //\\n  // There will never be adjacent blocks with wait=false, because the only thing\\n  // that makes methods need to be serialized is a wait method.\\n  //\\n  // Methods are removed from the first block when their \\\"result\\\" is\\n  // received. The entire first block is only removed when all of the in-flight\\n  // methods have received their results (so the \\\"methods\\\" list is empty) *AND*\\n  // all of the data written by those methods are visible in the local cache. So\\n  // it is possible for the first block's methods list to be empty, if we are\\n  // still waiting for some objects to quiesce.\\n  //\\n  // Example:\\n  //  _outstandingMethodBlocks = [\\n  //    {wait: false, methods: []},\\n  //    {wait: true, methods: [<MethodInvoker for 'login'>]},\\n  //    {wait: false, methods: [<MethodInvoker for 'foo'>,\\n  //                            <MethodInvoker for 'bar'>]}]\\n  // This means that there were some methods which were sent to the server and\\n  // which have returned their results, but some of the data written by\\n  // the methods may not be visible in the local cache. Once all that data is\\n  // visible, we will send a 'login' method. Once the login method has returned\\n  // and all the data is visible (including re-running subs if userId changes),\\n  // we will send the 'foo' and 'bar' methods in parallel.\\n  self._outstandingMethodBlocks = [];\\n\\n  // method ID -> array of objects with keys 'collection' and 'id', listing\\n  // documents written by a given method's stub. keys are associated with\\n  // methods whose stub wrote at least one document, and whose data-done message\\n  // has not yet been received.\\n  self._documentsWrittenByStub = {};\\n  // collection -> IdMap of \\\"server document\\\" object. A \\\"server document\\\" has:\\n  // - \\\"document\\\": the version of the document according the\\n  //   server (ie, the snapshot before a stub wrote it, amended by any changes\\n  //   received from the server)\\n  //   It is undefined if we think the document does not exist\\n  // - \\\"writtenByStubs\\\": a set of method IDs whose stubs wrote to the document\\n  //   whose \\\"data done\\\" messages have not yet been processed\\n  self._serverDocuments = {};\\n\\n  // Array of callbacks to be called after the next update of the local\\n  // cache. Used for:\\n  //  - Calling methodInvoker.dataVisible and sub ready callbacks after\\n  //    the relevant data is flushed.\\n  //  - Invoking the callbacks of \\\"half-finished\\\" methods after reconnect\\n  //    quiescence. Specifically, methods whose result was received over the old\\n  //    connection (so we don't re-send it) but whose data had not been made\\n  //    visible.\\n  self._afterUpdateCallbacks = [];\\n\\n  // In two contexts, we buffer all incoming data messages and then process them\\n  // all at once in a single update:\\n  //   - During reconnect, we buffer all data messages until all subs that had\\n  //     been ready before reconnect are ready again, and all methods that are\\n  //     active have returned their \\\"data done message\\\"; then\\n  //   - During the execution of a \\\"wait\\\" method, we buffer all data messages\\n  //     until the wait method gets its \\\"data done\\\" message. (If the wait method\\n  //     occurs during reconnect, it doesn't get any special handling.)\\n  // all data messages are processed in one update.\\n  //\\n  // The following fields are used for this \\\"quiescence\\\" process.\\n\\n  // This buffers the messages that aren't being processed yet.\\n  self._messagesBufferedUntilQuiescence = [];\\n  // Map from method ID -> true. Methods are removed from this when their\\n  // \\\"data done\\\" message is received, and we will not quiesce until it is\\n  // empty.\\n  self._methodsBlockingQuiescence = {};\\n  // map from sub ID -> true for subs that were ready (ie, called the sub\\n  // ready callback) before reconnect but haven't become ready again yet\\n  self._subsBeingRevived = {}; // map from sub._id -> true\\n  // if true, the next data update should reset all stores. (set during\\n  // reconnect.)\\n  self._resetStores = false;\\n\\n  // name -> array of updates for (yet to be created) collections\\n  self._updatesForUnknownStores = {};\\n  // if we're blocking a migration, the retry func\\n  self._retryMigrate = null;\\n\\n  // metadata for subscriptions.  Map from sub ID to object with keys:\\n  //   - id\\n  //   - name\\n  //   - params\\n  //   - inactive (if true, will be cleaned up if not reused in re-run)\\n  //   - ready (has the 'ready' message been received?)\\n  //   - readyCallback (an optional callback to call when ready)\\n  //   - errorCallback (an optional callback to call if the sub terminates with\\n  //                    an error, XXX COMPAT WITH 1.0.3.1)\\n  //   - stopCallback (an optional callback to call when the sub terminates\\n  //     for any reason, with an error argument if an error triggered the stop)\\n  self._subscriptions = {};\\n\\n  // Reactive userId.\\n  self._userId = null;\\n  self._userIdDeps = new Tracker.Dependency;\\n\\n  // Block auto-reload while we're waiting for method responses.\\n  if (Meteor.isClient && Package.reload && !options.reloadWithOutstanding) {\\n    Package.reload.Reload._onMigrate(function (retry) {\\n      if (!self._readyToMigrate()) {\\n        if (self._retryMigrate)\\n          throw new Error(\\\"Two migrations in progress?\\\");\\n        self._retryMigrate = retry;\\n        return false;\\n      } else {\\n        return [true];\\n      }\\n    });\\n  }\\n\\n  var onMessage = function (raw_msg) {\\n    try {\\n      var msg = parseDDP(raw_msg);\\n    } catch (e) {\\n      Meteor._debug(\\\"Exception while parsing DDP\\\", e);\\n      return;\\n    }\\n\\n    if (msg === null || !msg.msg) {\\n      // XXX COMPAT WITH 0.6.6. ignore the old welcome message for back\\n      // compat.  Remove this 'if' once the server stops sending welcome\\n      // messages (stream_server.js).\\n      if (! (msg && msg.server_id))\\n        Meteor._debug(\\\"discarding invalid livedata message\\\", msg);\\n      return;\\n    }\\n\\n    if (msg.msg === 'connected') {\\n      self._version = self._versionSuggestion;\\n      self._livedata_connected(msg);\\n      options.onConnected();\\n    }\\n    else if (msg.msg == 'failed') {\\n      if (_.contains(self._supportedDDPVersions, msg.version)) {\\n        self._versionSuggestion = msg.version;\\n        self._stream.reconnect({_force: true});\\n      } else {\\n        var description =\\n              \\\"DDP version negotiation failed; server requested version \\\" + msg.version;\\n        self._stream.disconnect({_permanent: true, _error: description});\\n        options.onDDPVersionNegotiationFailure(description);\\n      }\\n    }\\n    else if (msg.msg === 'ping') {\\n      if (options.respondToPings)\\n        self._send({msg: \\\"pong\\\", id: msg.id});\\n      if (self._heartbeat)\\n        self._heartbeat.pingReceived();\\n    }\\n    else if (msg.msg === 'pong') {\\n      if (self._heartbeat) {\\n        self._heartbeat.pongReceived();\\n      }\\n    }\\n    else if (_.include(['added', 'changed', 'removed', 'ready', 'updated'], msg.msg))\\n      self._livedata_data(msg);\\n    else if (msg.msg === 'nosub')\\n      self._livedata_nosub(msg);\\n    else if (msg.msg === 'result')\\n      self._livedata_result(msg);\\n    else if (msg.msg === 'error')\\n      self._livedata_error(msg);\\n    else\\n      Meteor._debug(\\\"discarding unknown livedata message type\\\", msg);\\n  };\\n\\n  var onReset = function () {\\n    // Send a connect message at the beginning of the stream.\\n    // NOTE: reset is called even on the first connection, so this is\\n    // the only place we send this message.\\n    var msg = {msg: 'connect'};\\n    if (self._lastSessionId)\\n      msg.session = self._lastSessionId;\\n    msg.version = self._versionSuggestion || self._supportedDDPVersions[0];\\n    self._versionSuggestion = msg.version;\\n    msg.support = self._supportedDDPVersions;\\n    self._send(msg);\\n\\n    // Now, to minimize setup latency, go ahead and blast out all of\\n    // our pending methods ands subscriptions before we've even taken\\n    // the necessary RTT to know if we successfully reconnected. (1)\\n    // They're supposed to be idempotent; (2) even if we did\\n    // reconnect, we're not sure what messages might have gotten lost\\n    // (in either direction) since we were disconnected (TCP being\\n    // sloppy about that.)\\n\\n    // If the current block of methods all got their results (but didn't all get\\n    // their data visible), discard the empty block now.\\n    if (! _.isEmpty(self._outstandingMethodBlocks) &&\\n        _.isEmpty(self._outstandingMethodBlocks[0].methods)) {\\n      self._outstandingMethodBlocks.shift();\\n    }\\n\\n    // Mark all messages as unsent, they have not yet been sent on this\\n    // connection.\\n    _.each(self._methodInvokers, function (m) {\\n      m.sentMessage = false;\\n    });\\n\\n    // If an `onReconnect` handler is set, call it first. Go through\\n    // some hoops to ensure that methods that are called from within\\n    // `onReconnect` get executed _before_ ones that were originally\\n    // outstanding (since `onReconnect` is used to re-establish auth\\n    // certificates)\\n    if (self.onReconnect)\\n      self._callOnReconnectAndSendAppropriateOutstandingMethods();\\n    else\\n      self._sendOutstandingMethods();\\n\\n    // add new subscriptions at the end. this way they take effect after\\n    // the handlers and we don't see flicker.\\n    _.each(self._subscriptions, function (sub, id) {\\n      self._send({\\n        msg: 'sub',\\n        id: id,\\n        name: sub.name,\\n        params: sub.params\\n      });\\n    });\\n  };\\n\\n  var onDisconnect = function () {\\n    if (self._heartbeat) {\\n      self._heartbeat.stop();\\n      self._heartbeat = null;\\n    }\\n  };\\n\\n  if (Meteor.isServer) {\\n    self._stream.on('message', Meteor.bindEnvironment(onMessage, Meteor._debug));\\n    self._stream.on('reset', Meteor.bindEnvironment(onReset, Meteor._debug));\\n    self._stream.on('disconnect', Meteor.bindEnvironment(onDisconnect, Meteor._debug));\\n  } else {\\n    self._stream.on('message', onMessage);\\n    self._stream.on('reset', onReset);\\n    self._stream.on('disconnect', onDisconnect);\\n  }\\n};\\n\\n// A MethodInvoker manages sending a method to the server and calling the user's\\n// callbacks. On construction, it registers itself in the connection's\\n// _methodInvokers map; it removes itself once the method is fully finished and\\n// the callback is invoked. This occurs when it has both received a result,\\n// and the data written by it is fully visible.\\nvar MethodInvoker = function (options) {\\n  var self = this;\\n\\n  // Public (within this file) fields.\\n  self.methodId = options.methodId;\\n  self.sentMessage = false;\\n\\n  self._callback = options.callback;\\n  self._connection = options.connection;\\n  self._message = options.message;\\n  self._onResultReceived = options.onResultReceived || function () {};\\n  self._wait = options.wait;\\n  self._methodResult = null;\\n  self._dataVisible = false;\\n\\n  // Register with the connection.\\n  self._connection._methodInvokers[self.methodId] = self;\\n};\\n_.extend(MethodInvoker.prototype, {\\n  // Sends the method message to the server. May be called additional times if\\n  // we lose the connection and reconnect before receiving a result.\\n  sendMessage: function () {\\n    var self = this;\\n    // This function is called before sending a method (including resending on\\n    // reconnect). We should only (re)send methods where we don't already have a\\n    // result!\\n    if (self.gotResult())\\n      throw new Error(\\\"sendingMethod is called on method with result\\\");\\n\\n    // If we're re-sending it, it doesn't matter if data was written the first\\n    // time.\\n    self._dataVisible = false;\\n\\n    self.sentMessage = true;\\n\\n    // If this is a wait method, make all data messages be buffered until it is\\n    // done.\\n    if (self._wait)\\n      self._connection._methodsBlockingQuiescence[self.methodId] = true;\\n\\n    // Actually send the message.\\n    self._connection._send(self._message);\\n  },\\n  // Invoke the callback, if we have both a result and know that all data has\\n  // been written to the local cache.\\n  _maybeInvokeCallback: function () {\\n    var self = this;\\n    if (self._methodResult && self._dataVisible) {\\n      // Call the callback. (This won't throw: the callback was wrapped with\\n      // bindEnvironment.)\\n      self._callback(self._methodResult[0], self._methodResult[1]);\\n\\n      // Forget about this method.\\n      delete self._connection._methodInvokers[self.methodId];\\n\\n      // Let the connection know that this method is finished, so it can try to\\n      // move on to the next block of methods.\\n      self._connection._outstandingMethodFinished();\\n    }\\n  },\\n  // Call with the result of the method from the server. Only may be called\\n  // once; once it is called, you should not call sendMessage again.\\n  // If the user provided an onResultReceived callback, call it immediately.\\n  // Then invoke the main callback if data is also visible.\\n  receiveResult: function (err, result) {\\n    var self = this;\\n    if (self.gotResult())\\n      throw new Error(\\\"Methods should only receive results once\\\");\\n    self._methodResult = [err, result];\\n    self._onResultReceived(err, result);\\n    self._maybeInvokeCallback();\\n  },\\n  // Call this when all data written by the method is visible. This means that\\n  // the method has returns its \\\"data is done\\\" message *AND* all server\\n  // documents that are buffered at that time have been written to the local\\n  // cache. Invokes the main callback if the result has been received.\\n  dataVisible: function () {\\n    var self = this;\\n    self._dataVisible = true;\\n    self._maybeInvokeCallback();\\n  },\\n  // True if receiveResult has been called.\\n  gotResult: function () {\\n    var self = this;\\n    return !!self._methodResult;\\n  }\\n});\\n\\n_.extend(Connection.prototype, {\\n  // 'name' is the name of the data on the wire that should go in the\\n  // store. 'wrappedStore' should be an object with methods beginUpdate, update,\\n  // endUpdate, saveOriginals, retrieveOriginals. see Collection for an example.\\n  registerStore: function (name, wrappedStore) {\\n    var self = this;\\n\\n    if (name in self._stores)\\n      return false;\\n\\n    // Wrap the input object in an object which makes any store method not\\n    // implemented by 'store' into a no-op.\\n    var store = {};\\n    _.each(['update', 'beginUpdate', 'endUpdate', 'saveOriginals',\\n            'retrieveOriginals'], function (method) {\\n              store[method] = function () {\\n                return (wrappedStore[method]\\n                        ? wrappedStore[method].apply(wrappedStore, arguments)\\n                        : undefined);\\n              };\\n            });\\n\\n    self._stores[name] = store;\\n\\n    var queued = self._updatesForUnknownStores[name];\\n    if (queued) {\\n      store.beginUpdate(queued.length, false);\\n      _.each(queued, function (msg) {\\n        store.update(msg);\\n      });\\n      store.endUpdate();\\n      delete self._updatesForUnknownStores[name];\\n    }\\n\\n    return true;\\n  },\\n\\n  /**\\n   * @memberOf Meteor\\n   * @summary Subscribe to a record set.  Returns a handle that provides\\n   * `stop()` and `ready()` methods.\\n   * @locus Client\\n   * @param {String} name Name of the subscription.  Matches the name of the\\n   * server's `publish()` call.\\n   * @param {Any} [arg1,arg2...] Optional arguments passed to publisher\\n   * function on server.\\n   * @param {Function|Object} [callbacks] Optional. May include `onStop`\\n   * and `onReady` callbacks. If there is an error, it is passed as an\\n   * argument to `onStop`. If a function is passed instead of an object, it\\n   * is interpreted as an `onReady` callback.\\n   */\\n  subscribe: function (name /* .. [arguments] .. (callback|callbacks) */) {\\n    var self = this;\\n\\n    var params = Array.prototype.slice.call(arguments, 1);\\n    var callbacks = {};\\n    if (params.length) {\\n      var lastParam = params[params.length - 1];\\n      if (_.isFunction(lastParam)) {\\n        callbacks.onReady = params.pop();\\n      } else if (lastParam &&\\n        // XXX COMPAT WITH 1.0.3.1 onError used to exist, but now we use\\n        // onStop with an error callback instead.\\n        _.any([lastParam.onReady, lastParam.onError, lastParam.onStop],\\n          _.isFunction)) {\\n        callbacks = params.pop();\\n      }\\n    }\\n\\n    // Is there an existing sub with the same name and param, run in an\\n    // invalidated Computation? This will happen if we are rerunning an\\n    // existing computation.\\n    //\\n    // For example, consider a rerun of:\\n    //\\n    //     Tracker.autorun(function () {\\n    //       Meteor.subscribe(\\\"foo\\\", Session.get(\\\"foo\\\"));\\n    //       Meteor.subscribe(\\\"bar\\\", Session.get(\\\"bar\\\"));\\n    //     });\\n    //\\n    // If \\\"foo\\\" has changed but \\\"bar\\\" has not, we will match the \\\"bar\\\"\\n    // subcribe to an existing inactive subscription in order to not\\n    // unsub and resub the subscription unnecessarily.\\n    //\\n    // We only look for one such sub; if there are N apparently-identical subs\\n    // being invalidated, we will require N matching subscribe calls to keep\\n    // them all active.\\n    var existing = _.find(self._subscriptions, function (sub) {\\n      return sub.inactive && sub.name === name &&\\n        EJSON.equals(sub.params, params);\\n    });\\n\\n    var id;\\n    if (existing) {\\n      id = existing.id;\\n      existing.inactive = false; // reactivate\\n\\n      if (callbacks.onReady) {\\n        // If the sub is not already ready, replace any ready callback with the\\n        // one provided now. (It's not really clear what users would expect for\\n        // an onReady callback inside an autorun; the semantics we provide is\\n        // that at the time the sub first becomes ready, we call the last\\n        // onReady callback provided, if any.)\\n        if (!existing.ready)\\n          existing.readyCallback = callbacks.onReady;\\n      }\\n\\n      // XXX COMPAT WITH 1.0.3.1 we used to have onError but now we call\\n      // onStop with an optional error argument\\n      if (callbacks.onError) {\\n        // Replace existing callback if any, so that errors aren't\\n        // double-reported.\\n        existing.errorCallback = callbacks.onError;\\n      }\\n\\n      if (callbacks.onStop) {\\n        existing.stopCallback = callbacks.onStop;\\n      }\\n    } else {\\n      // New sub! Generate an id, save it locally, and send message.\\n      id = Random.id();\\n      self._subscriptions[id] = {\\n        id: id,\\n        name: name,\\n        params: EJSON.clone(params),\\n        inactive: false,\\n        ready: false,\\n        readyDeps: new Tracker.Dependency,\\n        readyCallback: callbacks.onReady,\\n        // XXX COMPAT WITH 1.0.3.1 #errorCallback\\n        errorCallback: callbacks.onError,\\n        stopCallback: callbacks.onStop,\\n        connection: self,\\n        remove: function() {\\n          delete this.connection._subscriptions[this.id];\\n          this.ready && this.readyDeps.changed();\\n        },\\n        stop: function() {\\n          this.connection._send({msg: 'unsub', id: id});\\n          this.remove();\\n\\n          if (callbacks.onStop) {\\n            callbacks.onStop();\\n          }\\n        }\\n      };\\n      self._send({msg: 'sub', id: id, name: name, params: params});\\n    }\\n\\n    // return a handle to the application.\\n    var handle = {\\n      stop: function () {\\n        if (!_.has(self._subscriptions, id))\\n          return;\\n\\n        self._subscriptions[id].stop();\\n      },\\n      ready: function () {\\n        // return false if we've unsubscribed.\\n        if (!_.has(self._subscriptions, id))\\n          return false;\\n        var record = self._subscriptions[id];\\n        record.readyDeps.depend();\\n        return record.ready;\\n      },\\n      subscriptionId: id\\n    };\\n\\n    if (Tracker.active) {\\n      // We're in a reactive computation, so we'd like to unsubscribe when the\\n      // computation is invalidated... but not if the rerun just re-subscribes\\n      // to the same subscription!  When a rerun happens, we use onInvalidate\\n      // as a change to mark the subscription \\\"inactive\\\" so that it can\\n      // be reused from the rerun.  If it isn't reused, it's killed from\\n      // an afterFlush.\\n      Tracker.onInvalidate(function (c) {\\n        if (_.has(self._subscriptions, id))\\n          self._subscriptions[id].inactive = true;\\n\\n        Tracker.afterFlush(function () {\\n          if (_.has(self._subscriptions, id) &&\\n              self._subscriptions[id].inactive)\\n            handle.stop();\\n        });\\n      });\\n    }\\n\\n    return handle;\\n  },\\n\\n  // options:\\n  // - onLateError {Function(error)} called if an error was received after the ready event.\\n  //     (errors received before ready cause an error to be thrown)\\n  _subscribeAndWait: function (name, args, options) {\\n    var self = this;\\n    var f = new Future();\\n    var ready = false;\\n    var handle;\\n    args = args || [];\\n    args.push({\\n      onReady: function () {\\n        ready = true;\\n        f['return']();\\n      },\\n      onError: function (e) {\\n        if (!ready)\\n          f['throw'](e);\\n        else\\n          options && options.onLateError && options.onLateError(e);\\n      }\\n    });\\n\\n    handle = self.subscribe.apply(self, [name].concat(args));\\n    f.wait();\\n    return handle;\\n  },\\n\\n  methods: function (methods) {\\n    var self = this;\\n    _.each(methods, function (func, name) {\\n      if (self._methodHandlers[name])\\n        throw new Error(\\\"A method named '\\\" + name + \\\"' is already defined\\\");\\n      self._methodHandlers[name] = func;\\n    });\\n  },\\n\\n  /**\\n   * @memberOf Meteor\\n   * @summary Invokes a method passing any number of arguments.\\n   * @locus Anywhere\\n   * @param {String} name Name of method to invoke\\n   * @param {EJSONable} [arg1,arg2...] Optional method arguments\\n   * @param {Function} [asyncCallback] Optional callback, which is called asynchronously with the error or result after the method is complete. If not provided, the method runs synchronously if possible (see below).\\n   */\\n  call: function (name /* .. [arguments] .. callback */) {\\n    // if it's a function, the last argument is the result callback,\\n    // not a parameter to the remote method.\\n    var args = Array.prototype.slice.call(arguments, 1);\\n    if (args.length && typeof args[args.length - 1] === \\\"function\\\")\\n      var callback = args.pop();\\n    return this.apply(name, args, callback);\\n  },\\n\\n  // @param options {Optional Object}\\n  //   wait: Boolean - Should we wait to call this until all current methods\\n  //                   are fully finished, and block subsequent method calls\\n  //                   until this method is fully finished?\\n  //                   (does not affect methods called from within this method)\\n  //   onResultReceived: Function - a callback to call as soon as the method\\n  //                                result is received. the data written by\\n  //                                the method may not yet be in the cache!\\n  //   returnStubValue: Boolean - If true then in cases where we would have\\n  //                              otherwise discarded the stub's return value\\n  //                              and returned undefined, instead we go ahead\\n  //                              and return it.  Specifically, this is any\\n  //                              time other than when (a) we are already\\n  //                              inside a stub or (b) we are in Node and no\\n  //                              callback was provided.  Currently we require\\n  //                              this flag to be explicitly passed to reduce\\n  //                              the likelihood that stub return values will\\n  //                              be confused with server return values; we\\n  //                              may improve this in future.\\n  // @param callback {Optional Function}\\n\\n  /**\\n   * @memberOf Meteor\\n   * @summary Invoke a method passing an array of arguments.\\n   * @locus Anywhere\\n   * @param {String} name Name of method to invoke\\n   * @param {EJSONable[]} args Method arguments\\n   * @param {Object} [options]\\n   * @param {Boolean} options.wait (Client only) If true, don't send this method until all previous method calls have completed, and don't send any subsequent method calls until this one is completed.\\n   * @param {Function} options.onResultReceived (Client only) This callback is invoked with the error or result of the method (just like `asyncCallback`) as soon as the error or result is available. The local cache may not yet reflect the writes performed by the method.\\n   * @param {Function} [asyncCallback] Optional callback; same semantics as in [`Meteor.call`](#meteor_call).\\n   */\\n  apply: function (name, args, options, callback) {\\n    var self = this;\\n\\n    // We were passed 3 arguments. They may be either (name, args, options)\\n    // or (name, args, callback)\\n    if (!callback && typeof options === 'function') {\\n      callback = options;\\n      options = {};\\n    }\\n    options = options || {};\\n\\n    if (callback) {\\n      // XXX would it be better form to do the binding in stream.on,\\n      // or caller, instead of here?\\n      // XXX improve error message (and how we report it)\\n      callback = Meteor.bindEnvironment(\\n        callback,\\n        \\\"delivering result of invoking '\\\" + name + \\\"'\\\"\\n      );\\n    }\\n\\n    // Keep our args safe from mutation (eg if we don't send the message for a\\n    // while because of a wait method).\\n    args = EJSON.clone(args);\\n\\n    // Lazily allocate method ID once we know that it'll be needed.\\n    var methodId = (function () {\\n      var id;\\n      return function () {\\n        if (id === undefined)\\n          id = '' + (self._nextMethodId++);\\n        return id;\\n      };\\n    })();\\n\\n    var enclosing = DDP._CurrentInvocation.get();\\n    var alreadyInSimulation = enclosing && enclosing.isSimulation;\\n\\n    // Lazily generate a randomSeed, only if it is requested by the stub.\\n    // The random streams only have utility if they're used on both the client\\n    // and the server; if the client doesn't generate any 'random' values\\n    // then we don't expect the server to generate any either.\\n    // Less commonly, the server may perform different actions from the client,\\n    // and may in fact generate values where the client did not, but we don't\\n    // have any client-side values to match, so even here we may as well just\\n    // use a random seed on the server.  In that case, we don't pass the\\n    // randomSeed to save bandwidth, and we don't even generate it to save a\\n    // bit of CPU and to avoid consuming entropy.\\n    var randomSeed = null;\\n    var randomSeedGenerator = function () {\\n      if (randomSeed === null) {\\n        randomSeed = makeRpcSeed(enclosing, name);\\n      }\\n      return randomSeed;\\n    };\\n\\n    // Run the stub, if we have one. The stub is supposed to make some\\n    // temporary writes to the database to give the user a smooth experience\\n    // until the actual result of executing the method comes back from the\\n    // server (whereupon the temporary writes to the database will be reversed\\n    // during the beginUpdate/endUpdate process.)\\n    //\\n    // Normally, we ignore the return value of the stub (even if it is an\\n    // exception), in favor of the real return value from the server. The\\n    // exception is if the *caller* is a stub. In that case, we're not going\\n    // to do a RPC, so we use the return value of the stub as our return\\n    // value.\\n\\n    var stub = self._methodHandlers[name];\\n    if (stub) {\\n      var setUserId = function(userId) {\\n        self.setUserId(userId);\\n      };\\n\\n      var invocation = new MethodInvocation({\\n        isSimulation: true,\\n        userId: self.userId(),\\n        setUserId: setUserId,\\n        randomSeed: function () { return randomSeedGenerator(); }\\n      });\\n\\n      if (!alreadyInSimulation)\\n        self._saveOriginals();\\n\\n      try {\\n        // Note that unlike in the corresponding server code, we never audit\\n        // that stubs check() their arguments.\\n        var stubReturnValue = DDP._CurrentInvocation.withValue(invocation, function () {\\n          if (Meteor.isServer) {\\n            // Because saveOriginals and retrieveOriginals aren't reentrant,\\n            // don't allow stubs to yield.\\n            return Meteor._noYieldsAllowed(function () {\\n              // re-clone, so that the stub can't affect our caller's values\\n              return stub.apply(invocation, EJSON.clone(args));\\n            });\\n          } else {\\n            return stub.apply(invocation, EJSON.clone(args));\\n          }\\n        });\\n      }\\n      catch (e) {\\n        var exception = e;\\n      }\\n\\n      if (!alreadyInSimulation)\\n        self._retrieveAndStoreOriginals(methodId());\\n    }\\n\\n    // If we're in a simulation, stop and return the result we have,\\n    // rather than going on to do an RPC. If there was no stub,\\n    // we'll end up returning undefined.\\n    if (alreadyInSimulation) {\\n      if (callback) {\\n        callback(exception, stubReturnValue);\\n        return undefined;\\n      }\\n      if (exception)\\n        throw exception;\\n      return stubReturnValue;\\n    }\\n\\n    // If an exception occurred in a stub, and we're ignoring it\\n    // because we're doing an RPC and want to use what the server\\n    // returns instead, log it so the developer knows.\\n    //\\n    // Tests can set the 'expected' flag on an exception so it won't\\n    // go to log.\\n    if (exception && !exception.expected) {\\n      Meteor._debug(\\\"Exception while simulating the effect of invoking '\\\" +\\n                    name + \\\"'\\\", exception, exception.stack);\\n    }\\n\\n\\n    // At this point we're definitely doing an RPC, and we're going to\\n    // return the value of the RPC to the caller.\\n\\n    // If the caller didn't give a callback, decide what to do.\\n    if (!callback) {\\n      if (Meteor.isClient) {\\n        // On the client, we don't have fibers, so we can't block. The\\n        // only thing we can do is to return undefined and discard the\\n        // result of the RPC. If an error occurred then print the error\\n        // to the console.\\n        callback = function (err) {\\n          err && Meteor._debug(\\\"Error invoking Method '\\\" + name + \\\"':\\\",\\n                               err.message);\\n        };\\n      } else {\\n        // On the server, make the function synchronous. Throw on\\n        // errors, return on success.\\n        var future = new Future;\\n        callback = future.resolver();\\n      }\\n    }\\n    // Send the RPC. Note that on the client, it is important that the\\n    // stub have finished before we send the RPC, so that we know we have\\n    // a complete list of which local documents the stub wrote.\\n    var message = {\\n      msg: 'method',\\n      method: name,\\n      params: args,\\n      id: methodId()\\n    };\\n\\n    // Send the randomSeed only if we used it\\n    if (randomSeed !== null) {\\n      message.randomSeed = randomSeed;\\n    }\\n\\n    var methodInvoker = new MethodInvoker({\\n      methodId: methodId(),\\n      callback: callback,\\n      connection: self,\\n      onResultReceived: options.onResultReceived,\\n      wait: !!options.wait,\\n      message: message\\n    });\\n\\n    if (options.wait) {\\n      // It's a wait method! Wait methods go in their own block.\\n      self._outstandingMethodBlocks.push(\\n        {wait: true, methods: [methodInvoker]});\\n    } else {\\n      // Not a wait method. Start a new block if the previous block was a wait\\n      // block, and add it to the last block of methods.\\n      if (_.isEmpty(self._outstandingMethodBlocks) ||\\n          _.last(self._outstandingMethodBlocks).wait)\\n        self._outstandingMethodBlocks.push({wait: false, methods: []});\\n      _.last(self._outstandingMethodBlocks).methods.push(methodInvoker);\\n    }\\n\\n    // If we added it to the first block, send it out now.\\n    if (self._outstandingMethodBlocks.length === 1)\\n      methodInvoker.sendMessage();\\n\\n    // If we're using the default callback on the server,\\n    // block waiting for the result.\\n    if (future) {\\n      return future.wait();\\n    }\\n    return options.returnStubValue ? stubReturnValue : undefined;\\n  },\\n\\n  // Before calling a method stub, prepare all stores to track changes and allow\\n  // _retrieveAndStoreOriginals to get the original versions of changed\\n  // documents.\\n  _saveOriginals: function () {\\n    var self = this;\\n    _.each(self._stores, function (s) {\\n      s.saveOriginals();\\n    });\\n  },\\n  // Retrieves the original versions of all documents modified by the stub for\\n  // method 'methodId' from all stores and saves them to _serverDocuments (keyed\\n  // by document) and _documentsWrittenByStub (keyed by method ID).\\n  _retrieveAndStoreOriginals: function (methodId) {\\n    var self = this;\\n    if (self._documentsWrittenByStub[methodId])\\n      throw new Error(\\\"Duplicate methodId in _retrieveAndStoreOriginals\\\");\\n\\n    var docsWritten = [];\\n    _.each(self._stores, function (s, collection) {\\n      var originals = s.retrieveOriginals();\\n      // not all stores define retrieveOriginals\\n      if (!originals)\\n        return;\\n      originals.forEach(function (doc, id) {\\n        docsWritten.push({collection: collection, id: id});\\n        if (!_.has(self._serverDocuments, collection))\\n          self._serverDocuments[collection] = new LocalCollection._IdMap;\\n        var serverDoc = self._serverDocuments[collection].setDefault(id, {});\\n        if (serverDoc.writtenByStubs) {\\n          // We're not the first stub to write this doc. Just add our method ID\\n          // to the record.\\n          serverDoc.writtenByStubs[methodId] = true;\\n        } else {\\n          // First stub! Save the original value and our method ID.\\n          serverDoc.document = doc;\\n          serverDoc.flushCallbacks = [];\\n          serverDoc.writtenByStubs = {};\\n          serverDoc.writtenByStubs[methodId] = true;\\n        }\\n      });\\n    });\\n    if (!_.isEmpty(docsWritten)) {\\n      self._documentsWrittenByStub[methodId] = docsWritten;\\n    }\\n  },\\n\\n  // This is very much a private function we use to make the tests\\n  // take up fewer server resources after they complete.\\n  _unsubscribeAll: function () {\\n    var self = this;\\n    _.each(_.clone(self._subscriptions), function (sub, id) {\\n      // Avoid killing the autoupdate subscription so that developers\\n      // still get hot code pushes when writing tests.\\n      //\\n      // XXX it's a hack to encode knowledge about autoupdate here,\\n      // but it doesn't seem worth it yet to have a special API for\\n      // subscriptions to preserve after unit tests.\\n      if (sub.name !== 'meteor_autoupdate_clientVersions') {\\n        self._subscriptions[id].stop();\\n      }\\n    });\\n  },\\n\\n  // Sends the DDP stringification of the given message object\\n  _send: function (obj) {\\n    var self = this;\\n    self._stream.send(stringifyDDP(obj));\\n  },\\n\\n  // We detected via DDP-level heartbeats that we've lost the\\n  // connection.  Unlike `disconnect` or `close`, a lost connection\\n  // will be automatically retried.\\n  _lostConnection: function (error) {\\n    var self = this;\\n    self._stream._lostConnection(error);\\n  },\\n\\n  /**\\n   * @summary Get the current connection status. A reactive data source.\\n   * @locus Client\\n   * @memberOf Meteor\\n   */\\n  status: function (/*passthrough args*/) {\\n    var self = this;\\n    return self._stream.status.apply(self._stream, arguments);\\n  },\\n\\n  /**\\n   * @summary Force an immediate reconnection attempt if the client is not connected to the server.\\n\\n  This method does nothing if the client is already connected.\\n   * @locus Client\\n   * @memberOf Meteor\\n   */\\n  reconnect: function (/*passthrough args*/) {\\n    var self = this;\\n    return self._stream.reconnect.apply(self._stream, arguments);\\n  },\\n\\n  /**\\n   * @summary Disconnect the client from the server.\\n   * @locus Client\\n   * @memberOf Meteor\\n   */\\n  disconnect: function (/*passthrough args*/) {\\n    var self = this;\\n    return self._stream.disconnect.apply(self._stream, arguments);\\n  },\\n\\n  close: function () {\\n    var self = this;\\n    return self._stream.disconnect({_permanent: true});\\n  },\\n\\n  ///\\n  /// Reactive user system\\n  ///\\n  userId: function () {\\n    var self = this;\\n    if (self._userIdDeps)\\n      self._userIdDeps.depend();\\n    return self._userId;\\n  },\\n\\n  setUserId: function (userId) {\\n    var self = this;\\n    // Avoid invalidating dependents if setUserId is called with current value.\\n    if (self._userId === userId)\\n      return;\\n    self._userId = userId;\\n    if (self._userIdDeps)\\n      self._userIdDeps.changed();\\n  },\\n\\n  // Returns true if we are in a state after reconnect of waiting for subs to be\\n  // revived or early methods to finish their data, or we are waiting for a\\n  // \\\"wait\\\" method to finish.\\n  _waitingForQuiescence: function () {\\n    var self = this;\\n    return (! _.isEmpty(self._subsBeingRevived) ||\\n            ! _.isEmpty(self._methodsBlockingQuiescence));\\n  },\\n\\n  // Returns true if any method whose message has been sent to the server has\\n  // not yet invoked its user callback.\\n  _anyMethodsAreOutstanding: function () {\\n    var self = this;\\n    return _.any(_.pluck(self._methodInvokers, 'sentMessage'));\\n  },\\n\\n  _livedata_connected: function (msg) {\\n    var self = this;\\n\\n    if (self._version !== 'pre1' && self._heartbeatInterval !== 0) {\\n      self._heartbeat = new Heartbeat({\\n        heartbeatInterval: self._heartbeatInterval,\\n        heartbeatTimeout: self._heartbeatTimeout,\\n        onTimeout: function () {\\n          self._lostConnection(\\n            new DDP.ConnectionError(\\\"DDP heartbeat timed out\\\"));\\n        },\\n        sendPing: function () {\\n          self._send({msg: 'ping'});\\n        }\\n      });\\n      self._heartbeat.start();\\n    }\\n\\n    // If this is a reconnect, we'll have to reset all stores.\\n    if (self._lastSessionId)\\n      self._resetStores = true;\\n\\n    if (typeof (msg.session) === \\\"string\\\") {\\n      var reconnectedToPreviousSession = (self._lastSessionId === msg.session);\\n      self._lastSessionId = msg.session;\\n    }\\n\\n    if (reconnectedToPreviousSession) {\\n      // Successful reconnection -- pick up where we left off.  Note that right\\n      // now, this never happens: the server never connects us to a previous\\n      // session, because DDP doesn't provide enough data for the server to know\\n      // what messages the client has processed. We need to improve DDP to make\\n      // this possible, at which point we'll probably need more code here.\\n      return;\\n    }\\n\\n    // Server doesn't have our data any more. Re-sync a new session.\\n\\n    // Forget about messages we were buffering for unknown collections. They'll\\n    // be resent if still relevant.\\n    self._updatesForUnknownStores = {};\\n\\n    if (self._resetStores) {\\n      // Forget about the effects of stubs. We'll be resetting all collections\\n      // anyway.\\n      self._documentsWrittenByStub = {};\\n      self._serverDocuments = {};\\n    }\\n\\n    // Clear _afterUpdateCallbacks.\\n    self._afterUpdateCallbacks = [];\\n\\n    // Mark all named subscriptions which are ready (ie, we already called the\\n    // ready callback) as needing to be revived.\\n    // XXX We should also block reconnect quiescence until unnamed subscriptions\\n    //     (eg, autopublish) are done re-publishing to avoid flicker!\\n    self._subsBeingRevived = {};\\n    _.each(self._subscriptions, function (sub, id) {\\n      if (sub.ready)\\n        self._subsBeingRevived[id] = true;\\n    });\\n\\n    // Arrange for \\\"half-finished\\\" methods to have their callbacks run, and\\n    // track methods that were sent on this connection so that we don't\\n    // quiesce until they are all done.\\n    //\\n    // Start by clearing _methodsBlockingQuiescence: methods sent before\\n    // reconnect don't matter, and any \\\"wait\\\" methods sent on the new connection\\n    // that we drop here will be restored by the loop below.\\n    self._methodsBlockingQuiescence = {};\\n    if (self._resetStores) {\\n      _.each(self._methodInvokers, function (invoker) {\\n        if (invoker.gotResult()) {\\n          // This method already got its result, but it didn't call its callback\\n          // because its data didn't become visible. We did not resend the\\n          // method RPC. We'll call its callback when we get a full quiesce,\\n          // since that's as close as we'll get to \\\"data must be visible\\\".\\n          self._afterUpdateCallbacks.push(_.bind(invoker.dataVisible, invoker));\\n        } else if (invoker.sentMessage) {\\n          // This method has been sent on this connection (maybe as a resend\\n          // from the last connection, maybe from onReconnect, maybe just very\\n          // quickly before processing the connected message).\\n          //\\n          // We don't need to do anything special to ensure its callbacks get\\n          // called, but we'll count it as a method which is preventing\\n          // reconnect quiescence. (eg, it might be a login method that was run\\n          // from onReconnect, and we don't want to see flicker by seeing a\\n          // logged-out state.)\\n          self._methodsBlockingQuiescence[invoker.methodId] = true;\\n        }\\n      });\\n    }\\n\\n    self._messagesBufferedUntilQuiescence = [];\\n\\n    // If we're not waiting on any methods or subs, we can reset the stores and\\n    // call the callbacks immediately.\\n    if (!self._waitingForQuiescence()) {\\n      if (self._resetStores) {\\n        _.each(self._stores, function (s) {\\n          s.beginUpdate(0, true);\\n          s.endUpdate();\\n        });\\n        self._resetStores = false;\\n      }\\n      self._runAfterUpdateCallbacks();\\n    }\\n  },\\n\\n\\n  _processOneDataMessage: function (msg, updates) {\\n    var self = this;\\n    // Using underscore here so as not to need to capitalize.\\n    self['_process_' + msg.msg](msg, updates);\\n  },\\n\\n\\n  _livedata_data: function (msg) {\\n    var self = this;\\n\\n    // collection name -> array of messages\\n    var updates = {};\\n\\n    if (self._waitingForQuiescence()) {\\n      self._messagesBufferedUntilQuiescence.push(msg);\\n\\n      if (msg.msg === \\\"nosub\\\")\\n        delete self._subsBeingRevived[msg.id];\\n\\n      _.each(msg.subs || [], function (subId) {\\n        delete self._subsBeingRevived[subId];\\n      });\\n      _.each(msg.methods || [], function (methodId) {\\n        delete self._methodsBlockingQuiescence[methodId];\\n      });\\n\\n      if (self._waitingForQuiescence())\\n        return;\\n\\n      // No methods or subs are blocking quiescence!\\n      // We'll now process and all of our buffered messages, reset all stores,\\n      // and apply them all at once.\\n      _.each(self._messagesBufferedUntilQuiescence, function (bufferedMsg) {\\n        self._processOneDataMessage(bufferedMsg, updates);\\n      });\\n      self._messagesBufferedUntilQuiescence = [];\\n    } else {\\n      self._processOneDataMessage(msg, updates);\\n    }\\n\\n    if (self._resetStores || !_.isEmpty(updates)) {\\n      // Begin a transactional update of each store.\\n      _.each(self._stores, function (s, storeName) {\\n        s.beginUpdate(_.has(updates, storeName) ? updates[storeName].length : 0,\\n                      self._resetStores);\\n      });\\n      self._resetStores = false;\\n\\n      _.each(updates, function (updateMessages, storeName) {\\n        var store = self._stores[storeName];\\n        if (store) {\\n          _.each(updateMessages, function (updateMessage) {\\n            store.update(updateMessage);\\n          });\\n        } else {\\n          // Nobody's listening for this data. Queue it up until\\n          // someone wants it.\\n          // XXX memory use will grow without bound if you forget to\\n          // create a collection or just don't care about it... going\\n          // to have to do something about that.\\n          if (!_.has(self._updatesForUnknownStores, storeName))\\n            self._updatesForUnknownStores[storeName] = [];\\n          Array.prototype.push.apply(self._updatesForUnknownStores[storeName],\\n                                     updateMessages);\\n        }\\n      });\\n\\n      // End update transaction.\\n      _.each(self._stores, function (s) { s.endUpdate(); });\\n    }\\n\\n    self._runAfterUpdateCallbacks();\\n  },\\n\\n  // Call any callbacks deferred with _runWhenAllServerDocsAreFlushed whose\\n  // relevant docs have been flushed, as well as dataVisible callbacks at\\n  // reconnect-quiescence time.\\n  _runAfterUpdateCallbacks: function () {\\n    var self = this;\\n    var callbacks = self._afterUpdateCallbacks;\\n    self._afterUpdateCallbacks = [];\\n    _.each(callbacks, function (c) {\\n      c();\\n    });\\n  },\\n\\n  _pushUpdate: function (updates, collection, msg) {\\n    var self = this;\\n    if (!_.has(updates, collection)) {\\n      updates[collection] = [];\\n    }\\n    updates[collection].push(msg);\\n  },\\n\\n  _getServerDoc: function (collection, id) {\\n    var self = this;\\n    if (!_.has(self._serverDocuments, collection))\\n      return null;\\n    var serverDocsForCollection = self._serverDocuments[collection];\\n    return serverDocsForCollection.get(id) || null;\\n  },\\n\\n  _process_added: function (msg, updates) {\\n    var self = this;\\n    var id = LocalCollection._idParse(msg.id);\\n    var serverDoc = self._getServerDoc(msg.collection, id);\\n    if (serverDoc) {\\n      // Some outstanding stub wrote here.\\n      if (serverDoc.document !== undefined)\\n        throw new Error(\\\"Server sent add for existing id: \\\" + msg.id);\\n      serverDoc.document = msg.fields || {};\\n      serverDoc.document._id = id;\\n    } else {\\n      self._pushUpdate(updates, msg.collection, msg);\\n    }\\n  },\\n\\n  _process_changed: function (msg, updates) {\\n    var self = this;\\n    var serverDoc = self._getServerDoc(\\n      msg.collection, LocalCollection._idParse(msg.id));\\n    if (serverDoc) {\\n      if (serverDoc.document === undefined)\\n        throw new Error(\\\"Server sent changed for nonexisting id: \\\" + msg.id);\\n      LocalCollection._applyChanges(serverDoc.document, msg.fields);\\n    } else {\\n      self._pushUpdate(updates, msg.collection, msg);\\n    }\\n  },\\n\\n  _process_removed: function (msg, updates) {\\n    var self = this;\\n    var serverDoc = self._getServerDoc(\\n      msg.collection, LocalCollection._idParse(msg.id));\\n    if (serverDoc) {\\n      // Some outstanding stub wrote here.\\n      if (serverDoc.document === undefined)\\n        throw new Error(\\\"Server sent removed for nonexisting id:\\\" + msg.id);\\n      serverDoc.document = undefined;\\n    } else {\\n      self._pushUpdate(updates, msg.collection, {\\n        msg: 'removed',\\n        collection: msg.collection,\\n        id: msg.id\\n      });\\n    }\\n  },\\n\\n  _process_updated: function (msg, updates) {\\n    var self = this;\\n    // Process \\\"method done\\\" messages.\\n    _.each(msg.methods, function (methodId) {\\n      _.each(self._documentsWrittenByStub[methodId], function (written) {\\n        var serverDoc = self._getServerDoc(written.collection, written.id);\\n        if (!serverDoc)\\n          throw new Error(\\\"Lost serverDoc for \\\" + JSON.stringify(written));\\n        if (!serverDoc.writtenByStubs[methodId])\\n          throw new Error(\\\"Doc \\\" + JSON.stringify(written) +\\n                          \\\" not written by  method \\\" + methodId);\\n        delete serverDoc.writtenByStubs[methodId];\\n        if (_.isEmpty(serverDoc.writtenByStubs)) {\\n          // All methods whose stubs wrote this method have completed! We can\\n          // now copy the saved document to the database (reverting the stub's\\n          // change if the server did not write to this object, or applying the\\n          // server's writes if it did).\\n\\n          // This is a fake ddp 'replace' message.  It's just for talking\\n          // between livedata connections and minimongo.  (We have to stringify\\n          // the ID because it's supposed to look like a wire message.)\\n          self._pushUpdate(updates, written.collection, {\\n            msg: 'replace',\\n            id: LocalCollection._idStringify(written.id),\\n            replace: serverDoc.document\\n          });\\n          // Call all flush callbacks.\\n          _.each(serverDoc.flushCallbacks, function (c) {\\n            c();\\n          });\\n\\n          // Delete this completed serverDocument. Don't bother to GC empty\\n          // IdMaps inside self._serverDocuments, since there probably aren't\\n          // many collections and they'll be written repeatedly.\\n          self._serverDocuments[written.collection].remove(written.id);\\n        }\\n      });\\n      delete self._documentsWrittenByStub[methodId];\\n\\n      // We want to call the data-written callback, but we can't do so until all\\n      // currently buffered messages are flushed.\\n      var callbackInvoker = self._methodInvokers[methodId];\\n      if (!callbackInvoker)\\n        throw new Error(\\\"No callback invoker for method \\\" + methodId);\\n      self._runWhenAllServerDocsAreFlushed(\\n        _.bind(callbackInvoker.dataVisible, callbackInvoker));\\n    });\\n  },\\n\\n  _process_ready: function (msg, updates) {\\n    var self = this;\\n    // Process \\\"sub ready\\\" messages. \\\"sub ready\\\" messages don't take effect\\n    // until all current server documents have been flushed to the local\\n    // database. We can use a write fence to implement this.\\n    _.each(msg.subs, function (subId) {\\n      self._runWhenAllServerDocsAreFlushed(function () {\\n        var subRecord = self._subscriptions[subId];\\n        // Did we already unsubscribe?\\n        if (!subRecord)\\n          return;\\n        // Did we already receive a ready message? (Oops!)\\n        if (subRecord.ready)\\n          return;\\n        subRecord.readyCallback && subRecord.readyCallback();\\n        subRecord.ready = true;\\n        subRecord.readyDeps.changed();\\n      });\\n    });\\n  },\\n\\n  // Ensures that \\\"f\\\" will be called after all documents currently in\\n  // _serverDocuments have been written to the local cache. f will not be called\\n  // if the connection is lost before then!\\n  _runWhenAllServerDocsAreFlushed: function (f) {\\n    var self = this;\\n    var runFAfterUpdates = function () {\\n      self._afterUpdateCallbacks.push(f);\\n    };\\n    var unflushedServerDocCount = 0;\\n    var onServerDocFlush = function () {\\n      --unflushedServerDocCount;\\n      if (unflushedServerDocCount === 0) {\\n        // This was the last doc to flush! Arrange to run f after the updates\\n        // have been applied.\\n        runFAfterUpdates();\\n      }\\n    };\\n    _.each(self._serverDocuments, function (collectionDocs) {\\n      collectionDocs.forEach(function (serverDoc) {\\n        var writtenByStubForAMethodWithSentMessage = _.any(\\n          serverDoc.writtenByStubs, function (dummy, methodId) {\\n            var invoker = self._methodInvokers[methodId];\\n            return invoker && invoker.sentMessage;\\n          });\\n        if (writtenByStubForAMethodWithSentMessage) {\\n          ++unflushedServerDocCount;\\n          serverDoc.flushCallbacks.push(onServerDocFlush);\\n        }\\n      });\\n    });\\n    if (unflushedServerDocCount === 0) {\\n      // There aren't any buffered docs --- we can call f as soon as the current\\n      // round of updates is applied!\\n      runFAfterUpdates();\\n    }\\n  },\\n\\n  _livedata_nosub: function (msg) {\\n    var self = this;\\n\\n    // First pass it through _livedata_data, which only uses it to help get\\n    // towards quiescence.\\n    self._livedata_data(msg);\\n\\n    // Do the rest of our processing immediately, with no\\n    // buffering-until-quiescence.\\n\\n    // we weren't subbed anyway, or we initiated the unsub.\\n    if (!_.has(self._subscriptions, msg.id))\\n      return;\\n\\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback\\n    var errorCallback = self._subscriptions[msg.id].errorCallback;\\n    var stopCallback = self._subscriptions[msg.id].stopCallback;\\n\\n    self._subscriptions[msg.id].remove();\\n\\n    var meteorErrorFromMsg = function (msgArg) {\\n      return msgArg && msgArg.error && new Meteor.Error(\\n        msgArg.error.error, msgArg.error.reason, msgArg.error.details);\\n    }\\n\\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback\\n    if (errorCallback && msg.error) {\\n      errorCallback(meteorErrorFromMsg(msg));\\n    }\\n\\n    if (stopCallback) {\\n      stopCallback(meteorErrorFromMsg(msg));\\n    }\\n  },\\n\\n  _process_nosub: function () {\\n    // This is called as part of the \\\"buffer until quiescence\\\" process, but\\n    // nosub's effect is always immediate. It only goes in the buffer at all\\n    // because it's possible for a nosub to be the thing that triggers\\n    // quiescence, if we were waiting for a sub to be revived and it dies\\n    // instead.\\n  },\\n\\n  _livedata_result: function (msg) {\\n    // id, result or error. error has error (code), reason, details\\n\\n    var self = this;\\n\\n    // find the outstanding request\\n    // should be O(1) in nearly all realistic use cases\\n    if (_.isEmpty(self._outstandingMethodBlocks)) {\\n      Meteor._debug(\\\"Received method result but no methods outstanding\\\");\\n      return;\\n    }\\n    var currentMethodBlock = self._outstandingMethodBlocks[0].methods;\\n    var m;\\n    for (var i = 0; i < currentMethodBlock.length; i++) {\\n      m = currentMethodBlock[i];\\n      if (m.methodId === msg.id)\\n        break;\\n    }\\n\\n    if (!m) {\\n      Meteor._debug(\\\"Can't match method response to original method call\\\", msg);\\n      return;\\n    }\\n\\n    // Remove from current method block. This may leave the block empty, but we\\n    // don't move on to the next block until the callback has been delivered, in\\n    // _outstandingMethodFinished.\\n    currentMethodBlock.splice(i, 1);\\n\\n    if (_.has(msg, 'error')) {\\n      m.receiveResult(new Meteor.Error(\\n        msg.error.error, msg.error.reason,\\n        msg.error.details));\\n    } else {\\n      // msg.result may be undefined if the method didn't return a\\n      // value\\n      m.receiveResult(undefined, msg.result);\\n    }\\n  },\\n\\n  // Called by MethodInvoker after a method's callback is invoked.  If this was\\n  // the last outstanding method in the current block, runs the next block. If\\n  // there are no more methods, consider accepting a hot code push.\\n  _outstandingMethodFinished: function () {\\n    var self = this;\\n    if (self._anyMethodsAreOutstanding())\\n      return;\\n\\n    // No methods are outstanding. This should mean that the first block of\\n    // methods is empty. (Or it might not exist, if this was a method that\\n    // half-finished before disconnect/reconnect.)\\n    if (! _.isEmpty(self._outstandingMethodBlocks)) {\\n      var firstBlock = self._outstandingMethodBlocks.shift();\\n      if (! _.isEmpty(firstBlock.methods))\\n        throw new Error(\\\"No methods outstanding but nonempty block: \\\" +\\n                        JSON.stringify(firstBlock));\\n\\n      // Send the outstanding methods now in the first block.\\n      if (!_.isEmpty(self._outstandingMethodBlocks))\\n        self._sendOutstandingMethods();\\n    }\\n\\n    // Maybe accept a hot code push.\\n    self._maybeMigrate();\\n  },\\n\\n  // Sends messages for all the methods in the first block in\\n  // _outstandingMethodBlocks.\\n  _sendOutstandingMethods: function() {\\n    var self = this;\\n    if (_.isEmpty(self._outstandingMethodBlocks))\\n      return;\\n    _.each(self._outstandingMethodBlocks[0].methods, function (m) {\\n      m.sendMessage();\\n    });\\n  },\\n\\n  _livedata_error: function (msg) {\\n    Meteor._debug(\\\"Received error from server: \\\", msg.reason);\\n    if (msg.offendingMessage)\\n      Meteor._debug(\\\"For: \\\", msg.offendingMessage);\\n  },\\n\\n  _callOnReconnectAndSendAppropriateOutstandingMethods: function() {\\n    var self = this;\\n    var oldOutstandingMethodBlocks = self._outstandingMethodBlocks;\\n    self._outstandingMethodBlocks = [];\\n\\n    self.onReconnect();\\n\\n    if (_.isEmpty(oldOutstandingMethodBlocks))\\n      return;\\n\\n    // We have at least one block worth of old outstanding methods to try\\n    // again. First: did onReconnect actually send anything? If not, we just\\n    // restore all outstanding methods and run the first block.\\n    if (_.isEmpty(self._outstandingMethodBlocks)) {\\n      self._outstandingMethodBlocks = oldOutstandingMethodBlocks;\\n      self._sendOutstandingMethods();\\n      return;\\n    }\\n\\n    // OK, there are blocks on both sides. Special case: merge the last block of\\n    // the reconnect methods with the first block of the original methods, if\\n    // neither of them are \\\"wait\\\" blocks.\\n    if (!_.last(self._outstandingMethodBlocks).wait &&\\n        !oldOutstandingMethodBlocks[0].wait) {\\n      _.each(oldOutstandingMethodBlocks[0].methods, function (m) {\\n        _.last(self._outstandingMethodBlocks).methods.push(m);\\n\\n        // If this \\\"last block\\\" is also the first block, send the message.\\n        if (self._outstandingMethodBlocks.length === 1)\\n          m.sendMessage();\\n      });\\n\\n      oldOutstandingMethodBlocks.shift();\\n    }\\n\\n    // Now add the rest of the original blocks on.\\n    _.each(oldOutstandingMethodBlocks, function (block) {\\n      self._outstandingMethodBlocks.push(block);\\n    });\\n  },\\n\\n  // We can accept a hot code push if there are no methods in flight.\\n  _readyToMigrate: function() {\\n    var self = this;\\n    return _.isEmpty(self._methodInvokers);\\n  },\\n\\n  // If we were blocking a migration, see if it's now possible to continue.\\n  // Call whenever the set of outstanding/blocked methods shrinks.\\n  _maybeMigrate: function () {\\n    var self = this;\\n    if (self._retryMigrate && self._readyToMigrate()) {\\n      self._retryMigrate();\\n      self._retryMigrate = null;\\n    }\\n  }\\n});\\n\\nLivedataTest.Connection = Connection;\\n\\n// @param url {String} URL to Meteor app,\\n//     e.g.:\\n//     \\\"subdomain.meteor.com\\\",\\n//     \\\"http://subdomain.meteor.com\\\",\\n//     \\\"/\\\",\\n//     \\\"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\\\"\\n\\n/**\\n * @summary Connect to the server of a different Meteor application to subscribe to its document sets and invoke its remote methods.\\n * @locus Anywhere\\n * @param {String} url The URL of another Meteor application.\\n */\\nDDP.connect = function (url, options) {\\n  var ret = new Connection(url, options);\\n  allConnections.push(ret); // hack. see below.\\n  return ret;\\n};\\n\\n// Hack for `spiderable` package: a way to see if the page is done\\n// loading all the data it needs.\\n//\\nallConnections = [];\\nDDP._allSubscriptionsReady = function () {\\n  return _.all(allConnections, function (conn) {\\n    return _.all(conn._subscriptions, function (sub) {\\n      return sub.ready;\\n    });\\n  });\\n};\\n\",\"// Meteor.refresh can be called on the client (if you're in common code) but it\\n// only has an effect on the server.\\nMeteor.refresh = function (notification) {\\n};\\n\\nif (Meteor.isClient) {\\n  // By default, try to connect back to the same endpoint as the page\\n  // was served from.\\n  //\\n  // XXX We should be doing this a different way. Right now we don't\\n  // include ROOT_URL_PATH_PREFIX when computing ddpUrl. (We don't\\n  // include it on the server when computing\\n  // DDP_DEFAULT_CONNECTION_URL, and we don't include it in our\\n  // default, '/'.) We get by with this because DDP.connect then\\n  // forces the URL passed to it to be interpreted relative to the\\n  // app's deploy path, even if it is absolute. Instead, we should\\n  // make DDP_DEFAULT_CONNECTION_URL, if set, include the path prefix;\\n  // make the default ddpUrl be '' rather that '/'; and make\\n  // _translateUrl in stream_client_common.js not force absolute paths\\n  // to be treated like relative paths. See also\\n  // stream_client_common.js #RationalizingRelativeDDPURLs\\n  var ddpUrl = '/';\\n  if (typeof __meteor_runtime_config__ !== \\\"undefined\\\") {\\n    if (__meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL)\\n      ddpUrl = __meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL;\\n  }\\n\\n  var retry = new Retry();\\n\\n  var onDDPVersionNegotiationFailure = function (description) {\\n    Meteor._debug(description);\\n    if (Package.reload) {\\n      var migrationData = Package.reload.Reload._migrationData('livedata') || {};\\n      var failures = migrationData.DDPVersionNegotiationFailures || 0;\\n      ++failures;\\n      Package.reload.Reload._onMigrate('livedata', function () {\\n        return [true, {DDPVersionNegotiationFailures: failures}];\\n      });\\n      retry.retryLater(failures, function () {\\n        Package.reload.Reload._reload();\\n      });\\n    }\\n  };\\n\\n  Meteor.connection =\\n    DDP.connect(ddpUrl, {\\n      onDDPVersionNegotiationFailure: onDDPVersionNegotiationFailure\\n    });\\n\\n  // Proxy the public methods of Meteor.connection so they can\\n  // be called directly on Meteor.\\n  _.each(['subscribe', 'methods', 'call', 'apply', 'status', 'reconnect',\\n          'disconnect'],\\n         function (name) {\\n           Meteor[name] = _.bind(Meteor.connection[name], Meteor.connection);\\n         });\\n} else {\\n  // Never set up a default connection on the server. Don't even map\\n  // subscribe/call/etc onto Meteor.\\n  Meteor.connection = null;\\n}\\n\\n// Meteor.connection used to be called\\n// Meteor.default_connection. Provide backcompat as a courtesy even\\n// though it was never documented.\\n// XXX COMPAT WITH 0.6.4\\nMeteor.default_connection = Meteor.connection;\\n\\n// We should transition from Meteor.connect to DDP.connect.\\n// XXX COMPAT WITH 0.6.4\\nMeteor.connect = DDP.connect;\\n\"]}\n\nUnable to open C:\\socialite\\.meteor\\local\\db\\mongod.lock\n333 matches across 8 files\n\n\nSearching 558 files for \"logo.png\"\n\nC:\\socialite\\.meteor\\local\\build\\programs\\web.cordova\\program.json:\n 1426      },\n 1427      {\n 1428:       \"path\": \"app/logo.png\",\n 1429        \"where\": \"client\",\n 1430        \"type\": \"asset\",\n 1431        \"cacheable\": false,\n 1432:       \"url\": \"/logo.png\",\n 1433        \"size\": 2790,\n 1434        \"hash\": \"cd5b539f1dd2f8dc031d460ed1d412abbbb03f7f\"\n\nC:\\socialite\\.meteor\\local\\build\\programs\\web.cordova\\app\\client\\views\\dashboard\\template.dashboard_header.js:\n   20      },\n   21      \"class\": \"btn btn-link\"\n   22:   }, HTML.Raw('<i class=\"fa fa-power-off\"></i>'), \" Log out\"), \"\\n          \"), \"\\n          \", HTML.Raw('<img class=\"hidden-xs\" src=\"logo.png\">'), \"\\n        \"), \"\\n      \"), \"\\n    \"), \"\\n  \"), \"\\n  \", Blaze.If(function() {\n   23      return Spacebars.call(view.lookup(\"showInvitation\"));\n   24    }, function() {\n\nC:\\socialite\\.meteor\\local\\build\\programs\\web.cordova\\app\\client\\views\\invitation\\template.invitation.js:\n    7    }, \"\\n    \", HTML.DIV({\n    8      \"class\": \"container\"\n    9:   }, \"\\n      \", HTML.Raw('<div class=\"row\">\\n        <div class=\"col-xs-12\">\\n          <div class=\"logo-line\"><!-- <img src=\"/logo.png\"> --></div>\\n        </div>\\n      </div>'), \"\\n      \", HTML.DIV({\n   10      \"class\": \"row\"\n   11    }, \"\\n        \", HTML.DIV({\n\nC:\\socialite\\.meteor\\local\\build\\programs\\web.cordova\\app\\client\\views\\landing\\template.landing.js:\n    7    }, \"\\n    \", HTML.DIV({\n    8      \"class\": \"container\"\n    9:   }, \"\\n      \", HTML.Raw('<div class=\"row\">\\n       <div class=\"col-xs-12\">\\n          <div class=\"logo-line\"><!-- <img src=\"logo.png\"> --> </div>\\n        </div> \\n      </div>'), \"\\n      \", HTML.DIV({\n   10      \"class\": \"row\"\n   11    }, \"\\n        \", Blaze.Unless(function() {\n\nUnable to open C:\\socialite\\.meteor\\local\\db\\mongod.lock\nC:\\socialite\\client\\views\\dashboard\\dashboard_header.html:\n    8              <a href=\"{{pathFor route='logout'}}\" class=\"btn btn-link\"><i class=\"fa fa-power-off\"></i> Log out</a>\n    9            </div>\n   10:           <img class=\"hidden-xs\" src=\"logo.png\">\n   11          </div>\n   12        </div>\n\nC:\\socialite\\client\\views\\invitation\\invitation.html:\n    4        <div class=\"row\">\n    5          <div class=\"col-xs-12\">\n    6:           <div class=\"logo-line\"><!-- <img src=\"/logo.png\"> --></div>\n    7          </div>\n    8        </div>\n\nC:\\socialite\\client\\views\\landing\\landing.html:\n    4        <div class=\"row\">\n    5         <div class=\"col-xs-12\">\n    6:           <div class=\"logo-line\"><!-- <img src=\"logo.png\"> --> </div>\n    7          </div> \n    8        </div>\n\n8 matches across 7 files\n\n\nSearching 96 files for \"invitation-form\"\n\nUnable to open C:\\socialite\\.meteor\\local\\db\\mongod.lock\nC:\\socialite\\client\\views\\dashboard\\dashboard_header.html:\n   14    </div>\n   15    {{#if showInvitation}}\n   16:     <div class=\"invitation-form\">\n   17        <div class=\"container\">\n   18          <div class=\"row\">\n\nC:\\socialite\\client\\views\\dashboard\\dashboard_header.sass:\n   14      padding: 15px 0\n   15  \n   16: .invitation-form\n   17    background: $dark-green\n   18    padding: 30px 0\n   ..\n   65        width: 50%\n   66        float: left\n   67:   .invitation-form\n   68      .toggle-button\n   69        position: relative\n\n3 matches across 2 files\n",
			"settings":
			{
				"buffer_size": 520388,
				"line_ending": "Windows",
				"name": "Find Results",
				"scratch": true
			}
		},
		{
			"contents": "(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar Random = Package.random.Random;\nvar EJSON = Package.ejson.EJSON;\nvar _ = Package.underscore._;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar Log = Package.logging.Log;\nvar Retry = Package.retry.Retry;\nvar Hook = Package['callback-hook'].Hook;\nvar LocalCollection = Package.minimongo.LocalCollection;\nvar Minimongo = Package.minimongo.Minimongo;\n\n/* Package-scope variables */\nvar DDP, DDPServer, LivedataTest, toSockjsUrl, toWebsocketUrl, StreamServer, Heartbeat, Server, SUPPORTED_DDP_VERSIONS, MethodInvocation, parseDDP, stringifyDDP, RandomStream, makeRpcSeed, allConnections;\n\n(function () {\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/ddp/common.js                                                                                              //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/**                                                                                                                    // 1\n * @namespace DDP                                                                                                      // 2\n * @summary The namespace for DDP-related methods.                                                                     // 3\n */                                                                                                                    // 4\nDDP = {};                                                                                                              // 5\nLivedataTest = {};                                                                                                     // 6\n                                                                                                                       // 7\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function () {\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/ddp/stream_client_nodejs.js                                                                                //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n// @param endpoint {String} URL to Meteor app                                                                          // 1\n//   \"http://subdomain.meteor.com/\" or \"/\" or                                                                          // 2\n//   \"ddp+sockjs://foo-**.meteor.com/sockjs\"                                                                           // 3\n//                                                                                                                     // 4\n// We do some rewriting of the URL to eventually make it \"ws://\" or \"wss://\",                                          // 5\n// whatever was passed in.  At the very least, what Meteor.absoluteUrl() returns                                       // 6\n// us should work.                                                                                                     // 7\n//                                                                                                                     // 8\n// We don't do any heartbeating. (The logic that did this in sockjs was removed,                                       // 9\n// because it used a built-in sockjs mechanism. We could do it with WebSocket                                          // 10\n// ping frames or with DDP-level messages.)                                                                            // 11\nLivedataTest.ClientStream = function (endpoint, options) {                                                             // 12\n  var self = this;                                                                                                     // 13\n  options = options || {};                                                                                             // 14\n                                                                                                                       // 15\n  self.options = _.extend({                                                                                            // 16\n    retry: true                                                                                                        // 17\n  }, options);                                                                                                         // 18\n                                                                                                                       // 19\n  self.client = null;  // created in _launchConnection                                                                 // 20\n  self.endpoint = endpoint;                                                                                            // 21\n                                                                                                                       // 22\n  self.headers = self.options.headers || {};                                                                           // 23\n                                                                                                                       // 24\n  self._initCommon(self.options);                                                                                      // 25\n                                                                                                                       // 26\n  //// Kickoff!                                                                                                        // 27\n  self._launchConnection();                                                                                            // 28\n};                                                                                                                     // 29\n                                                                                                                       // 30\n_.extend(LivedataTest.ClientStream.prototype, {                                                                        // 31\n                                                                                                                       // 32\n  // data is a utf8 string. Data sent while not connected is dropped on                                                // 33\n  // the floor, and it is up the user of this API to retransmit lost                                                   // 34\n  // messages on 'reset'                                                                                               // 35\n  send: function (data) {                                                                                              // 36\n    var self = this;                                                                                                   // 37\n    if (self.currentStatus.connected) {                                                                                // 38\n      self.client.send(data);                                                                                          // 39\n    }                                                                                                                  // 40\n  },                                                                                                                   // 41\n                                                                                                                       // 42\n  // Changes where this connection points                                                                              // 43\n  _changeUrl: function (url) {                                                                                         // 44\n    var self = this;                                                                                                   // 45\n    self.endpoint = url;                                                                                               // 46\n  },                                                                                                                   // 47\n                                                                                                                       // 48\n  _onConnect: function (client) {                                                                                      // 49\n    var self = this;                                                                                                   // 50\n                                                                                                                       // 51\n    if (client !== self.client) {                                                                                      // 52\n      // This connection is not from the last call to _launchConnection.                                               // 53\n      // But _launchConnection calls _cleanup which closes previous connections.                                       // 54\n      // It's our belief that this stifles future 'open' events, but maybe                                             // 55\n      // we are wrong?                                                                                                 // 56\n      throw new Error(\"Got open from inactive client \" + !!self.client);                                               // 57\n    }                                                                                                                  // 58\n                                                                                                                       // 59\n    if (self._forcedToDisconnect) {                                                                                    // 60\n      // We were asked to disconnect between trying to open the connection and                                         // 61\n      // actually opening it. Let's just pretend this never happened.                                                  // 62\n      self.client.close();                                                                                             // 63\n      self.client = null;                                                                                              // 64\n      return;                                                                                                          // 65\n    }                                                                                                                  // 66\n                                                                                                                       // 67\n    if (self.currentStatus.connected) {                                                                                // 68\n      // We already have a connection. It must have been the case that we                                              // 69\n      // started two parallel connection attempts (because we wanted to                                                // 70\n      // 'reconnect now' on a hanging connection and we had no way to cancel the                                       // 71\n      // connection attempt.) But this shouldn't happen (similarly to the client                                       // 72\n      // !== self.client check above).                                                                                 // 73\n      throw new Error(\"Two parallel connections?\");                                                                    // 74\n    }                                                                                                                  // 75\n                                                                                                                       // 76\n    self._clearConnectionTimer();                                                                                      // 77\n                                                                                                                       // 78\n    // update status                                                                                                   // 79\n    self.currentStatus.status = \"connected\";                                                                           // 80\n    self.currentStatus.connected = true;                                                                               // 81\n    self.currentStatus.retryCount = 0;                                                                                 // 82\n    self.statusChanged();                                                                                              // 83\n                                                                                                                       // 84\n    // fire resets. This must come after status change so that clients                                                 // 85\n    // can call send from within a reset callback.                                                                     // 86\n    _.each(self.eventCallbacks.reset, function (callback) { callback(); });                                            // 87\n  },                                                                                                                   // 88\n                                                                                                                       // 89\n  _cleanup: function (maybeError) {                                                                                    // 90\n    var self = this;                                                                                                   // 91\n                                                                                                                       // 92\n    self._clearConnectionTimer();                                                                                      // 93\n    if (self.client) {                                                                                                 // 94\n      var client = self.client;                                                                                        // 95\n      self.client = null;                                                                                              // 96\n      client.close();                                                                                                  // 97\n                                                                                                                       // 98\n      _.each(self.eventCallbacks.disconnect, function (callback) {                                                     // 99\n        callback(maybeError);                                                                                          // 100\n      });                                                                                                              // 101\n    }                                                                                                                  // 102\n  },                                                                                                                   // 103\n                                                                                                                       // 104\n  _clearConnectionTimer: function () {                                                                                 // 105\n    var self = this;                                                                                                   // 106\n                                                                                                                       // 107\n    if (self.connectionTimer) {                                                                                        // 108\n      clearTimeout(self.connectionTimer);                                                                              // 109\n      self.connectionTimer = null;                                                                                     // 110\n    }                                                                                                                  // 111\n  },                                                                                                                   // 112\n                                                                                                                       // 113\n  _getProxyUrl: function (targetUrl) {                                                                                 // 114\n    var self = this;                                                                                                   // 115\n    // Similar to code in tools/http-helpers.js.                                                                       // 116\n    var proxy = process.env.HTTP_PROXY || process.env.http_proxy || null;                                              // 117\n    // if we're going to a secure url, try the https_proxy env variable first.                                         // 118\n    if (targetUrl.match(/^wss:/)) {                                                                                    // 119\n      proxy = process.env.HTTPS_PROXY || process.env.https_proxy || proxy;                                             // 120\n    }                                                                                                                  // 121\n    return proxy;                                                                                                      // 122\n  },                                                                                                                   // 123\n                                                                                                                       // 124\n  _launchConnection: function () {                                                                                     // 125\n    var self = this;                                                                                                   // 126\n    self._cleanup(); // cleanup the old socket, if there was one.                                                      // 127\n                                                                                                                       // 128\n    // Since server-to-server DDP is still an experimental feature, we only                                            // 129\n    // require the module if we actually create a server-to-server                                                     // 130\n    // connection.                                                                                                     // 131\n    var FayeWebSocket = Npm.require('faye-websocket');                                                                 // 132\n                                                                                                                       // 133\n    var targetUrl = toWebsocketUrl(self.endpoint);                                                                     // 134\n    var fayeOptions = { headers: self.headers };                                                                       // 135\n    var proxyUrl = self._getProxyUrl(targetUrl);                                                                       // 136\n    if (proxyUrl) {                                                                                                    // 137\n      fayeOptions.proxy = { origin: proxyUrl };                                                                        // 138\n    };                                                                                                                 // 139\n                                                                                                                       // 140\n    // We would like to specify 'ddp' as the subprotocol here. The npm module we                                       // 141\n    // used to use as a client would fail the handshake if we ask for a                                                // 142\n    // subprotocol and the server doesn't send one back (and sockjs doesn't).                                          // 143\n    // Faye doesn't have that behavior; it's unclear from reading RFC 6455 if                                          // 144\n    // Faye is erroneous or not.  So for now, we don't specify protocols.                                              // 145\n    var subprotocols = [];                                                                                             // 146\n                                                                                                                       // 147\n    var client = self.client = new FayeWebSocket.Client(                                                               // 148\n      targetUrl, subprotocols, fayeOptions);                                                                           // 149\n                                                                                                                       // 150\n    self._clearConnectionTimer();                                                                                      // 151\n    self.connectionTimer = Meteor.setTimeout(                                                                          // 152\n      function () {                                                                                                    // 153\n        self._lostConnection(                                                                                          // 154\n          new DDP.ConnectionError(\"DDP connection timed out\"));                                                        // 155\n      },                                                                                                               // 156\n      self.CONNECT_TIMEOUT);                                                                                           // 157\n                                                                                                                       // 158\n    self.client.on('open', Meteor.bindEnvironment(function () {                                                        // 159\n      return self._onConnect(client);                                                                                  // 160\n    }, \"stream connect callback\"));                                                                                    // 161\n                                                                                                                       // 162\n    var clientOnIfCurrent = function (event, description, f) {                                                         // 163\n      self.client.on(event, Meteor.bindEnvironment(function () {                                                       // 164\n        // Ignore events from any connection we've already cleaned up.                                                 // 165\n        if (client !== self.client)                                                                                    // 166\n          return;                                                                                                      // 167\n        f.apply(this, arguments);                                                                                      // 168\n      }, description));                                                                                                // 169\n    };                                                                                                                 // 170\n                                                                                                                       // 171\n    clientOnIfCurrent('error', 'stream error callback', function (error) {                                             // 172\n      if (!self.options._dontPrintErrors)                                                                              // 173\n        Meteor._debug(\"stream error\", error.message);                                                                  // 174\n                                                                                                                       // 175\n      // Faye's 'error' object is not a JS error (and among other things,                                              // 176\n      // doesn't stringify well). Convert it to one.                                                                   // 177\n      self._lostConnection(new DDP.ConnectionError(error.message));                                                    // 178\n    });                                                                                                                // 179\n                                                                                                                       // 180\n                                                                                                                       // 181\n    clientOnIfCurrent('close', 'stream close callback', function () {                                                  // 182\n      self._lostConnection();                                                                                          // 183\n    });                                                                                                                // 184\n                                                                                                                       // 185\n                                                                                                                       // 186\n    clientOnIfCurrent('message', 'stream message callback', function (message) {                                       // 187\n      // Ignore binary frames, where message.data is a Buffer                                                          // 188\n      if (typeof message.data !== \"string\")                                                                            // 189\n        return;                                                                                                        // 190\n                                                                                                                       // 191\n      _.each(self.eventCallbacks.message, function (callback) {                                                        // 192\n        callback(message.data);                                                                                        // 193\n      });                                                                                                              // 194\n    });                                                                                                                // 195\n  }                                                                                                                    // 196\n});                                                                                                                    // 197\n                                                                                                                       // 198\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function () {\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/ddp/stream_client_common.js                                                                                //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n// XXX from Underscore.String (http://epeli.github.com/underscore.string/)                                             // 1\nvar startsWith = function(str, starts) {                                                                               // 2\n  return str.length >= starts.length &&                                                                                // 3\n    str.substring(0, starts.length) === starts;                                                                        // 4\n};                                                                                                                     // 5\nvar endsWith = function(str, ends) {                                                                                   // 6\n  return str.length >= ends.length &&                                                                                  // 7\n    str.substring(str.length - ends.length) === ends;                                                                  // 8\n};                                                                                                                     // 9\n                                                                                                                       // 10\n// @param url {String} URL to Meteor app, eg:                                                                          // 11\n//   \"/\" or \"madewith.meteor.com\" or \"https://foo.meteor.com\"                                                          // 12\n//   or \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"                                                                 // 13\n// @returns {String} URL to the endpoint with the specific scheme and subPath, e.g.                                    // 14\n// for scheme \"http\" and subPath \"sockjs\"                                                                              // 15\n//   \"http://subdomain.meteor.com/sockjs\" or \"/sockjs\"                                                                 // 16\n//   or \"https://ddp--1234-foo.meteor.com/sockjs\"                                                                      // 17\nvar translateUrl =  function(url, newSchemeBase, subPath) {                                                            // 18\n  if (! newSchemeBase) {                                                                                               // 19\n    newSchemeBase = \"http\";                                                                                            // 20\n  }                                                                                                                    // 21\n                                                                                                                       // 22\n  var ddpUrlMatch = url.match(/^ddp(i?)\\+sockjs:\\/\\//);                                                                // 23\n  var httpUrlMatch = url.match(/^http(s?):\\/\\//);                                                                      // 24\n  var newScheme;                                                                                                       // 25\n  if (ddpUrlMatch) {                                                                                                   // 26\n    // Remove scheme and split off the host.                                                                           // 27\n    var urlAfterDDP = url.substr(ddpUrlMatch[0].length);                                                               // 28\n    newScheme = ddpUrlMatch[1] === \"i\" ? newSchemeBase : newSchemeBase + \"s\";                                          // 29\n    var slashPos = urlAfterDDP.indexOf('/');                                                                           // 30\n    var host =                                                                                                         // 31\n          slashPos === -1 ? urlAfterDDP : urlAfterDDP.substr(0, slashPos);                                             // 32\n    var rest = slashPos === -1 ? '' : urlAfterDDP.substr(slashPos);                                                    // 33\n                                                                                                                       // 34\n    // In the host (ONLY!), change '*' characters into random digits. This                                             // 35\n    // allows different stream connections to connect to different hostnames                                           // 36\n    // and avoid browser per-hostname connection limits.                                                               // 37\n    host = host.replace(/\\*/g, function () {                                                                           // 38\n      return Math.floor(Random.fraction()*10);                                                                         // 39\n    });                                                                                                                // 40\n                                                                                                                       // 41\n    return newScheme + '://' + host + rest;                                                                            // 42\n  } else if (httpUrlMatch) {                                                                                           // 43\n    newScheme = !httpUrlMatch[1] ? newSchemeBase : newSchemeBase + \"s\";                                                // 44\n    var urlAfterHttp = url.substr(httpUrlMatch[0].length);                                                             // 45\n    url = newScheme + \"://\" + urlAfterHttp;                                                                            // 46\n  }                                                                                                                    // 47\n                                                                                                                       // 48\n  // Prefix FQDNs but not relative URLs                                                                                // 49\n  if (url.indexOf(\"://\") === -1 && !startsWith(url, \"/\")) {                                                            // 50\n    url = newSchemeBase + \"://\" + url;                                                                                 // 51\n  }                                                                                                                    // 52\n                                                                                                                       // 53\n  // XXX This is not what we should be doing: if I have a site                                                         // 54\n  // deployed at \"/foo\", then DDP.connect(\"/\") should actually connect                                                 // 55\n  // to \"/\", not to \"/foo\". \"/\" is an absolute path. (Contrast: if                                                     // 56\n  // deployed at \"/foo\", it would be reasonable for DDP.connect(\"bar\")                                                 // 57\n  // to connect to \"/foo/bar\").                                                                                        // 58\n  //                                                                                                                   // 59\n  // We should make this properly honor absolute paths rather than                                                     // 60\n  // forcing the path to be relative to the site root. Simultaneously,                                                 // 61\n  // we should set DDP_DEFAULT_CONNECTION_URL to include the site                                                      // 62\n  // root. See also client_convenience.js #RationalizingRelativeDDPURLs                                                // 63\n  url = Meteor._relativeToSiteRootUrl(url);                                                                            // 64\n                                                                                                                       // 65\n  if (endsWith(url, \"/\"))                                                                                              // 66\n    return url + subPath;                                                                                              // 67\n  else                                                                                                                 // 68\n    return url + \"/\" + subPath;                                                                                        // 69\n};                                                                                                                     // 70\n                                                                                                                       // 71\ntoSockjsUrl = function (url) {                                                                                         // 72\n  return translateUrl(url, \"http\", \"sockjs\");                                                                          // 73\n};                                                                                                                     // 74\n                                                                                                                       // 75\ntoWebsocketUrl = function (url) {                                                                                      // 76\n  var ret = translateUrl(url, \"ws\", \"websocket\");                                                                      // 77\n  return ret;                                                                                                          // 78\n};                                                                                                                     // 79\n                                                                                                                       // 80\nLivedataTest.toSockjsUrl = toSockjsUrl;                                                                                // 81\n                                                                                                                       // 82\n                                                                                                                       // 83\n_.extend(LivedataTest.ClientStream.prototype, {                                                                        // 84\n                                                                                                                       // 85\n  // Register for callbacks.                                                                                           // 86\n  on: function (name, callback) {                                                                                      // 87\n    var self = this;                                                                                                   // 88\n                                                                                                                       // 89\n    if (name !== 'message' && name !== 'reset' && name !== 'disconnect')                                               // 90\n      throw new Error(\"unknown event type: \" + name);                                                                  // 91\n                                                                                                                       // 92\n    if (!self.eventCallbacks[name])                                                                                    // 93\n      self.eventCallbacks[name] = [];                                                                                  // 94\n    self.eventCallbacks[name].push(callback);                                                                          // 95\n  },                                                                                                                   // 96\n                                                                                                                       // 97\n                                                                                                                       // 98\n  _initCommon: function (options) {                                                                                    // 99\n    var self = this;                                                                                                   // 100\n    options = options || {};                                                                                           // 101\n                                                                                                                       // 102\n    //// Constants                                                                                                     // 103\n                                                                                                                       // 104\n    // how long to wait until we declare the connection attempt                                                        // 105\n    // failed.                                                                                                         // 106\n    self.CONNECT_TIMEOUT = options.connectTimeoutMs || 10000;                                                          // 107\n                                                                                                                       // 108\n    self.eventCallbacks = {}; // name -> [callback]                                                                    // 109\n                                                                                                                       // 110\n    self._forcedToDisconnect = false;                                                                                  // 111\n                                                                                                                       // 112\n    //// Reactive status                                                                                               // 113\n    self.currentStatus = {                                                                                             // 114\n      status: \"connecting\",                                                                                            // 115\n      connected: false,                                                                                                // 116\n      retryCount: 0                                                                                                    // 117\n    };                                                                                                                 // 118\n                                                                                                                       // 119\n                                                                                                                       // 120\n    self.statusListeners = typeof Tracker !== 'undefined' && new Tracker.Dependency;                                   // 121\n    self.statusChanged = function () {                                                                                 // 122\n      if (self.statusListeners)                                                                                        // 123\n        self.statusListeners.changed();                                                                                // 124\n    };                                                                                                                 // 125\n                                                                                                                       // 126\n    //// Retry logic                                                                                                   // 127\n    self._retry = new Retry;                                                                                           // 128\n    self.connectionTimer = null;                                                                                       // 129\n                                                                                                                       // 130\n  },                                                                                                                   // 131\n                                                                                                                       // 132\n  // Trigger a reconnect.                                                                                              // 133\n  reconnect: function (options) {                                                                                      // 134\n    var self = this;                                                                                                   // 135\n    options = options || {};                                                                                           // 136\n                                                                                                                       // 137\n    if (options.url) {                                                                                                 // 138\n      self._changeUrl(options.url);                                                                                    // 139\n    }                                                                                                                  // 140\n                                                                                                                       // 141\n    if (options._sockjsOptions) {                                                                                      // 142\n      self.options._sockjsOptions = options._sockjsOptions;                                                            // 143\n    }                                                                                                                  // 144\n                                                                                                                       // 145\n    if (self.currentStatus.connected) {                                                                                // 146\n      if (options._force || options.url) {                                                                             // 147\n        // force reconnect.                                                                                            // 148\n        self._lostConnection(new DDP.ForcedReconnectError);                                                            // 149\n      } // else, noop.                                                                                                 // 150\n      return;                                                                                                          // 151\n    }                                                                                                                  // 152\n                                                                                                                       // 153\n    // if we're mid-connection, stop it.                                                                               // 154\n    if (self.currentStatus.status === \"connecting\") {                                                                  // 155\n      // Pretend it's a clean close.                                                                                   // 156\n      self._lostConnection();                                                                                          // 157\n    }                                                                                                                  // 158\n                                                                                                                       // 159\n    self._retry.clear();                                                                                               // 160\n    self.currentStatus.retryCount -= 1; // don't count manual retries                                                  // 161\n    self._retryNow();                                                                                                  // 162\n  },                                                                                                                   // 163\n                                                                                                                       // 164\n  disconnect: function (options) {                                                                                     // 165\n    var self = this;                                                                                                   // 166\n    options = options || {};                                                                                           // 167\n                                                                                                                       // 168\n    // Failed is permanent. If we're failed, don't let people go back                                                  // 169\n    // online by calling 'disconnect' then 'reconnect'.                                                                // 170\n    if (self._forcedToDisconnect)                                                                                      // 171\n      return;                                                                                                          // 172\n                                                                                                                       // 173\n    // If _permanent is set, permanently disconnect a stream. Once a stream                                            // 174\n    // is forced to disconnect, it can never reconnect. This is for                                                    // 175\n    // error cases such as ddp version mismatch, where trying again                                                    // 176\n    // won't fix the problem.                                                                                          // 177\n    if (options._permanent) {                                                                                          // 178\n      self._forcedToDisconnect = true;                                                                                 // 179\n    }                                                                                                                  // 180\n                                                                                                                       // 181\n    self._cleanup();                                                                                                   // 182\n    self._retry.clear();                                                                                               // 183\n                                                                                                                       // 184\n    self.currentStatus = {                                                                                             // 185\n      status: (options._permanent ? \"failed\" : \"offline\"),                                                             // 186\n      connected: false,                                                                                                // 187\n      retryCount: 0                                                                                                    // 188\n    };                                                                                                                 // 189\n                                                                                                                       // 190\n    if (options._permanent && options._error)                                                                          // 191\n      self.currentStatus.reason = options._error;                                                                      // 192\n                                                                                                                       // 193\n    self.statusChanged();                                                                                              // 194\n  },                                                                                                                   // 195\n                                                                                                                       // 196\n  // maybeError is set unless it's a clean protocol-level close.                                                       // 197\n  _lostConnection: function (maybeError) {                                                                             // 198\n    var self = this;                                                                                                   // 199\n                                                                                                                       // 200\n    self._cleanup(maybeError);                                                                                         // 201\n    self._retryLater(maybeError); // sets status. no need to do it here.                                               // 202\n  },                                                                                                                   // 203\n                                                                                                                       // 204\n  // fired when we detect that we've gone online. try to reconnect                                                     // 205\n  // immediately.                                                                                                      // 206\n  _online: function () {                                                                                               // 207\n    // if we've requested to be offline by disconnecting, don't reconnect.                                             // 208\n    if (this.currentStatus.status != \"offline\")                                                                        // 209\n      this.reconnect();                                                                                                // 210\n  },                                                                                                                   // 211\n                                                                                                                       // 212\n  _retryLater: function (maybeError) {                                                                                 // 213\n    var self = this;                                                                                                   // 214\n                                                                                                                       // 215\n    var timeout = 0;                                                                                                   // 216\n    if (self.options.retry ||                                                                                          // 217\n        (maybeError && maybeError.errorType === \"DDP.ForcedReconnectError\")) {                                         // 218\n      timeout = self._retry.retryLater(                                                                                // 219\n        self.currentStatus.retryCount,                                                                                 // 220\n        _.bind(self._retryNow, self)                                                                                   // 221\n      );                                                                                                               // 222\n      self.currentStatus.status = \"waiting\";                                                                           // 223\n      self.currentStatus.retryTime = (new Date()).getTime() + timeout;                                                 // 224\n    } else {                                                                                                           // 225\n      self.currentStatus.status = \"failed\";                                                                            // 226\n      delete self.currentStatus.retryTime;                                                                             // 227\n    }                                                                                                                  // 228\n                                                                                                                       // 229\n    self.currentStatus.connected = false;                                                                              // 230\n    self.statusChanged();                                                                                              // 231\n  },                                                                                                                   // 232\n                                                                                                                       // 233\n  _retryNow: function () {                                                                                             // 234\n    var self = this;                                                                                                   // 235\n                                                                                                                       // 236\n    if (self._forcedToDisconnect)                                                                                      // 237\n      return;                                                                                                          // 238\n                                                                                                                       // 239\n    self.currentStatus.retryCount += 1;                                                                                // 240\n    self.currentStatus.status = \"connecting\";                                                                          // 241\n    self.currentStatus.connected = false;                                                                              // 242\n    delete self.currentStatus.retryTime;                                                                               // 243\n    self.statusChanged();                                                                                              // 244\n                                                                                                                       // 245\n    self._launchConnection();                                                                                          // 246\n  },                                                                                                                   // 247\n                                                                                                                       // 248\n                                                                                                                       // 249\n  // Get current status. Reactive.                                                                                     // 250\n  status: function () {                                                                                                // 251\n    var self = this;                                                                                                   // 252\n    if (self.statusListeners)                                                                                          // 253\n      self.statusListeners.depend();                                                                                   // 254\n    return self.currentStatus;                                                                                         // 255\n  }                                                                                                                    // 256\n});                                                                                                                    // 257\n                                                                                                                       // 258\nDDP.ConnectionError = Meteor.makeErrorType(                                                                            // 259\n  \"DDP.ConnectionError\", function (message) {                                                                          // 260\n    var self = this;                                                                                                   // 261\n    self.message = message;                                                                                            // 262\n});                                                                                                                    // 263\n                                                                                                                       // 264\nDDP.ForcedReconnectError = Meteor.makeErrorType(                                                                       // 265\n  \"DDP.ForcedReconnectError\", function () {});                                                                         // 266\n                                                                                                                       // 267\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function () {\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/ddp/stream_server.js                                                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar url = Npm.require('url');                                                                                          // 1\n                                                                                                                       // 2\nvar pathPrefix = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX ||  \"\";                                                // 3\n                                                                                                                       // 4\nStreamServer = function () {                                                                                           // 5\n  var self = this;                                                                                                     // 6\n  self.registration_callbacks = [];                                                                                    // 7\n  self.open_sockets = [];                                                                                              // 8\n                                                                                                                       // 9\n  // Because we are installing directly onto WebApp.httpServer instead of using                                        // 10\n  // WebApp.app, we have to process the path prefix ourselves.                                                         // 11\n  self.prefix = pathPrefix + '/sockjs';                                                                                // 12\n  // routepolicy is only a weak dependency, because we don't need it if we're                                          // 13\n  // just doing server-to-server DDP as a client.                                                                      // 14\n  if (Package.routepolicy) {                                                                                           // 15\n    Package.routepolicy.RoutePolicy.declare(self.prefix + '/', 'network');                                             // 16\n  }                                                                                                                    // 17\n                                                                                                                       // 18\n  // set up sockjs                                                                                                     // 19\n  var sockjs = Npm.require('sockjs');                                                                                  // 20\n  var serverOptions = {                                                                                                // 21\n    prefix: self.prefix,                                                                                               // 22\n    log: function() {},                                                                                                // 23\n    // this is the default, but we code it explicitly because we depend                                                // 24\n    // on it in stream_client:HEARTBEAT_TIMEOUT                                                                        // 25\n    heartbeat_delay: 45000,                                                                                            // 26\n    // The default disconnect_delay is 5 seconds, but if the server ends up CPU                                        // 27\n    // bound for that much time, SockJS might not notice that the user has                                             // 28\n    // reconnected because the timer (of disconnect_delay ms) can fire before                                          // 29\n    // SockJS processes the new connection. Eventually we'll fix this by not                                           // 30\n    // combining CPU-heavy processing with SockJS termination (eg a proxy which                                        // 31\n    // converts to Unix sockets) but for now, raise the delay.                                                         // 32\n    disconnect_delay: 60 * 1000,                                                                                       // 33\n    // Set the USE_JSESSIONID environment variable to enable setting the                                               // 34\n    // JSESSIONID cookie. This is useful for setting up proxies with                                                   // 35\n    // session affinity.                                                                                               // 36\n    jsessionid: !!process.env.USE_JSESSIONID                                                                           // 37\n  };                                                                                                                   // 38\n                                                                                                                       // 39\n  // If you know your server environment (eg, proxies) will prevent websockets                                         // 40\n  // from ever working, set $DISABLE_WEBSOCKETS and SockJS clients (ie,                                                // 41\n  // browsers) will not waste time attempting to use them.                                                             // 42\n  // (Your server will still have a /websocket endpoint.)                                                              // 43\n  if (process.env.DISABLE_WEBSOCKETS)                                                                                  // 44\n    serverOptions.websocket = false;                                                                                   // 45\n                                                                                                                       // 46\n  self.server = sockjs.createServer(serverOptions);                                                                    // 47\n  if (!Package.webapp) {                                                                                               // 48\n    throw new Error(\"Cannot create a DDP server without the webapp package\");                                          // 49\n  }                                                                                                                    // 50\n  // Install the sockjs handlers, but we want to keep around our own particular                                        // 51\n  // request handler that adjusts idle timeouts while we have an outstanding                                           // 52\n  // request.  This compensates for the fact that sockjs removes all listeners                                         // 53\n  // for \"request\" to add its own.                                                                                     // 54\n  Package.webapp.WebApp.httpServer.removeListener('request', Package.webapp.WebApp._timeoutAdjustmentRequestCallback); // 55\n  self.server.installHandlers(Package.webapp.WebApp.httpServer);                                                       // 56\n  Package.webapp.WebApp.httpServer.addListener('request', Package.webapp.WebApp._timeoutAdjustmentRequestCallback);    // 57\n                                                                                                                       // 58\n  // Support the /websocket endpoint                                                                                   // 59\n  self._redirectWebsocketEndpoint();                                                                                   // 60\n                                                                                                                       // 61\n  self.server.on('connection', function (socket) {                                                                     // 62\n    socket.send = function (data) {                                                                                    // 63\n      socket.write(data);                                                                                              // 64\n    };                                                                                                                 // 65\n    socket.on('close', function () {                                                                                   // 66\n      self.open_sockets = _.without(self.open_sockets, socket);                                                        // 67\n    });                                                                                                                // 68\n    self.open_sockets.push(socket);                                                                                    // 69\n                                                                                                                       // 70\n    // XXX COMPAT WITH 0.6.6. Send the old style welcome message, which                                                // 71\n    // will force old clients to reload. Remove this once we're not                                                    // 72\n    // concerned about people upgrading from a pre-0.7.0 release. Also,                                                // 73\n    // remove the clause in the client that ignores the welcome message                                                // 74\n    // (livedata_connection.js)                                                                                        // 75\n    socket.send(JSON.stringify({server_id: \"0\"}));                                                                     // 76\n                                                                                                                       // 77\n    // call all our callbacks when we get a new socket. they will do the                                               // 78\n    // work of setting up handlers and such for specific messages.                                                     // 79\n    _.each(self.registration_callbacks, function (callback) {                                                          // 80\n      callback(socket);                                                                                                // 81\n    });                                                                                                                // 82\n  });                                                                                                                  // 83\n                                                                                                                       // 84\n};                                                                                                                     // 85\n                                                                                                                       // 86\n_.extend(StreamServer.prototype, {                                                                                     // 87\n  // call my callback when a new socket connects.                                                                      // 88\n  // also call it for all current connections.                                                                         // 89\n  register: function (callback) {                                                                                      // 90\n    var self = this;                                                                                                   // 91\n    self.registration_callbacks.push(callback);                                                                        // 92\n    _.each(self.all_sockets(), function (socket) {                                                                     // 93\n      callback(socket);                                                                                                // 94\n    });                                                                                                                // 95\n  },                                                                                                                   // 96\n                                                                                                                       // 97\n  // get a list of all sockets                                                                                         // 98\n  all_sockets: function () {                                                                                           // 99\n    var self = this;                                                                                                   // 100\n    return _.values(self.open_sockets);                                                                                // 101\n  },                                                                                                                   // 102\n                                                                                                                       // 103\n  // Redirect /websocket to /sockjs/websocket in order to not expose                                                   // 104\n  // sockjs to clients that want to use raw websockets                                                                 // 105\n  _redirectWebsocketEndpoint: function() {                                                                             // 106\n    var self = this;                                                                                                   // 107\n    // Unfortunately we can't use a connect middleware here since                                                      // 108\n    // sockjs installs itself prior to all existing listeners                                                          // 109\n    // (meaning prior to any connect middlewares) so we need to take                                                   // 110\n    // an approach similar to overshadowListeners in                                                                   // 111\n    // https://github.com/sockjs/sockjs-node/blob/cf820c55af6a9953e16558555a31decea554f70e/src/utils.coffee            // 112\n    _.each(['request', 'upgrade'], function(event) {                                                                   // 113\n      var httpServer = Package.webapp.WebApp.httpServer;                                                               // 114\n      var oldHttpServerListeners = httpServer.listeners(event).slice(0);                                               // 115\n      httpServer.removeAllListeners(event);                                                                            // 116\n                                                                                                                       // 117\n      // request and upgrade have different arguments passed but                                                       // 118\n      // we only care about the first one which is always request                                                      // 119\n      var newListener = function(request /*, moreArguments */) {                                                       // 120\n        // Store arguments for use within the closure below                                                            // 121\n        var args = arguments;                                                                                          // 122\n                                                                                                                       // 123\n        // Rewrite /websocket and /websocket/ urls to /sockjs/websocket while                                          // 124\n        // preserving query string.                                                                                    // 125\n        var parsedUrl = url.parse(request.url);                                                                        // 126\n        if (parsedUrl.pathname === pathPrefix + '/websocket' ||                                                        // 127\n            parsedUrl.pathname === pathPrefix + '/websocket/') {                                                       // 128\n          parsedUrl.pathname = self.prefix + '/websocket';                                                             // 129\n          request.url = url.format(parsedUrl);                                                                         // 130\n        }                                                                                                              // 131\n        _.each(oldHttpServerListeners, function(oldListener) {                                                         // 132\n          oldListener.apply(httpServer, args);                                                                         // 133\n        });                                                                                                            // 134\n      };                                                                                                               // 135\n      httpServer.addListener(event, newListener);                                                                      // 136\n    });                                                                                                                // 137\n  }                                                                                                                    // 138\n});                                                                                                                    // 139\n                                                                                                                       // 140\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function () {\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/ddp/heartbeat.js                                                                                           //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n// Heartbeat options:                                                                                                  // 1\n//   heartbeatInterval: interval to send pings, in milliseconds.                                                       // 2\n//   heartbeatTimeout: timeout to close the connection if a reply isn't                                                // 3\n//     received, in milliseconds.                                                                                      // 4\n//   sendPing: function to call to send a ping on the connection.                                                      // 5\n//   onTimeout: function to call to close the connection.                                                              // 6\n                                                                                                                       // 7\nHeartbeat = function (options) {                                                                                       // 8\n  var self = this;                                                                                                     // 9\n                                                                                                                       // 10\n  self.heartbeatInterval = options.heartbeatInterval;                                                                  // 11\n  self.heartbeatTimeout = options.heartbeatTimeout;                                                                    // 12\n  self._sendPing = options.sendPing;                                                                                   // 13\n  self._onTimeout = options.onTimeout;                                                                                 // 14\n                                                                                                                       // 15\n  self._heartbeatIntervalHandle = null;                                                                                // 16\n  self._heartbeatTimeoutHandle = null;                                                                                 // 17\n};                                                                                                                     // 18\n                                                                                                                       // 19\n_.extend(Heartbeat.prototype, {                                                                                        // 20\n  stop: function () {                                                                                                  // 21\n    var self = this;                                                                                                   // 22\n    self._clearHeartbeatIntervalTimer();                                                                               // 23\n    self._clearHeartbeatTimeoutTimer();                                                                                // 24\n  },                                                                                                                   // 25\n                                                                                                                       // 26\n  start: function () {                                                                                                 // 27\n    var self = this;                                                                                                   // 28\n    self.stop();                                                                                                       // 29\n    self._startHeartbeatIntervalTimer();                                                                               // 30\n  },                                                                                                                   // 31\n                                                                                                                       // 32\n  _startHeartbeatIntervalTimer: function () {                                                                          // 33\n    var self = this;                                                                                                   // 34\n    self._heartbeatIntervalHandle = Meteor.setTimeout(                                                                 // 35\n      _.bind(self._heartbeatIntervalFired, self),                                                                      // 36\n      self.heartbeatInterval                                                                                           // 37\n    );                                                                                                                 // 38\n  },                                                                                                                   // 39\n                                                                                                                       // 40\n  _startHeartbeatTimeoutTimer: function () {                                                                           // 41\n    var self = this;                                                                                                   // 42\n    self._heartbeatTimeoutHandle = Meteor.setTimeout(                                                                  // 43\n      _.bind(self._heartbeatTimeoutFired, self),                                                                       // 44\n      self.heartbeatTimeout                                                                                            // 45\n    );                                                                                                                 // 46\n  },                                                                                                                   // 47\n                                                                                                                       // 48\n  _clearHeartbeatIntervalTimer: function () {                                                                          // 49\n    var self = this;                                                                                                   // 50\n    if (self._heartbeatIntervalHandle) {                                                                               // 51\n      Meteor.clearTimeout(self._heartbeatIntervalHandle);                                                              // 52\n      self._heartbeatIntervalHandle = null;                                                                            // 53\n    }                                                                                                                  // 54\n  },                                                                                                                   // 55\n                                                                                                                       // 56\n  _clearHeartbeatTimeoutTimer: function () {                                                                           // 57\n    var self = this;                                                                                                   // 58\n    if (self._heartbeatTimeoutHandle) {                                                                                // 59\n      Meteor.clearTimeout(self._heartbeatTimeoutHandle);                                                               // 60\n      self._heartbeatTimeoutHandle = null;                                                                             // 61\n    }                                                                                                                  // 62\n  },                                                                                                                   // 63\n                                                                                                                       // 64\n  // The heartbeat interval timer is fired when we should send a ping.                                                 // 65\n  _heartbeatIntervalFired: function () {                                                                               // 66\n    var self = this;                                                                                                   // 67\n    self._heartbeatIntervalHandle = null;                                                                              // 68\n    self._sendPing();                                                                                                  // 69\n    // Wait for a pong.                                                                                                // 70\n    self._startHeartbeatTimeoutTimer();                                                                                // 71\n  },                                                                                                                   // 72\n                                                                                                                       // 73\n  // The heartbeat timeout timer is fired when we sent a ping, but we                                                  // 74\n  // timed out waiting for the pong.                                                                                   // 75\n  _heartbeatTimeoutFired: function () {                                                                                // 76\n    var self = this;                                                                                                   // 77\n    self._heartbeatTimeoutHandle = null;                                                                               // 78\n    self._onTimeout();                                                                                                 // 79\n  },                                                                                                                   // 80\n                                                                                                                       // 81\n  pingReceived: function () {                                                                                          // 82\n    var self = this;                                                                                                   // 83\n    // We know the connection is alive if we receive a ping, so we                                                     // 84\n    // don't need to send a ping ourselves.  Reset the interval timer.                                                 // 85\n    if (self._heartbeatIntervalHandle) {                                                                               // 86\n      self._clearHeartbeatIntervalTimer();                                                                             // 87\n      self._startHeartbeatIntervalTimer();                                                                             // 88\n    }                                                                                                                  // 89\n  },                                                                                                                   // 90\n                                                                                                                       // 91\n  pongReceived: function () {                                                                                          // 92\n    var self = this;                                                                                                   // 93\n                                                                                                                       // 94\n    // Receiving a pong means we won't timeout, so clear the timeout                                                   // 95\n    // timer and start the interval again.                                                                             // 96\n    if (self._heartbeatTimeoutHandle) {                                                                                // 97\n      self._clearHeartbeatTimeoutTimer();                                                                              // 98\n      self._startHeartbeatIntervalTimer();                                                                             // 99\n    }                                                                                                                  // 100\n  }                                                                                                                    // 101\n});                                                                                                                    // 102\n                                                                                                                       // 103\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function () {\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/ddp/livedata_server.js                                                                                     //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nDDPServer = {};                                                                                                        // 1\n                                                                                                                       // 2\nvar Fiber = Npm.require('fibers');                                                                                     // 3\n                                                                                                                       // 4\n// This file contains classes:                                                                                         // 5\n// * Session - The server's connection to a single DDP client                                                          // 6\n// * Subscription - A single subscription for a single client                                                          // 7\n// * Server - An entire server that may talk to > 1 client. A DDP endpoint.                                            // 8\n//                                                                                                                     // 9\n// Session and Subscription are file scope. For now, until we freeze                                                   // 10\n// the interface, Server is package scope (in the future it should be                                                  // 11\n// exported.)                                                                                                          // 12\n                                                                                                                       // 13\n// Represents a single document in a SessionCollectionView                                                             // 14\nvar SessionDocumentView = function () {                                                                                // 15\n  var self = this;                                                                                                     // 16\n  self.existsIn = {}; // set of subscriptionHandle                                                                     // 17\n  self.dataByKey = {}; // key-> [ {subscriptionHandle, value} by precedence]                                           // 18\n};                                                                                                                     // 19\n                                                                                                                       // 20\n_.extend(SessionDocumentView.prototype, {                                                                              // 21\n                                                                                                                       // 22\n  getFields: function () {                                                                                             // 23\n    var self = this;                                                                                                   // 24\n    var ret = {};                                                                                                      // 25\n    _.each(self.dataByKey, function (precedenceList, key) {                                                            // 26\n      ret[key] = precedenceList[0].value;                                                                              // 27\n    });                                                                                                                // 28\n    return ret;                                                                                                        // 29\n  },                                                                                                                   // 30\n                                                                                                                       // 31\n  clearField: function (subscriptionHandle, key, changeCollector) {                                                    // 32\n    var self = this;                                                                                                   // 33\n    // Publish API ignores _id if present in fields                                                                    // 34\n    if (key === \"_id\")                                                                                                 // 35\n      return;                                                                                                          // 36\n    var precedenceList = self.dataByKey[key];                                                                          // 37\n                                                                                                                       // 38\n    // It's okay to clear fields that didn't exist. No need to throw                                                   // 39\n    // an error.                                                                                                       // 40\n    if (!precedenceList)                                                                                               // 41\n      return;                                                                                                          // 42\n                                                                                                                       // 43\n    var removedValue = undefined;                                                                                      // 44\n    for (var i = 0; i < precedenceList.length; i++) {                                                                  // 45\n      var precedence = precedenceList[i];                                                                              // 46\n      if (precedence.subscriptionHandle === subscriptionHandle) {                                                      // 47\n        // The view's value can only change if this subscription is the one that                                       // 48\n        // used to have precedence.                                                                                    // 49\n        if (i === 0)                                                                                                   // 50\n          removedValue = precedence.value;                                                                             // 51\n        precedenceList.splice(i, 1);                                                                                   // 52\n        break;                                                                                                         // 53\n      }                                                                                                                // 54\n    }                                                                                                                  // 55\n    if (_.isEmpty(precedenceList)) {                                                                                   // 56\n      delete self.dataByKey[key];                                                                                      // 57\n      changeCollector[key] = undefined;                                                                                // 58\n    } else if (removedValue !== undefined &&                                                                           // 59\n               !EJSON.equals(removedValue, precedenceList[0].value)) {                                                 // 60\n      changeCollector[key] = precedenceList[0].value;                                                                  // 61\n    }                                                                                                                  // 62\n  },                                                                                                                   // 63\n                                                                                                                       // 64\n  changeField: function (subscriptionHandle, key, value,                                                               // 65\n                         changeCollector, isAdd) {                                                                     // 66\n    var self = this;                                                                                                   // 67\n    // Publish API ignores _id if present in fields                                                                    // 68\n    if (key === \"_id\")                                                                                                 // 69\n      return;                                                                                                          // 70\n                                                                                                                       // 71\n    // Don't share state with the data passed in by the user.                                                          // 72\n    value = EJSON.clone(value);                                                                                        // 73\n                                                                                                                       // 74\n    if (!_.has(self.dataByKey, key)) {                                                                                 // 75\n      self.dataByKey[key] = [{subscriptionHandle: subscriptionHandle,                                                  // 76\n                              value: value}];                                                                          // 77\n      changeCollector[key] = value;                                                                                    // 78\n      return;                                                                                                          // 79\n    }                                                                                                                  // 80\n    var precedenceList = self.dataByKey[key];                                                                          // 81\n    var elt;                                                                                                           // 82\n    if (!isAdd) {                                                                                                      // 83\n      elt = _.find(precedenceList, function (precedence) {                                                             // 84\n        return precedence.subscriptionHandle === subscriptionHandle;                                                   // 85\n      });                                                                                                              // 86\n    }                                                                                                                  // 87\n                                                                                                                       // 88\n    if (elt) {                                                                                                         // 89\n      if (elt === precedenceList[0] && !EJSON.equals(value, elt.value)) {                                              // 90\n        // this subscription is changing the value of this field.                                                      // 91\n        changeCollector[key] = value;                                                                                  // 92\n      }                                                                                                                // 93\n      elt.value = value;                                                                                               // 94\n    } else {                                                                                                           // 95\n      // this subscription is newly caring about this field                                                            // 96\n      precedenceList.push({subscriptionHandle: subscriptionHandle, value: value});                                     // 97\n    }                                                                                                                  // 98\n                                                                                                                       // 99\n  }                                                                                                                    // 100\n});                                                                                                                    // 101\n                                                                                                                       // 102\n/**                                                                                                                    // 103\n * Represents a client's view of a single collection                                                                   // 104\n * @param {String} collectionName Name of the collection it represents                                                 // 105\n * @param {Object.<String, Function>} sessionCallbacks The callbacks for added, changed, removed                       // 106\n * @class SessionCollectionView                                                                                        // 107\n */                                                                                                                    // 108\nvar SessionCollectionView = function (collectionName, sessionCallbacks) {                                              // 109\n  var self = this;                                                                                                     // 110\n  self.collectionName = collectionName;                                                                                // 111\n  self.documents = {};                                                                                                 // 112\n  self.callbacks = sessionCallbacks;                                                                                   // 113\n};                                                                                                                     // 114\n                                                                                                                       // 115\nLivedataTest.SessionCollectionView = SessionCollectionView;                                                            // 116\n                                                                                                                       // 117\n                                                                                                                       // 118\n_.extend(SessionCollectionView.prototype, {                                                                            // 119\n                                                                                                                       // 120\n  isEmpty: function () {                                                                                               // 121\n    var self = this;                                                                                                   // 122\n    return _.isEmpty(self.documents);                                                                                  // 123\n  },                                                                                                                   // 124\n                                                                                                                       // 125\n  diff: function (previous) {                                                                                          // 126\n    var self = this;                                                                                                   // 127\n    LocalCollection._diffObjects(previous.documents, self.documents, {                                                 // 128\n      both: _.bind(self.diffDocument, self),                                                                           // 129\n                                                                                                                       // 130\n      rightOnly: function (id, nowDV) {                                                                                // 131\n        self.callbacks.added(self.collectionName, id, nowDV.getFields());                                              // 132\n      },                                                                                                               // 133\n                                                                                                                       // 134\n      leftOnly: function (id, prevDV) {                                                                                // 135\n        self.callbacks.removed(self.collectionName, id);                                                               // 136\n      }                                                                                                                // 137\n    });                                                                                                                // 138\n  },                                                                                                                   // 139\n                                                                                                                       // 140\n  diffDocument: function (id, prevDV, nowDV) {                                                                         // 141\n    var self = this;                                                                                                   // 142\n    var fields = {};                                                                                                   // 143\n    LocalCollection._diffObjects(prevDV.getFields(), nowDV.getFields(), {                                              // 144\n      both: function (key, prev, now) {                                                                                // 145\n        if (!EJSON.equals(prev, now))                                                                                  // 146\n          fields[key] = now;                                                                                           // 147\n      },                                                                                                               // 148\n      rightOnly: function (key, now) {                                                                                 // 149\n        fields[key] = now;                                                                                             // 150\n      },                                                                                                               // 151\n      leftOnly: function(key, prev) {                                                                                  // 152\n        fields[key] = undefined;                                                                                       // 153\n      }                                                                                                                // 154\n    });                                                                                                                // 155\n    self.callbacks.changed(self.collectionName, id, fields);                                                           // 156\n  },                                                                                                                   // 157\n                                                                                                                       // 158\n  added: function (subscriptionHandle, id, fields) {                                                                   // 159\n    var self = this;                                                                                                   // 160\n    var docView = self.documents[id];                                                                                  // 161\n    var added = false;                                                                                                 // 162\n    if (!docView) {                                                                                                    // 163\n      added = true;                                                                                                    // 164\n      docView = new SessionDocumentView();                                                                             // 165\n      self.documents[id] = docView;                                                                                    // 166\n    }                                                                                                                  // 167\n    docView.existsIn[subscriptionHandle] = true;                                                                       // 168\n    var changeCollector = {};                                                                                          // 169\n    _.each(fields, function (value, key) {                                                                             // 170\n      docView.changeField(                                                                                             // 171\n        subscriptionHandle, key, value, changeCollector, true);                                                        // 172\n    });                                                                                                                // 173\n    if (added)                                                                                                         // 174\n      self.callbacks.added(self.collectionName, id, changeCollector);                                                  // 175\n    else                                                                                                               // 176\n      self.callbacks.changed(self.collectionName, id, changeCollector);                                                // 177\n  },                                                                                                                   // 178\n                                                                                                                       // 179\n  changed: function (subscriptionHandle, id, changed) {                                                                // 180\n    var self = this;                                                                                                   // 181\n    var changedResult = {};                                                                                            // 182\n    var docView = self.documents[id];                                                                                  // 183\n    if (!docView)                                                                                                      // 184\n      throw new Error(\"Could not find element with id \" + id + \" to change\");                                          // 185\n    _.each(changed, function (value, key) {                                                                            // 186\n      if (value === undefined)                                                                                         // 187\n        docView.clearField(subscriptionHandle, key, changedResult);                                                    // 188\n      else                                                                                                             // 189\n        docView.changeField(subscriptionHandle, key, value, changedResult);                                            // 190\n    });                                                                                                                // 191\n    self.callbacks.changed(self.collectionName, id, changedResult);                                                    // 192\n  },                                                                                                                   // 193\n                                                                                                                       // 194\n  removed: function (subscriptionHandle, id) {                                                                         // 195\n    var self = this;                                                                                                   // 196\n    var docView = self.documents[id];                                                                                  // 197\n    if (!docView) {                                                                                                    // 198\n      var err = new Error(\"Removed nonexistent document \" + id);                                                       // 199\n      throw err;                                                                                                       // 200\n    }                                                                                                                  // 201\n    delete docView.existsIn[subscriptionHandle];                                                                       // 202\n    if (_.isEmpty(docView.existsIn)) {                                                                                 // 203\n      // it is gone from everyone                                                                                      // 204\n      self.callbacks.removed(self.collectionName, id);                                                                 // 205\n      delete self.documents[id];                                                                                       // 206\n    } else {                                                                                                           // 207\n      var changed = {};                                                                                                // 208\n      // remove this subscription from every precedence list                                                           // 209\n      // and record the changes                                                                                        // 210\n      _.each(docView.dataByKey, function (precedenceList, key) {                                                       // 211\n        docView.clearField(subscriptionHandle, key, changed);                                                          // 212\n      });                                                                                                              // 213\n                                                                                                                       // 214\n      self.callbacks.changed(self.collectionName, id, changed);                                                        // 215\n    }                                                                                                                  // 216\n  }                                                                                                                    // 217\n});                                                                                                                    // 218\n                                                                                                                       // 219\n/******************************************************************************/                                       // 220\n/* Session                                                                    */                                       // 221\n/******************************************************************************/                                       // 222\n                                                                                                                       // 223\nvar Session = function (server, version, socket, options) {                                                            // 224\n  var self = this;                                                                                                     // 225\n  self.id = Random.id();                                                                                               // 226\n                                                                                                                       // 227\n  self.server = server;                                                                                                // 228\n  self.version = version;                                                                                              // 229\n                                                                                                                       // 230\n  self.initialized = false;                                                                                            // 231\n  self.socket = socket;                                                                                                // 232\n                                                                                                                       // 233\n  // set to null when the session is destroyed. multiple places below                                                  // 234\n  // use this to determine if the session is alive or not.                                                             // 235\n  self.inQueue = new Meteor._DoubleEndedQueue();                                                                       // 236\n                                                                                                                       // 237\n  self.blocked = false;                                                                                                // 238\n  self.workerRunning = false;                                                                                          // 239\n                                                                                                                       // 240\n  // Sub objects for active subscriptions                                                                              // 241\n  self._namedSubs = {};                                                                                                // 242\n  self._universalSubs = [];                                                                                            // 243\n                                                                                                                       // 244\n  self.userId = null;                                                                                                  // 245\n                                                                                                                       // 246\n  self.collectionViews = {};                                                                                           // 247\n                                                                                                                       // 248\n  // Set this to false to not send messages when collectionViews are                                                   // 249\n  // modified. This is done when rerunning subs in _setUserId and those messages                                       // 250\n  // are calculated via a diff instead.                                                                                // 251\n  self._isSending = true;                                                                                              // 252\n                                                                                                                       // 253\n  // If this is true, don't start a newly-created universal publisher on this                                          // 254\n  // session. The session will take care of starting it when appropriate.                                              // 255\n  self._dontStartNewUniversalSubs = false;                                                                             // 256\n                                                                                                                       // 257\n  // when we are rerunning subscriptions, any ready messages                                                           // 258\n  // we want to buffer up for when we are done rerunning subscriptions                                                 // 259\n  self._pendingReady = [];                                                                                             // 260\n                                                                                                                       // 261\n  // List of callbacks to call when this connection is closed.                                                         // 262\n  self._closeCallbacks = [];                                                                                           // 263\n                                                                                                                       // 264\n                                                                                                                       // 265\n  // XXX HACK: If a sockjs connection, save off the URL. This is                                                       // 266\n  // temporary and will go away in the near future.                                                                    // 267\n  self._socketUrl = socket.url;                                                                                        // 268\n                                                                                                                       // 269\n  // Allow tests to disable responding to pings.                                                                       // 270\n  self._respondToPings = options.respondToPings;                                                                       // 271\n                                                                                                                       // 272\n  // This object is the public interface to the session. In the public                                                 // 273\n  // API, it is called the `connection` object.  Internally we call it                                                 // 274\n  // a `connectionHandle` to avoid ambiguity.                                                                          // 275\n  self.connectionHandle = {                                                                                            // 276\n    id: self.id,                                                                                                       // 277\n    close: function () {                                                                                               // 278\n      self.close();                                                                                                    // 279\n    },                                                                                                                 // 280\n    onClose: function (fn) {                                                                                           // 281\n      var cb = Meteor.bindEnvironment(fn, \"connection onClose callback\");                                              // 282\n      if (self.inQueue) {                                                                                              // 283\n        self._closeCallbacks.push(cb);                                                                                 // 284\n      } else {                                                                                                         // 285\n        // if we're already closed, call the callback.                                                                 // 286\n        Meteor.defer(cb);                                                                                              // 287\n      }                                                                                                                // 288\n    },                                                                                                                 // 289\n    clientAddress: self._clientAddress(),                                                                              // 290\n    httpHeaders: self.socket.headers                                                                                   // 291\n  };                                                                                                                   // 292\n                                                                                                                       // 293\n  socket.send(stringifyDDP({msg: 'connected',                                                                          // 294\n                            session: self.id}));                                                                       // 295\n  // On initial connect, spin up all the universal publishers.                                                         // 296\n  Fiber(function () {                                                                                                  // 297\n    self.startUniversalSubs();                                                                                         // 298\n  }).run();                                                                                                            // 299\n                                                                                                                       // 300\n  if (version !== 'pre1' && options.heartbeatInterval !== 0) {                                                         // 301\n    self.heartbeat = new Heartbeat({                                                                                   // 302\n      heartbeatInterval: options.heartbeatInterval,                                                                    // 303\n      heartbeatTimeout: options.heartbeatTimeout,                                                                      // 304\n      onTimeout: function () {                                                                                         // 305\n        self.close();                                                                                                  // 306\n      },                                                                                                               // 307\n      sendPing: function () {                                                                                          // 308\n        self.send({msg: 'ping'});                                                                                      // 309\n      }                                                                                                                // 310\n    });                                                                                                                // 311\n    self.heartbeat.start();                                                                                            // 312\n  }                                                                                                                    // 313\n                                                                                                                       // 314\n  Package.facts && Package.facts.Facts.incrementServerFact(                                                            // 315\n    \"livedata\", \"sessions\", 1);                                                                                        // 316\n};                                                                                                                     // 317\n                                                                                                                       // 318\n_.extend(Session.prototype, {                                                                                          // 319\n                                                                                                                       // 320\n  sendReady: function (subscriptionIds) {                                                                              // 321\n    var self = this;                                                                                                   // 322\n    if (self._isSending)                                                                                               // 323\n      self.send({msg: \"ready\", subs: subscriptionIds});                                                                // 324\n    else {                                                                                                             // 325\n      _.each(subscriptionIds, function (subscriptionId) {                                                              // 326\n        self._pendingReady.push(subscriptionId);                                                                       // 327\n      });                                                                                                              // 328\n    }                                                                                                                  // 329\n  },                                                                                                                   // 330\n                                                                                                                       // 331\n  sendAdded: function (collectionName, id, fields) {                                                                   // 332\n    var self = this;                                                                                                   // 333\n    if (self._isSending)                                                                                               // 334\n      self.send({msg: \"added\", collection: collectionName, id: id, fields: fields});                                   // 335\n  },                                                                                                                   // 336\n                                                                                                                       // 337\n  sendChanged: function (collectionName, id, fields) {                                                                 // 338\n    var self = this;                                                                                                   // 339\n    if (_.isEmpty(fields))                                                                                             // 340\n      return;                                                                                                          // 341\n                                                                                                                       // 342\n    if (self._isSending) {                                                                                             // 343\n      self.send({                                                                                                      // 344\n        msg: \"changed\",                                                                                                // 345\n        collection: collectionName,                                                                                    // 346\n        id: id,                                                                                                        // 347\n        fields: fields                                                                                                 // 348\n      });                                                                                                              // 349\n    }                                                                                                                  // 350\n  },                                                                                                                   // 351\n                                                                                                                       // 352\n  sendRemoved: function (collectionName, id) {                                                                         // 353\n    var self = this;                                                                                                   // 354\n    if (self._isSending)                                                                                               // 355\n      self.send({msg: \"removed\", collection: collectionName, id: id});                                                 // 356\n  },                                                                                                                   // 357\n                                                                                                                       // 358\n  getSendCallbacks: function () {                                                                                      // 359\n    var self = this;                                                                                                   // 360\n    return {                                                                                                           // 361\n      added: _.bind(self.sendAdded, self),                                                                             // 362\n      changed: _.bind(self.sendChanged, self),                                                                         // 363\n      removed: _.bind(self.sendRemoved, self)                                                                          // 364\n    };                                                                                                                 // 365\n  },                                                                                                                   // 366\n                                                                                                                       // 367\n  getCollectionView: function (collectionName) {                                                                       // 368\n    var self = this;                                                                                                   // 369\n    if (_.has(self.collectionViews, collectionName)) {                                                                 // 370\n      return self.collectionViews[collectionName];                                                                     // 371\n    }                                                                                                                  // 372\n    var ret = new SessionCollectionView(collectionName,                                                                // 373\n                                        self.getSendCallbacks());                                                      // 374\n    self.collectionViews[collectionName] = ret;                                                                        // 375\n    return ret;                                                                                                        // 376\n  },                                                                                                                   // 377\n                                                                                                                       // 378\n  added: function (subscriptionHandle, collectionName, id, fields) {                                                   // 379\n    var self = this;                                                                                                   // 380\n    var view = self.getCollectionView(collectionName);                                                                 // 381\n    view.added(subscriptionHandle, id, fields);                                                                        // 382\n  },                                                                                                                   // 383\n                                                                                                                       // 384\n  removed: function (subscriptionHandle, collectionName, id) {                                                         // 385\n    var self = this;                                                                                                   // 386\n    var view = self.getCollectionView(collectionName);                                                                 // 387\n    view.removed(subscriptionHandle, id);                                                                              // 388\n    if (view.isEmpty()) {                                                                                              // 389\n      delete self.collectionViews[collectionName];                                                                     // 390\n    }                                                                                                                  // 391\n  },                                                                                                                   // 392\n                                                                                                                       // 393\n  changed: function (subscriptionHandle, collectionName, id, fields) {                                                 // 394\n    var self = this;                                                                                                   // 395\n    var view = self.getCollectionView(collectionName);                                                                 // 396\n    view.changed(subscriptionHandle, id, fields);                                                                      // 397\n  },                                                                                                                   // 398\n                                                                                                                       // 399\n  startUniversalSubs: function () {                                                                                    // 400\n    var self = this;                                                                                                   // 401\n    // Make a shallow copy of the set of universal handlers and start them. If                                         // 402\n    // additional universal publishers start while we're running them (due to                                          // 403\n    // yielding), they will run separately as part of Server.publish.                                                  // 404\n    var handlers = _.clone(self.server.universal_publish_handlers);                                                    // 405\n    _.each(handlers, function (handler) {                                                                              // 406\n      self._startSubscription(handler);                                                                                // 407\n    });                                                                                                                // 408\n  },                                                                                                                   // 409\n                                                                                                                       // 410\n  // Destroy this session and unregister it at the server.                                                             // 411\n  close: function () {                                                                                                 // 412\n    var self = this;                                                                                                   // 413\n                                                                                                                       // 414\n    // Destroy this session, even if it's not registered at the                                                        // 415\n    // server. Stop all processing and tear everything down. If a socket                                               // 416\n    // was attached, close it.                                                                                         // 417\n                                                                                                                       // 418\n    // Already destroyed.                                                                                              // 419\n    if (! self.inQueue)                                                                                                // 420\n      return;                                                                                                          // 421\n                                                                                                                       // 422\n    // Drop the merge box data immediately.                                                                            // 423\n    self.inQueue = null;                                                                                               // 424\n    self.collectionViews = {};                                                                                         // 425\n                                                                                                                       // 426\n    if (self.heartbeat) {                                                                                              // 427\n      self.heartbeat.stop();                                                                                           // 428\n      self.heartbeat = null;                                                                                           // 429\n    }                                                                                                                  // 430\n                                                                                                                       // 431\n    if (self.socket) {                                                                                                 // 432\n      self.socket.close();                                                                                             // 433\n      self.socket._meteorSession = null;                                                                               // 434\n    }                                                                                                                  // 435\n                                                                                                                       // 436\n    Package.facts && Package.facts.Facts.incrementServerFact(                                                          // 437\n      \"livedata\", \"sessions\", -1);                                                                                     // 438\n                                                                                                                       // 439\n    Meteor.defer(function () {                                                                                         // 440\n      // stop callbacks can yield, so we defer this on close.                                                          // 441\n      // sub._isDeactivated() detects that we set inQueue to null and                                                  // 442\n      // treats it as semi-deactivated (it will ignore incoming callbacks, etc).                                       // 443\n      self._deactivateAllSubscriptions();                                                                              // 444\n                                                                                                                       // 445\n      // Defer calling the close callbacks, so that the caller closing                                                 // 446\n      // the session isn't waiting for all the callbacks to complete.                                                  // 447\n      _.each(self._closeCallbacks, function (callback) {                                                               // 448\n        callback();                                                                                                    // 449\n      });                                                                                                              // 450\n    });                                                                                                                // 451\n                                                                                                                       // 452\n    // Unregister the session.                                                                                         // 453\n    self.server._removeSession(self);                                                                                  // 454\n  },                                                                                                                   // 455\n                                                                                                                       // 456\n  // Send a message (doing nothing if no socket is connected right now.)                                               // 457\n  // It should be a JSON object (it will be stringified.)                                                              // 458\n  send: function (msg) {                                                                                               // 459\n    var self = this;                                                                                                   // 460\n    if (self.socket) {                                                                                                 // 461\n      if (Meteor._printSentDDP)                                                                                        // 462\n        Meteor._debug(\"Sent DDP\", stringifyDDP(msg));                                                                  // 463\n      self.socket.send(stringifyDDP(msg));                                                                             // 464\n    }                                                                                                                  // 465\n  },                                                                                                                   // 466\n                                                                                                                       // 467\n  // Send a connection error.                                                                                          // 468\n  sendError: function (reason, offendingMessage) {                                                                     // 469\n    var self = this;                                                                                                   // 470\n    var msg = {msg: 'error', reason: reason};                                                                          // 471\n    if (offendingMessage)                                                                                              // 472\n      msg.offendingMessage = offendingMessage;                                                                         // 473\n    self.send(msg);                                                                                                    // 474\n  },                                                                                                                   // 475\n                                                                                                                       // 476\n  // Process 'msg' as an incoming message. (But as a guard against                                                     // 477\n  // race conditions during reconnection, ignore the message if                                                        // 478\n  // 'socket' is not the currently connected socket.)                                                                  // 479\n  //                                                                                                                   // 480\n  // We run the messages from the client one at a time, in the order                                                   // 481\n  // given by the client. The message handler is passed an idempotent                                                  // 482\n  // function 'unblock' which it may call to allow other messages to                                                   // 483\n  // begin running in parallel in another fiber (for example, a method                                                 // 484\n  // that wants to yield.) Otherwise, it is automatically unblocked                                                    // 485\n  // when it returns.                                                                                                  // 486\n  //                                                                                                                   // 487\n  // Actually, we don't have to 'totally order' the messages in this                                                   // 488\n  // way, but it's the easiest thing that's correct. (unsub needs to                                                   // 489\n  // be ordered against sub, methods need to be ordered against each                                                   // 490\n  // other.)                                                                                                           // 491\n  processMessage: function (msg_in) {                                                                                  // 492\n    var self = this;                                                                                                   // 493\n    if (!self.inQueue) // we have been destroyed.                                                                      // 494\n      return;                                                                                                          // 495\n                                                                                                                       // 496\n    // Respond to ping and pong messages immediately without queuing.                                                  // 497\n    // If the negotiated DDP version is \"pre1\" which didn't support                                                    // 498\n    // pings, preserve the \"pre1\" behavior of responding with a \"bad                                                   // 499\n    // request\" for the unknown messages.                                                                              // 500\n    //                                                                                                                 // 501\n    // Fibers are needed because heartbeat uses Meteor.setTimeout, which                                               // 502\n    // needs a Fiber. We could actually use regular setTimeout and avoid                                               // 503\n    // these new fibers, but it is easier to just make everything use                                                  // 504\n    // Meteor.setTimeout and not think too hard.                                                                       // 505\n    if (self.version !== 'pre1' && msg_in.msg === 'ping') {                                                            // 506\n      if (self._respondToPings)                                                                                        // 507\n        self.send({msg: \"pong\", id: msg_in.id});                                                                       // 508\n      if (self.heartbeat)                                                                                              // 509\n        Fiber(function () {                                                                                            // 510\n          self.heartbeat.pingReceived();                                                                               // 511\n        }).run();                                                                                                      // 512\n      return;                                                                                                          // 513\n    }                                                                                                                  // 514\n    if (self.version !== 'pre1' && msg_in.msg === 'pong') {                                                            // 515\n      if (self.heartbeat)                                                                                              // 516\n        Fiber(function () {                                                                                            // 517\n          self.heartbeat.pongReceived();                                                                               // 518\n        }).run();                                                                                                      // 519\n      return;                                                                                                          // 520\n    }                                                                                                                  // 521\n                                                                                                                       // 522\n    self.inQueue.push(msg_in);                                                                                         // 523\n    if (self.workerRunning)                                                                                            // 524\n      return;                                                                                                          // 525\n    self.workerRunning = true;                                                                                         // 526\n                                                                                                                       // 527\n    var processNext = function () {                                                                                    // 528\n      var msg = self.inQueue && self.inQueue.shift();                                                                  // 529\n      if (!msg) {                                                                                                      // 530\n        self.workerRunning = false;                                                                                    // 531\n        return;                                                                                                        // 532\n      }                                                                                                                // 533\n                                                                                                                       // 534\n      Fiber(function () {                                                                                              // 535\n        var blocked = true;                                                                                            // 536\n                                                                                                                       // 537\n        var unblock = function () {                                                                                    // 538\n          if (!blocked)                                                                                                // 539\n            return; // idempotent                                                                                      // 540\n          blocked = false;                                                                                             // 541\n          processNext();                                                                                               // 542\n        };                                                                                                             // 543\n                                                                                                                       // 544\n        if (_.has(self.protocol_handlers, msg.msg))                                                                    // 545\n          self.protocol_handlers[msg.msg].call(self, msg, unblock);                                                    // 546\n        else                                                                                                           // 547\n          self.sendError('Bad request', msg);                                                                          // 548\n        unblock(); // in case the handler didn't already do it                                                         // 549\n      }).run();                                                                                                        // 550\n    };                                                                                                                 // 551\n                                                                                                                       // 552\n    processNext();                                                                                                     // 553\n  },                                                                                                                   // 554\n                                                                                                                       // 555\n  protocol_handlers: {                                                                                                 // 556\n    sub: function (msg) {                                                                                              // 557\n      var self = this;                                                                                                 // 558\n                                                                                                                       // 559\n      // reject malformed messages                                                                                     // 560\n      if (typeof (msg.id) !== \"string\" ||                                                                              // 561\n          typeof (msg.name) !== \"string\" ||                                                                            // 562\n          (('params' in msg) && !(msg.params instanceof Array))) {                                                     // 563\n        self.sendError(\"Malformed subscription\", msg);                                                                 // 564\n        return;                                                                                                        // 565\n      }                                                                                                                // 566\n                                                                                                                       // 567\n      if (!self.server.publish_handlers[msg.name]) {                                                                   // 568\n        self.send({                                                                                                    // 569\n          msg: 'nosub', id: msg.id,                                                                                    // 570\n          error: new Meteor.Error(404, \"Subscription not found\")});                                                    // 571\n        return;                                                                                                        // 572\n      }                                                                                                                // 573\n                                                                                                                       // 574\n      if (_.has(self._namedSubs, msg.id))                                                                              // 575\n        // subs are idempotent, or rather, they are ignored if a sub                                                   // 576\n        // with that id already exists. this is important during                                                       // 577\n        // reconnect.                                                                                                  // 578\n        return;                                                                                                        // 579\n                                                                                                                       // 580\n      var handler = self.server.publish_handlers[msg.name];                                                            // 581\n      self._startSubscription(handler, msg.id, msg.params, msg.name);                                                  // 582\n                                                                                                                       // 583\n    },                                                                                                                 // 584\n                                                                                                                       // 585\n    unsub: function (msg) {                                                                                            // 586\n      var self = this;                                                                                                 // 587\n                                                                                                                       // 588\n      self._stopSubscription(msg.id);                                                                                  // 589\n    },                                                                                                                 // 590\n                                                                                                                       // 591\n    method: function (msg, unblock) {                                                                                  // 592\n      var self = this;                                                                                                 // 593\n                                                                                                                       // 594\n      // reject malformed messages                                                                                     // 595\n      // For now, we silently ignore unknown attributes,                                                               // 596\n      // for forwards compatibility.                                                                                   // 597\n      if (typeof (msg.id) !== \"string\" ||                                                                              // 598\n          typeof (msg.method) !== \"string\" ||                                                                          // 599\n          (('params' in msg) && !(msg.params instanceof Array)) ||                                                     // 600\n          (('randomSeed' in msg) && (typeof msg.randomSeed !== \"string\"))) {                                           // 601\n        self.sendError(\"Malformed method invocation\", msg);                                                            // 602\n        return;                                                                                                        // 603\n      }                                                                                                                // 604\n                                                                                                                       // 605\n      var randomSeed = msg.randomSeed || null;                                                                         // 606\n                                                                                                                       // 607\n      // set up to mark the method as satisfied once all observers                                                     // 608\n      // (and subscriptions) have reacted to any writes that were                                                      // 609\n      // done.                                                                                                         // 610\n      var fence = new DDPServer._WriteFence;                                                                           // 611\n      fence.onAllCommitted(function () {                                                                               // 612\n        // Retire the fence so that future writes are allowed.                                                         // 613\n        // This means that callbacks like timers are free to use                                                       // 614\n        // the fence, and if they fire before it's armed (for                                                          // 615\n        // example, because the method waits for them) their                                                           // 616\n        // writes will be included in the fence.                                                                       // 617\n        fence.retire();                                                                                                // 618\n        self.send({                                                                                                    // 619\n          msg: 'updated', methods: [msg.id]});                                                                         // 620\n      });                                                                                                              // 621\n                                                                                                                       // 622\n      // find the handler                                                                                              // 623\n      var handler = self.server.method_handlers[msg.method];                                                           // 624\n      if (!handler) {                                                                                                  // 625\n        self.send({                                                                                                    // 626\n          msg: 'result', id: msg.id,                                                                                   // 627\n          error: new Meteor.Error(404, \"Method not found\")});                                                          // 628\n        fence.arm();                                                                                                   // 629\n        return;                                                                                                        // 630\n      }                                                                                                                // 631\n                                                                                                                       // 632\n      var setUserId = function(userId) {                                                                               // 633\n        self._setUserId(userId);                                                                                       // 634\n      };                                                                                                               // 635\n                                                                                                                       // 636\n      var invocation = new MethodInvocation({                                                                          // 637\n        isSimulation: false,                                                                                           // 638\n        userId: self.userId,                                                                                           // 639\n        setUserId: setUserId,                                                                                          // 640\n        unblock: unblock,                                                                                              // 641\n        connection: self.connectionHandle,                                                                             // 642\n        randomSeed: randomSeed                                                                                         // 643\n      });                                                                                                              // 644\n      try {                                                                                                            // 645\n        var result = DDPServer._CurrentWriteFence.withValue(fence, function () {                                       // 646\n          return DDP._CurrentInvocation.withValue(invocation, function () {                                            // 647\n            return maybeAuditArgumentChecks(                                                                           // 648\n              handler, invocation, msg.params, \"call to '\" + msg.method + \"'\");                                        // 649\n          });                                                                                                          // 650\n        });                                                                                                            // 651\n      } catch (e) {                                                                                                    // 652\n        var exception = e;                                                                                             // 653\n      }                                                                                                                // 654\n                                                                                                                       // 655\n      fence.arm(); // we're done adding writes to the fence                                                            // 656\n      unblock(); // unblock, if the method hasn't done it already                                                      // 657\n                                                                                                                       // 658\n      exception = wrapInternalException(                                                                               // 659\n        exception, \"while invoking method '\" + msg.method + \"'\");                                                      // 660\n                                                                                                                       // 661\n      // send response and add to cache                                                                                // 662\n      var payload =                                                                                                    // 663\n        exception ? {error: exception} : (result !== undefined ?                                                       // 664\n                                          {result: result} : {});                                                      // 665\n      self.send(_.extend({msg: 'result', id: msg.id}, payload));                                                       // 666\n    }                                                                                                                  // 667\n  },                                                                                                                   // 668\n                                                                                                                       // 669\n  _eachSub: function (f) {                                                                                             // 670\n    var self = this;                                                                                                   // 671\n    _.each(self._namedSubs, f);                                                                                        // 672\n    _.each(self._universalSubs, f);                                                                                    // 673\n  },                                                                                                                   // 674\n                                                                                                                       // 675\n  _diffCollectionViews: function (beforeCVs) {                                                                         // 676\n    var self = this;                                                                                                   // 677\n    LocalCollection._diffObjects(beforeCVs, self.collectionViews, {                                                    // 678\n      both: function (collectionName, leftValue, rightValue) {                                                         // 679\n        rightValue.diff(leftValue);                                                                                    // 680\n      },                                                                                                               // 681\n      rightOnly: function (collectionName, rightValue) {                                                               // 682\n        _.each(rightValue.documents, function (docView, id) {                                                          // 683\n          self.sendAdded(collectionName, id, docView.getFields());                                                     // 684\n        });                                                                                                            // 685\n      },                                                                                                               // 686\n      leftOnly: function (collectionName, leftValue) {                                                                 // 687\n        _.each(leftValue.documents, function (doc, id) {                                                               // 688\n          self.sendRemoved(collectionName, id);                                                                        // 689\n        });                                                                                                            // 690\n      }                                                                                                                // 691\n    });                                                                                                                // 692\n  },                                                                                                                   // 693\n                                                                                                                       // 694\n  // Sets the current user id in all appropriate contexts and reruns                                                   // 695\n  // all subscriptions                                                                                                 // 696\n  _setUserId: function(userId) {                                                                                       // 697\n    var self = this;                                                                                                   // 698\n                                                                                                                       // 699\n    if (userId !== null && typeof userId !== \"string\")                                                                 // 700\n      throw new Error(\"setUserId must be called on string or null, not \" +                                             // 701\n                      typeof userId);                                                                                  // 702\n                                                                                                                       // 703\n    // Prevent newly-created universal subscriptions from being added to our                                           // 704\n    // session; they will be found below when we call startUniversalSubs.                                              // 705\n    //                                                                                                                 // 706\n    // (We don't have to worry about named subscriptions, because we only add                                          // 707\n    // them when we process a 'sub' message. We are currently processing a                                             // 708\n    // 'method' message, and the method did not unblock, because it is illegal                                         // 709\n    // to call setUserId after unblock. Thus we cannot be concurrently adding a                                        // 710\n    // new named subscription.)                                                                                        // 711\n    self._dontStartNewUniversalSubs = true;                                                                            // 712\n                                                                                                                       // 713\n    // Prevent current subs from updating our collectionViews and call their                                           // 714\n    // stop callbacks. This may yield.                                                                                 // 715\n    self._eachSub(function (sub) {                                                                                     // 716\n      sub._deactivate();                                                                                               // 717\n    });                                                                                                                // 718\n                                                                                                                       // 719\n    // All subs should now be deactivated. Stop sending messages to the client,                                        // 720\n    // save the state of the published collections, reset to an empty view, and                                        // 721\n    // update the userId.                                                                                              // 722\n    self._isSending = false;                                                                                           // 723\n    var beforeCVs = self.collectionViews;                                                                              // 724\n    self.collectionViews = {};                                                                                         // 725\n    self.userId = userId;                                                                                              // 726\n                                                                                                                       // 727\n    // Save the old named subs, and reset to having no subscriptions.                                                  // 728\n    var oldNamedSubs = self._namedSubs;                                                                                // 729\n    self._namedSubs = {};                                                                                              // 730\n    self._universalSubs = [];                                                                                          // 731\n                                                                                                                       // 732\n    _.each(oldNamedSubs, function (sub, subscriptionId) {                                                              // 733\n      self._namedSubs[subscriptionId] = sub._recreate();                                                               // 734\n      // nb: if the handler throws or calls this.error(), it will in fact                                              // 735\n      // immediately send its 'nosub'. This is OK, though.                                                             // 736\n      self._namedSubs[subscriptionId]._runHandler();                                                                   // 737\n    });                                                                                                                // 738\n                                                                                                                       // 739\n    // Allow newly-created universal subs to be started on our connection in                                           // 740\n    // parallel with the ones we're spinning up here, and spin up universal                                            // 741\n    // subs.                                                                                                           // 742\n    self._dontStartNewUniversalSubs = false;                                                                           // 743\n    self.startUniversalSubs();                                                                                         // 744\n                                                                                                                       // 745\n    // Start sending messages again, beginning with the diff from the previous                                         // 746\n    // state of the world to the current state. No yields are allowed during                                           // 747\n    // this diff, so that other changes cannot interleave.                                                             // 748\n    Meteor._noYieldsAllowed(function () {                                                                              // 749\n      self._isSending = true;                                                                                          // 750\n      self._diffCollectionViews(beforeCVs);                                                                            // 751\n      if (!_.isEmpty(self._pendingReady)) {                                                                            // 752\n        self.sendReady(self._pendingReady);                                                                            // 753\n        self._pendingReady = [];                                                                                       // 754\n      }                                                                                                                // 755\n    });                                                                                                                // 756\n  },                                                                                                                   // 757\n                                                                                                                       // 758\n  _startSubscription: function (handler, subId, params, name) {                                                        // 759\n    var self = this;                                                                                                   // 760\n                                                                                                                       // 761\n    var sub = new Subscription(                                                                                        // 762\n      self, handler, subId, params, name);                                                                             // 763\n    if (subId)                                                                                                         // 764\n      self._namedSubs[subId] = sub;                                                                                    // 765\n    else                                                                                                               // 766\n      self._universalSubs.push(sub);                                                                                   // 767\n                                                                                                                       // 768\n    sub._runHandler();                                                                                                 // 769\n  },                                                                                                                   // 770\n                                                                                                                       // 771\n  // tear down specified subscription                                                                                  // 772\n  _stopSubscription: function (subId, error) {                                                                         // 773\n    var self = this;                                                                                                   // 774\n                                                                                                                       // 775\n    var subName = null;                                                                                                // 776\n                                                                                                                       // 777\n    if (subId && self._namedSubs[subId]) {                                                                             // 778\n      subName = self._namedSubs[subId]._name;                                                                          // 779\n      self._namedSubs[subId]._removeAllDocuments();                                                                    // 780\n      self._namedSubs[subId]._deactivate();                                                                            // 781\n      delete self._namedSubs[subId];                                                                                   // 782\n    }                                                                                                                  // 783\n                                                                                                                       // 784\n    var response = {msg: 'nosub', id: subId};                                                                          // 785\n                                                                                                                       // 786\n    if (error) {                                                                                                       // 787\n      response.error = wrapInternalException(                                                                          // 788\n        error,                                                                                                         // 789\n        subName ? (\"from sub \" + subName + \" id \" + subId)                                                             // 790\n          : (\"from sub id \" + subId));                                                                                 // 791\n    }                                                                                                                  // 792\n                                                                                                                       // 793\n    self.send(response);                                                                                               // 794\n  },                                                                                                                   // 795\n                                                                                                                       // 796\n  // tear down all subscriptions. Note that this does NOT send removed or nosub                                        // 797\n  // messages, since we assume the client is gone.                                                                     // 798\n  _deactivateAllSubscriptions: function () {                                                                           // 799\n    var self = this;                                                                                                   // 800\n                                                                                                                       // 801\n    _.each(self._namedSubs, function (sub, id) {                                                                       // 802\n      sub._deactivate();                                                                                               // 803\n    });                                                                                                                // 804\n    self._namedSubs = {};                                                                                              // 805\n                                                                                                                       // 806\n    _.each(self._universalSubs, function (sub) {                                                                       // 807\n      sub._deactivate();                                                                                               // 808\n    });                                                                                                                // 809\n    self._universalSubs = [];                                                                                          // 810\n  },                                                                                                                   // 811\n                                                                                                                       // 812\n  // Determine the remote client's IP address, based on the                                                            // 813\n  // HTTP_FORWARDED_COUNT environment variable representing how many                                                   // 814\n  // proxies the server is behind.                                                                                     // 815\n  _clientAddress: function () {                                                                                        // 816\n    var self = this;                                                                                                   // 817\n                                                                                                                       // 818\n    // For the reported client address for a connection to be correct,                                                 // 819\n    // the developer must set the HTTP_FORWARDED_COUNT environment                                                     // 820\n    // variable to an integer representing the number of hops they                                                     // 821\n    // expect in the `x-forwarded-for` header. E.g., set to \"1\" if the                                                 // 822\n    // server is behind one proxy.                                                                                     // 823\n    //                                                                                                                 // 824\n    // This could be computed once at startup instead of every time.                                                   // 825\n    var httpForwardedCount = parseInt(process.env['HTTP_FORWARDED_COUNT']) || 0;                                       // 826\n                                                                                                                       // 827\n    if (httpForwardedCount === 0)                                                                                      // 828\n      return self.socket.remoteAddress;                                                                                // 829\n                                                                                                                       // 830\n    var forwardedFor = self.socket.headers[\"x-forwarded-for\"];                                                         // 831\n    if (! _.isString(forwardedFor))                                                                                    // 832\n      return null;                                                                                                     // 833\n    forwardedFor = forwardedFor.trim().split(/\\s*,\\s*/);                                                               // 834\n                                                                                                                       // 835\n    // Typically the first value in the `x-forwarded-for` header is                                                    // 836\n    // the original IP address of the client connecting to the first                                                   // 837\n    // proxy.  However, the end user can easily spoof the header, in                                                   // 838\n    // which case the first value(s) will be the fake IP address from                                                  // 839\n    // the user pretending to be a proxy reporting the original IP                                                     // 840\n    // address value.  By counting HTTP_FORWARDED_COUNT back from the                                                  // 841\n    // end of the list, we ensure that we get the IP address being                                                     // 842\n    // reported by *our* first proxy.                                                                                  // 843\n                                                                                                                       // 844\n    if (httpForwardedCount < 0 || httpForwardedCount > forwardedFor.length)                                            // 845\n      return null;                                                                                                     // 846\n                                                                                                                       // 847\n    return forwardedFor[forwardedFor.length - httpForwardedCount];                                                     // 848\n  }                                                                                                                    // 849\n});                                                                                                                    // 850\n                                                                                                                       // 851\n/******************************************************************************/                                       // 852\n/* Subscription                                                               */                                       // 853\n/******************************************************************************/                                       // 854\n                                                                                                                       // 855\n// ctor for a sub handle: the input to each publish function                                                           // 856\n                                                                                                                       // 857\n// Instance name is this because it's usually referred to as this inside a                                             // 858\n// publish                                                                                                             // 859\n/**                                                                                                                    // 860\n * @summary The server's side of a subscription                                                                        // 861\n * @class Subscription                                                                                                 // 862\n * @instanceName this                                                                                                  // 863\n */                                                                                                                    // 864\nvar Subscription = function (                                                                                          // 865\n    session, handler, subscriptionId, params, name) {                                                                  // 866\n  var self = this;                                                                                                     // 867\n  self._session = session; // type is Session                                                                          // 868\n                                                                                                                       // 869\n  /**                                                                                                                  // 870\n   * @summary Access inside the publish function. The incoming [connection](#meteor_onconnection) for this subscription.\n   * @locus Server                                                                                                     // 872\n   * @name  connection                                                                                                 // 873\n   * @memberOf Subscription                                                                                            // 874\n   * @instance                                                                                                         // 875\n   */                                                                                                                  // 876\n  self.connection = session.connectionHandle; // public API object                                                     // 877\n                                                                                                                       // 878\n  self._handler = handler;                                                                                             // 879\n                                                                                                                       // 880\n  // my subscription ID (generated by client, undefined for universal subs).                                           // 881\n  self._subscriptionId = subscriptionId;                                                                               // 882\n  // undefined for universal subs                                                                                      // 883\n  self._name = name;                                                                                                   // 884\n                                                                                                                       // 885\n  self._params = params || [];                                                                                         // 886\n                                                                                                                       // 887\n  // Only named subscriptions have IDs, but we need some sort of string                                                // 888\n  // internally to keep track of all subscriptions inside                                                              // 889\n  // SessionDocumentViews. We use this subscriptionHandle for that.                                                    // 890\n  if (self._subscriptionId) {                                                                                          // 891\n    self._subscriptionHandle = 'N' + self._subscriptionId;                                                             // 892\n  } else {                                                                                                             // 893\n    self._subscriptionHandle = 'U' + Random.id();                                                                      // 894\n  }                                                                                                                    // 895\n                                                                                                                       // 896\n  // has _deactivate been called?                                                                                      // 897\n  self._deactivated = false;                                                                                           // 898\n                                                                                                                       // 899\n  // stop callbacks to g/c this sub.  called w/ zero arguments.                                                        // 900\n  self._stopCallbacks = [];                                                                                            // 901\n                                                                                                                       // 902\n  // the set of (collection, documentid) that this subscription has                                                    // 903\n  // an opinion about                                                                                                  // 904\n  self._documents = {};                                                                                                // 905\n                                                                                                                       // 906\n  // remember if we are ready.                                                                                         // 907\n  self._ready = false;                                                                                                 // 908\n                                                                                                                       // 909\n  // Part of the public API: the user of this sub.                                                                     // 910\n                                                                                                                       // 911\n  /**                                                                                                                  // 912\n   * @summary Access inside the publish function. The id of the logged-in user, or `null` if no user is logged in.     // 913\n   * @locus Server                                                                                                     // 914\n   * @memberOf Subscription                                                                                            // 915\n   * @name  userId                                                                                                     // 916\n   * @instance                                                                                                         // 917\n   */                                                                                                                  // 918\n  self.userId = session.userId;                                                                                        // 919\n                                                                                                                       // 920\n  // For now, the id filter is going to default to                                                                     // 921\n  // the to/from DDP methods on LocalCollection, to                                                                    // 922\n  // specifically deal with mongo/minimongo ObjectIds.                                                                 // 923\n                                                                                                                       // 924\n  // Later, you will be able to make this be \"raw\"                                                                     // 925\n  // if you want to publish a collection that you know                                                                 // 926\n  // just has strings for keys and no funny business, to                                                               // 927\n  // a ddp consumer that isn't minimongo                                                                               // 928\n                                                                                                                       // 929\n  self._idFilter = {                                                                                                   // 930\n    idStringify: LocalCollection._idStringify,                                                                         // 931\n    idParse: LocalCollection._idParse                                                                                  // 932\n  };                                                                                                                   // 933\n                                                                                                                       // 934\n  Package.facts && Package.facts.Facts.incrementServerFact(                                                            // 935\n    \"livedata\", \"subscriptions\", 1);                                                                                   // 936\n};                                                                                                                     // 937\n                                                                                                                       // 938\n_.extend(Subscription.prototype, {                                                                                     // 939\n  _runHandler: function () {                                                                                           // 940\n    // XXX should we unblock() here? Either before running the publish                                                 // 941\n    // function, or before running _publishCursor.                                                                     // 942\n    //                                                                                                                 // 943\n    // Right now, each publish function blocks all future publishes and                                                // 944\n    // methods waiting on data from Mongo (or whatever else the function                                               // 945\n    // blocks on). This probably slows page load in common cases.                                                      // 946\n                                                                                                                       // 947\n    var self = this;                                                                                                   // 948\n    try {                                                                                                              // 949\n      var res = maybeAuditArgumentChecks(                                                                              // 950\n        self._handler, self, EJSON.clone(self._params),                                                                // 951\n        // It's OK that this would look weird for universal subscriptions,                                             // 952\n        // because they have no arguments so there can never be an                                                     // 953\n        // audit-argument-checks failure.                                                                              // 954\n        \"publisher '\" + self._name + \"'\");                                                                             // 955\n    } catch (e) {                                                                                                      // 956\n      self.error(e);                                                                                                   // 957\n      return;                                                                                                          // 958\n    }                                                                                                                  // 959\n                                                                                                                       // 960\n    // Did the handler call this.error or this.stop?                                                                   // 961\n    if (self._isDeactivated())                                                                                         // 962\n      return;                                                                                                          // 963\n                                                                                                                       // 964\n    // SPECIAL CASE: Instead of writing their own callbacks that invoke                                                // 965\n    // this.added/changed/ready/etc, the user can just return a collection                                             // 966\n    // cursor or array of cursors from the publish function; we call their                                             // 967\n    // _publishCursor method which starts observing the cursor and publishes the                                       // 968\n    // results. Note that _publishCursor does NOT call ready().                                                        // 969\n    //                                                                                                                 // 970\n    // XXX This uses an undocumented interface which only the Mongo cursor                                             // 971\n    // interface publishes. Should we make this interface public and encourage                                         // 972\n    // users to implement it themselves? Arguably, it's unnecessary; users can                                         // 973\n    // already write their own functions like                                                                          // 974\n    //   var publishMyReactiveThingy = function (name, handler) {                                                      // 975\n    //     Meteor.publish(name, function () {                                                                          // 976\n    //       var reactiveThingy = handler();                                                                           // 977\n    //       reactiveThingy.publishMe();                                                                               // 978\n    //     });                                                                                                         // 979\n    //   };                                                                                                            // 980\n    var isCursor = function (c) {                                                                                      // 981\n      return c && c._publishCursor;                                                                                    // 982\n    };                                                                                                                 // 983\n    if (isCursor(res)) {                                                                                               // 984\n      try {                                                                                                            // 985\n        res._publishCursor(self);                                                                                      // 986\n      } catch (e) {                                                                                                    // 987\n        self.error(e);                                                                                                 // 988\n        return;                                                                                                        // 989\n      }                                                                                                                // 990\n      // _publishCursor only returns after the initial added callbacks have run.                                       // 991\n      // mark subscription as ready.                                                                                   // 992\n      self.ready();                                                                                                    // 993\n    } else if (_.isArray(res)) {                                                                                       // 994\n      // check all the elements are cursors                                                                            // 995\n      if (! _.all(res, isCursor)) {                                                                                    // 996\n        self.error(new Error(\"Publish function returned an array of non-Cursors\"));                                    // 997\n        return;                                                                                                        // 998\n      }                                                                                                                // 999\n      // find duplicate collection names                                                                               // 1000\n      // XXX we should support overlapping cursors, but that would require the                                         // 1001\n      // merge box to allow overlap within a subscription                                                              // 1002\n      var collectionNames = {};                                                                                        // 1003\n      for (var i = 0; i < res.length; ++i) {                                                                           // 1004\n        var collectionName = res[i]._getCollectionName();                                                              // 1005\n        if (_.has(collectionNames, collectionName)) {                                                                  // 1006\n          self.error(new Error(                                                                                        // 1007\n            \"Publish function returned multiple cursors for collection \" +                                             // 1008\n              collectionName));                                                                                        // 1009\n          return;                                                                                                      // 1010\n        }                                                                                                              // 1011\n        collectionNames[collectionName] = true;                                                                        // 1012\n      };                                                                                                               // 1013\n                                                                                                                       // 1014\n      try {                                                                                                            // 1015\n        _.each(res, function (cur) {                                                                                   // 1016\n          cur._publishCursor(self);                                                                                    // 1017\n        });                                                                                                            // 1018\n      } catch (e) {                                                                                                    // 1019\n        self.error(e);                                                                                                 // 1020\n        return;                                                                                                        // 1021\n      }                                                                                                                // 1022\n      self.ready();                                                                                                    // 1023\n    } else if (res) {                                                                                                  // 1024\n      // truthy values other than cursors or arrays are probably a                                                     // 1025\n      // user mistake (possible returning a Mongo document via, say,                                                   // 1026\n      // `coll.findOne()`).                                                                                            // 1027\n      self.error(new Error(\"Publish function can only return a Cursor or \"                                             // 1028\n                           + \"an array of Cursors\"));                                                                  // 1029\n    }                                                                                                                  // 1030\n  },                                                                                                                   // 1031\n                                                                                                                       // 1032\n  // This calls all stop callbacks and prevents the handler from updating any                                          // 1033\n  // SessionCollectionViews further. It's used when the user unsubscribes or                                           // 1034\n  // disconnects, as well as during setUserId re-runs. It does *NOT* send                                              // 1035\n  // removed messages for the published objects; if that is necessary, call                                            // 1036\n  // _removeAllDocuments first.                                                                                        // 1037\n  _deactivate: function() {                                                                                            // 1038\n    var self = this;                                                                                                   // 1039\n    if (self._deactivated)                                                                                             // 1040\n      return;                                                                                                          // 1041\n    self._deactivated = true;                                                                                          // 1042\n    self._callStopCallbacks();                                                                                         // 1043\n    Package.facts && Package.facts.Facts.incrementServerFact(                                                          // 1044\n      \"livedata\", \"subscriptions\", -1);                                                                                // 1045\n  },                                                                                                                   // 1046\n                                                                                                                       // 1047\n  _callStopCallbacks: function () {                                                                                    // 1048\n    var self = this;                                                                                                   // 1049\n    // tell listeners, so they can clean up                                                                            // 1050\n    var callbacks = self._stopCallbacks;                                                                               // 1051\n    self._stopCallbacks = [];                                                                                          // 1052\n    _.each(callbacks, function (callback) {                                                                            // 1053\n      callback();                                                                                                      // 1054\n    });                                                                                                                // 1055\n  },                                                                                                                   // 1056\n                                                                                                                       // 1057\n  // Send remove messages for every document.                                                                          // 1058\n  _removeAllDocuments: function () {                                                                                   // 1059\n    var self = this;                                                                                                   // 1060\n    Meteor._noYieldsAllowed(function () {                                                                              // 1061\n      _.each(self._documents, function(collectionDocs, collectionName) {                                               // 1062\n        // Iterate over _.keys instead of the dictionary itself, since we'll be                                        // 1063\n        // mutating it.                                                                                                // 1064\n        _.each(_.keys(collectionDocs), function (strId) {                                                              // 1065\n          self.removed(collectionName, self._idFilter.idParse(strId));                                                 // 1066\n        });                                                                                                            // 1067\n      });                                                                                                              // 1068\n    });                                                                                                                // 1069\n  },                                                                                                                   // 1070\n                                                                                                                       // 1071\n  // Returns a new Subscription for the same session with the same                                                     // 1072\n  // initial creation parameters. This isn't a clone: it doesn't have                                                  // 1073\n  // the same _documents cache, stopped state or callbacks; may have a                                                 // 1074\n  // different _subscriptionHandle, and gets its userId from the                                                       // 1075\n  // session, not from this object.                                                                                    // 1076\n  _recreate: function () {                                                                                             // 1077\n    var self = this;                                                                                                   // 1078\n    return new Subscription(                                                                                           // 1079\n      self._session, self._handler, self._subscriptionId, self._params,                                                // 1080\n      self._name);                                                                                                     // 1081\n  },                                                                                                                   // 1082\n                                                                                                                       // 1083\n  /**                                                                                                                  // 1084\n   * @summary Call inside the publish function.  Stops this client's subscription, triggering a call on the client to the `onStop` callback passed to [`Meteor.subscribe`](#meteor_subscribe), if any. If `error` is not a [`Meteor.Error`](#meteor_error), it will be [sanitized](#meteor_error).\n   * @locus Server                                                                                                     // 1086\n   * @param {Error} error The error to pass to the client.                                                             // 1087\n   * @instance                                                                                                         // 1088\n   * @memberOf Subscription                                                                                            // 1089\n   */                                                                                                                  // 1090\n  error: function (error) {                                                                                            // 1091\n    var self = this;                                                                                                   // 1092\n    if (self._isDeactivated())                                                                                         // 1093\n      return;                                                                                                          // 1094\n    self._session._stopSubscription(self._subscriptionId, error);                                                      // 1095\n  },                                                                                                                   // 1096\n                                                                                                                       // 1097\n  // Note that while our DDP client will notice that you've called stop() on the                                       // 1098\n  // server (and clean up its _subscriptions table) we don't actually provide a                                        // 1099\n  // mechanism for an app to notice this (the subscribe onError callback only                                          // 1100\n  // triggers if there is an error).                                                                                   // 1101\n                                                                                                                       // 1102\n  /**                                                                                                                  // 1103\n   * @summary Call inside the publish function.  Stops this client's subscription and invokes the client's `onStop` callback with no error.\n   * @locus Server                                                                                                     // 1105\n   * @instance                                                                                                         // 1106\n   * @memberOf Subscription                                                                                            // 1107\n   */                                                                                                                  // 1108\n  stop: function () {                                                                                                  // 1109\n    var self = this;                                                                                                   // 1110\n    if (self._isDeactivated())                                                                                         // 1111\n      return;                                                                                                          // 1112\n    self._session._stopSubscription(self._subscriptionId);                                                             // 1113\n  },                                                                                                                   // 1114\n                                                                                                                       // 1115\n  /**                                                                                                                  // 1116\n   * @summary Call inside the publish function.  Registers a callback function to run when the subscription is stopped.\n   * @locus Server                                                                                                     // 1118\n   * @memberOf Subscription                                                                                            // 1119\n   * @instance                                                                                                         // 1120\n   * @param {Function} func The callback function                                                                      // 1121\n   */                                                                                                                  // 1122\n  onStop: function (callback) {                                                                                        // 1123\n    var self = this;                                                                                                   // 1124\n    if (self._isDeactivated())                                                                                         // 1125\n      callback();                                                                                                      // 1126\n    else                                                                                                               // 1127\n      self._stopCallbacks.push(callback);                                                                              // 1128\n  },                                                                                                                   // 1129\n                                                                                                                       // 1130\n  // This returns true if the sub has been deactivated, *OR* if the session was                                        // 1131\n  // destroyed but the deferred call to _deactivateAllSubscriptions hasn't                                             // 1132\n  // happened yet.                                                                                                     // 1133\n  _isDeactivated: function () {                                                                                        // 1134\n    var self = this;                                                                                                   // 1135\n    return self._deactivated || self._session.inQueue === null;                                                        // 1136\n  },                                                                                                                   // 1137\n                                                                                                                       // 1138\n  /**                                                                                                                  // 1139\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been added to the record set.\n   * @locus Server                                                                                                     // 1141\n   * @memberOf Subscription                                                                                            // 1142\n   * @instance                                                                                                         // 1143\n   * @param {String} collection The name of the collection that contains the new document.                             // 1144\n   * @param {String} id The new document's ID.                                                                         // 1145\n   * @param {Object} fields The fields in the new document.  If `_id` is present it is ignored.                        // 1146\n   */                                                                                                                  // 1147\n  added: function (collectionName, id, fields) {                                                                       // 1148\n    var self = this;                                                                                                   // 1149\n    if (self._isDeactivated())                                                                                         // 1150\n      return;                                                                                                          // 1151\n    id = self._idFilter.idStringify(id);                                                                               // 1152\n    Meteor._ensure(self._documents, collectionName)[id] = true;                                                        // 1153\n    self._session.added(self._subscriptionHandle, collectionName, id, fields);                                         // 1154\n  },                                                                                                                   // 1155\n                                                                                                                       // 1156\n  /**                                                                                                                  // 1157\n   * @summary Call inside the publish function.  Informs the subscriber that a document in the record set has been modified.\n   * @locus Server                                                                                                     // 1159\n   * @memberOf Subscription                                                                                            // 1160\n   * @instance                                                                                                         // 1161\n   * @param {String} collection The name of the collection that contains the changed document.                         // 1162\n   * @param {String} id The changed document's ID.                                                                     // 1163\n   * @param {Object} fields The fields in the document that have changed, together with their new values.  If a field is not present in `fields` it was left unchanged; if it is present in `fields` and has a value of `undefined` it was removed from the document.  If `_id` is present it is ignored.\n   */                                                                                                                  // 1165\n  changed: function (collectionName, id, fields) {                                                                     // 1166\n    var self = this;                                                                                                   // 1167\n    if (self._isDeactivated())                                                                                         // 1168\n      return;                                                                                                          // 1169\n    id = self._idFilter.idStringify(id);                                                                               // 1170\n    self._session.changed(self._subscriptionHandle, collectionName, id, fields);                                       // 1171\n  },                                                                                                                   // 1172\n                                                                                                                       // 1173\n  /**                                                                                                                  // 1174\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been removed from the record set.\n   * @locus Server                                                                                                     // 1176\n   * @memberOf Subscription                                                                                            // 1177\n   * @instance                                                                                                         // 1178\n   * @param {String} collection The name of the collection that the document has been removed from.                    // 1179\n   * @param {String} id The ID of the document that has been removed.                                                  // 1180\n   */                                                                                                                  // 1181\n  removed: function (collectionName, id) {                                                                             // 1182\n    var self = this;                                                                                                   // 1183\n    if (self._isDeactivated())                                                                                         // 1184\n      return;                                                                                                          // 1185\n    id = self._idFilter.idStringify(id);                                                                               // 1186\n    // We don't bother to delete sets of things in a collection if the                                                 // 1187\n    // collection is empty.  It could break _removeAllDocuments.                                                       // 1188\n    delete self._documents[collectionName][id];                                                                        // 1189\n    self._session.removed(self._subscriptionHandle, collectionName, id);                                               // 1190\n  },                                                                                                                   // 1191\n                                                                                                                       // 1192\n  /**                                                                                                                  // 1193\n   * @summary Call inside the publish function.  Informs the subscriber that an initial, complete snapshot of the record set has been sent.  This will trigger a call on the client to the `onReady` callback passed to  [`Meteor.subscribe`](#meteor_subscribe), if any.\n   * @locus Server                                                                                                     // 1195\n   * @memberOf Subscription                                                                                            // 1196\n   * @instance                                                                                                         // 1197\n   */                                                                                                                  // 1198\n  ready: function () {                                                                                                 // 1199\n    var self = this;                                                                                                   // 1200\n    if (self._isDeactivated())                                                                                         // 1201\n      return;                                                                                                          // 1202\n    if (!self._subscriptionId)                                                                                         // 1203\n      return;  // unnecessary but ignored for universal sub                                                            // 1204\n    if (!self._ready) {                                                                                                // 1205\n      self._session.sendReady([self._subscriptionId]);                                                                 // 1206\n      self._ready = true;                                                                                              // 1207\n    }                                                                                                                  // 1208\n  }                                                                                                                    // 1209\n});                                                                                                                    // 1210\n                                                                                                                       // 1211\n/******************************************************************************/                                       // 1212\n/* Server                                                                     */                                       // 1213\n/******************************************************************************/                                       // 1214\n                                                                                                                       // 1215\nServer = function (options) {                                                                                          // 1216\n  var self = this;                                                                                                     // 1217\n                                                                                                                       // 1218\n  // The default heartbeat interval is 30 seconds on the server and 35                                                 // 1219\n  // seconds on the client.  Since the client doesn't need to send a                                                   // 1220\n  // ping as long as it is receiving pings, this means that pings                                                      // 1221\n  // normally go from the server to the client.                                                                        // 1222\n  //                                                                                                                   // 1223\n  // Note: Troposphere depends on the ability to mutate                                                                // 1224\n  // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.                                            // 1225\n  self.options = _.defaults(options || {}, {                                                                           // 1226\n    heartbeatInterval: 30000,                                                                                          // 1227\n    heartbeatTimeout: 15000,                                                                                           // 1228\n    // For testing, allow responding to pings to be disabled.                                                          // 1229\n    respondToPings: true                                                                                               // 1230\n  });                                                                                                                  // 1231\n                                                                                                                       // 1232\n  // Map of callbacks to call when a new connection comes in to the                                                    // 1233\n  // server and completes DDP version negotiation. Use an object instead                                               // 1234\n  // of an array so we can safely remove one from the list while                                                       // 1235\n  // iterating over it.                                                                                                // 1236\n  self.onConnectionHook = new Hook({                                                                                   // 1237\n    debugPrintExceptions: \"onConnection callback\"                                                                      // 1238\n  });                                                                                                                  // 1239\n                                                                                                                       // 1240\n  self.publish_handlers = {};                                                                                          // 1241\n  self.universal_publish_handlers = [];                                                                                // 1242\n                                                                                                                       // 1243\n  self.method_handlers = {};                                                                                           // 1244\n                                                                                                                       // 1245\n  self.sessions = {}; // map from id to session                                                                        // 1246\n                                                                                                                       // 1247\n  self.stream_server = new StreamServer;                                                                               // 1248\n                                                                                                                       // 1249\n  self.stream_server.register(function (socket) {                                                                      // 1250\n    // socket implements the SockJSConnection interface                                                                // 1251\n    socket._meteorSession = null;                                                                                      // 1252\n                                                                                                                       // 1253\n    var sendError = function (reason, offendingMessage) {                                                              // 1254\n      var msg = {msg: 'error', reason: reason};                                                                        // 1255\n      if (offendingMessage)                                                                                            // 1256\n        msg.offendingMessage = offendingMessage;                                                                       // 1257\n      socket.send(stringifyDDP(msg));                                                                                  // 1258\n    };                                                                                                                 // 1259\n                                                                                                                       // 1260\n    socket.on('data', function (raw_msg) {                                                                             // 1261\n      if (Meteor._printReceivedDDP) {                                                                                  // 1262\n        Meteor._debug(\"Received DDP\", raw_msg);                                                                        // 1263\n      }                                                                                                                // 1264\n      try {                                                                                                            // 1265\n        try {                                                                                                          // 1266\n          var msg = parseDDP(raw_msg);                                                                                 // 1267\n        } catch (err) {                                                                                                // 1268\n          sendError('Parse error');                                                                                    // 1269\n          return;                                                                                                      // 1270\n        }                                                                                                              // 1271\n        if (msg === null || !msg.msg) {                                                                                // 1272\n          sendError('Bad request', msg);                                                                               // 1273\n          return;                                                                                                      // 1274\n        }                                                                                                              // 1275\n                                                                                                                       // 1276\n        if (msg.msg === 'connect') {                                                                                   // 1277\n          if (socket._meteorSession) {                                                                                 // 1278\n            sendError(\"Already connected\", msg);                                                                       // 1279\n            return;                                                                                                    // 1280\n          }                                                                                                            // 1281\n          Fiber(function () {                                                                                          // 1282\n            self._handleConnect(socket, msg);                                                                          // 1283\n          }).run();                                                                                                    // 1284\n          return;                                                                                                      // 1285\n        }                                                                                                              // 1286\n                                                                                                                       // 1287\n        if (!socket._meteorSession) {                                                                                  // 1288\n          sendError('Must connect first', msg);                                                                        // 1289\n          return;                                                                                                      // 1290\n        }                                                                                                              // 1291\n        socket._meteorSession.processMessage(msg);                                                                     // 1292\n      } catch (e) {                                                                                                    // 1293\n        // XXX print stack nicely                                                                                      // 1294\n        Meteor._debug(\"Internal exception while processing message\", msg,                                              // 1295\n                      e.message, e.stack);                                                                             // 1296\n      }                                                                                                                // 1297\n    });                                                                                                                // 1298\n                                                                                                                       // 1299\n    socket.on('close', function () {                                                                                   // 1300\n      if (socket._meteorSession) {                                                                                     // 1301\n        Fiber(function () {                                                                                            // 1302\n          socket._meteorSession.close();                                                                               // 1303\n        }).run();                                                                                                      // 1304\n      }                                                                                                                // 1305\n    });                                                                                                                // 1306\n  });                                                                                                                  // 1307\n};                                                                                                                     // 1308\n                                                                                                                       // 1309\n_.extend(Server.prototype, {                                                                                           // 1310\n                                                                                                                       // 1311\n  /**                                                                                                                  // 1312\n   * @summary Register a callback to be called when a new DDP connection is made to the server.                        // 1313\n   * @locus Server                                                                                                     // 1314\n   * @param {function} callback The function to call when a new DDP connection is established.                         // 1315\n   * @memberOf Meteor                                                                                                  // 1316\n   */                                                                                                                  // 1317\n  onConnection: function (fn) {                                                                                        // 1318\n    var self = this;                                                                                                   // 1319\n    return self.onConnectionHook.register(fn);                                                                         // 1320\n  },                                                                                                                   // 1321\n                                                                                                                       // 1322\n  _handleConnect: function (socket, msg) {                                                                             // 1323\n    var self = this;                                                                                                   // 1324\n                                                                                                                       // 1325\n    // The connect message must specify a version and an array of supported                                            // 1326\n    // versions, and it must claim to support what it is proposing.                                                    // 1327\n    if (!(typeof (msg.version) === 'string' &&                                                                         // 1328\n          _.isArray(msg.support) &&                                                                                    // 1329\n          _.all(msg.support, _.isString) &&                                                                            // 1330\n          _.contains(msg.support, msg.version))) {                                                                     // 1331\n      socket.send(stringifyDDP({msg: 'failed',                                                                         // 1332\n                                version: SUPPORTED_DDP_VERSIONS[0]}));                                                 // 1333\n      socket.close();                                                                                                  // 1334\n      return;                                                                                                          // 1335\n    }                                                                                                                  // 1336\n                                                                                                                       // 1337\n    // In the future, handle session resumption: something like:                                                       // 1338\n    //  socket._meteorSession = self.sessions[msg.session]                                                             // 1339\n    var version = calculateVersion(msg.support, SUPPORTED_DDP_VERSIONS);                                               // 1340\n                                                                                                                       // 1341\n    if (msg.version !== version) {                                                                                     // 1342\n      // The best version to use (according to the client's stated preferences)                                        // 1343\n      // is not the one the client is trying to use. Inform them about the best                                        // 1344\n      // version to use.                                                                                               // 1345\n      socket.send(stringifyDDP({msg: 'failed', version: version}));                                                    // 1346\n      socket.close();                                                                                                  // 1347\n      return;                                                                                                          // 1348\n    }                                                                                                                  // 1349\n                                                                                                                       // 1350\n    // Yay, version matches! Create a new session.                                                                     // 1351\n    // Note: Troposphere depends on the ability to mutate                                                              // 1352\n    // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.                                          // 1353\n    socket._meteorSession = new Session(self, version, socket, self.options);                                          // 1354\n    self.sessions[socket._meteorSession.id] = socket._meteorSession;                                                   // 1355\n    self.onConnectionHook.each(function (callback) {                                                                   // 1356\n      if (socket._meteorSession)                                                                                       // 1357\n        callback(socket._meteorSession.connectionHandle);                                                              // 1358\n      return true;                                                                                                     // 1359\n    });                                                                                                                // 1360\n  },                                                                                                                   // 1361\n  /**                                                                                                                  // 1362\n   * Register a publish handler function.                                                                              // 1363\n   *                                                                                                                   // 1364\n   * @param name {String} identifier for query                                                                         // 1365\n   * @param handler {Function} publish handler                                                                         // 1366\n   * @param options {Object}                                                                                           // 1367\n   *                                                                                                                   // 1368\n   * Server will call handler function on each new subscription,                                                       // 1369\n   * either when receiving DDP sub message for a named subscription, or on                                             // 1370\n   * DDP connect for a universal subscription.                                                                         // 1371\n   *                                                                                                                   // 1372\n   * If name is null, this will be a subscription that is                                                              // 1373\n   * automatically established and permanently on for all connected                                                    // 1374\n   * client, instead of a subscription that can be turned on and off                                                   // 1375\n   * with subscribe().                                                                                                 // 1376\n   *                                                                                                                   // 1377\n   * options to contain:                                                                                               // 1378\n   *  - (mostly internal) is_auto: true if generated automatically                                                     // 1379\n   *    from an autopublish hook. this is for cosmetic purposes only                                                   // 1380\n   *    (it lets us determine whether to print a warning suggesting                                                    // 1381\n   *    that you turn off autopublish.)                                                                                // 1382\n   */                                                                                                                  // 1383\n                                                                                                                       // 1384\n  /**                                                                                                                  // 1385\n   * @summary Publish a record set.                                                                                    // 1386\n   * @memberOf Meteor                                                                                                  // 1387\n   * @locus Server                                                                                                     // 1388\n   * @param {String} name Name of the record set.  If `null`, the set has no name, and the record set is automatically sent to all connected clients.\n   * @param {Function} func Function called on the server each time a client subscribes.  Inside the function, `this` is the publish handler object, described below.  If the client passed arguments to `subscribe`, the function is called with the same arguments.\n   */                                                                                                                  // 1391\n  publish: function (name, handler, options) {                                                                         // 1392\n    var self = this;                                                                                                   // 1393\n                                                                                                                       // 1394\n    options = options || {};                                                                                           // 1395\n                                                                                                                       // 1396\n    if (name && name in self.publish_handlers) {                                                                       // 1397\n      Meteor._debug(\"Ignoring duplicate publish named '\" + name + \"'\");                                                // 1398\n      return;                                                                                                          // 1399\n    }                                                                                                                  // 1400\n                                                                                                                       // 1401\n    if (Package.autopublish && !options.is_auto) {                                                                     // 1402\n      // They have autopublish on, yet they're trying to manually                                                      // 1403\n      // picking stuff to publish. They probably should turn off                                                       // 1404\n      // autopublish. (This check isn't perfect -- if you create a                                                     // 1405\n      // publish before you turn on autopublish, it won't catch                                                        // 1406\n      // it. But this will definitely handle the simple case where                                                     // 1407\n      // you've added the autopublish package to your app, and are                                                     // 1408\n      // calling publish from your app code.)                                                                          // 1409\n      if (!self.warned_about_autopublish) {                                                                            // 1410\n        self.warned_about_autopublish = true;                                                                          // 1411\n        Meteor._debug(                                                                                                 // 1412\n\"** You've set up some data subscriptions with Meteor.publish(), but\\n\" +                                              // 1413\n\"** you still have autopublish turned on. Because autopublish is still\\n\" +                                            // 1414\n\"** on, your Meteor.publish() calls won't have much effect. All data\\n\" +                                              // 1415\n\"** will still be sent to all clients.\\n\" +                                                                            // 1416\n\"**\\n\" +                                                                                                               // 1417\n\"** Turn off autopublish by removing the autopublish package:\\n\" +                                                     // 1418\n\"**\\n\" +                                                                                                               // 1419\n\"**   $ meteor remove autopublish\\n\" +                                                                                 // 1420\n\"**\\n\" +                                                                                                               // 1421\n\"** .. and make sure you have Meteor.publish() and Meteor.subscribe() calls\\n\" +                                       // 1422\n\"** for each collection that you want clients to see.\\n\");                                                             // 1423\n      }                                                                                                                // 1424\n    }                                                                                                                  // 1425\n                                                                                                                       // 1426\n    if (name)                                                                                                          // 1427\n      self.publish_handlers[name] = handler;                                                                           // 1428\n    else {                                                                                                             // 1429\n      self.universal_publish_handlers.push(handler);                                                                   // 1430\n      // Spin up the new publisher on any existing session too. Run each                                               // 1431\n      // session's subscription in a new Fiber, so that there's no change for                                          // 1432\n      // self.sessions to change while we're running this loop.                                                        // 1433\n      _.each(self.sessions, function (session) {                                                                       // 1434\n        if (!session._dontStartNewUniversalSubs) {                                                                     // 1435\n          Fiber(function() {                                                                                           // 1436\n            session._startSubscription(handler);                                                                       // 1437\n          }).run();                                                                                                    // 1438\n        }                                                                                                              // 1439\n      });                                                                                                              // 1440\n    }                                                                                                                  // 1441\n  },                                                                                                                   // 1442\n                                                                                                                       // 1443\n  _removeSession: function (session) {                                                                                 // 1444\n    var self = this;                                                                                                   // 1445\n    if (self.sessions[session.id]) {                                                                                   // 1446\n      delete self.sessions[session.id];                                                                                // 1447\n    }                                                                                                                  // 1448\n  },                                                                                                                   // 1449\n                                                                                                                       // 1450\n  /**                                                                                                                  // 1451\n   * @summary Defines functions that can be invoked over the network by clients.                                       // 1452\n   * @locus Anywhere                                                                                                   // 1453\n   * @param {Object} methods Dictionary whose keys are method names and values are functions.                          // 1454\n   * @memberOf Meteor                                                                                                  // 1455\n   */                                                                                                                  // 1456\n  methods: function (methods) {                                                                                        // 1457\n    var self = this;                                                                                                   // 1458\n    _.each(methods, function (func, name) {                                                                            // 1459\n      if (self.method_handlers[name])                                                                                  // 1460\n        throw new Error(\"A method named '\" + name + \"' is already defined\");                                           // 1461\n      self.method_handlers[name] = func;                                                                               // 1462\n    });                                                                                                                // 1463\n  },                                                                                                                   // 1464\n                                                                                                                       // 1465\n  call: function (name /*, arguments */) {                                                                             // 1466\n    // if it's a function, the last argument is the result callback,                                                   // 1467\n    // not a parameter to the remote method.                                                                           // 1468\n    var args = Array.prototype.slice.call(arguments, 1);                                                               // 1469\n    if (args.length && typeof args[args.length - 1] === \"function\")                                                    // 1470\n      var callback = args.pop();                                                                                       // 1471\n    return this.apply(name, args, callback);                                                                           // 1472\n  },                                                                                                                   // 1473\n                                                                                                                       // 1474\n  // @param options {Optional Object}                                                                                  // 1475\n  // @param callback {Optional Function}                                                                               // 1476\n  apply: function (name, args, options, callback) {                                                                    // 1477\n    var self = this;                                                                                                   // 1478\n                                                                                                                       // 1479\n    // We were passed 3 arguments. They may be either (name, args, options)                                            // 1480\n    // or (name, args, callback)                                                                                       // 1481\n    if (!callback && typeof options === 'function') {                                                                  // 1482\n      callback = options;                                                                                              // 1483\n      options = {};                                                                                                    // 1484\n    }                                                                                                                  // 1485\n    options = options || {};                                                                                           // 1486\n                                                                                                                       // 1487\n    if (callback)                                                                                                      // 1488\n      // It's not really necessary to do this, since we immediately                                                    // 1489\n      // run the callback in this fiber before returning, but we do it                                                 // 1490\n      // anyway for regularity.                                                                                        // 1491\n      // XXX improve error message (and how we report it)                                                              // 1492\n      callback = Meteor.bindEnvironment(                                                                               // 1493\n        callback,                                                                                                      // 1494\n        \"delivering result of invoking '\" + name + \"'\"                                                                 // 1495\n      );                                                                                                               // 1496\n                                                                                                                       // 1497\n    // Run the handler                                                                                                 // 1498\n    var handler = self.method_handlers[name];                                                                          // 1499\n    var exception;                                                                                                     // 1500\n    if (!handler) {                                                                                                    // 1501\n      exception = new Meteor.Error(404, \"Method not found\");                                                           // 1502\n    } else {                                                                                                           // 1503\n      // If this is a method call from within another method, get the                                                  // 1504\n      // user state from the outer method, otherwise don't allow                                                       // 1505\n      // setUserId to be called                                                                                        // 1506\n      var userId = null;                                                                                               // 1507\n      var setUserId = function() {                                                                                     // 1508\n        throw new Error(\"Can't call setUserId on a server initiated method call\");                                     // 1509\n      };                                                                                                               // 1510\n      var connection = null;                                                                                           // 1511\n      var currentInvocation = DDP._CurrentInvocation.get();                                                            // 1512\n      if (currentInvocation) {                                                                                         // 1513\n        userId = currentInvocation.userId;                                                                             // 1514\n        setUserId = function(userId) {                                                                                 // 1515\n          currentInvocation.setUserId(userId);                                                                         // 1516\n        };                                                                                                             // 1517\n        connection = currentInvocation.connection;                                                                     // 1518\n      }                                                                                                                // 1519\n                                                                                                                       // 1520\n      var invocation = new MethodInvocation({                                                                          // 1521\n        isSimulation: false,                                                                                           // 1522\n        userId: userId,                                                                                                // 1523\n        setUserId: setUserId,                                                                                          // 1524\n        connection: connection,                                                                                        // 1525\n        randomSeed: makeRpcSeed(currentInvocation, name)                                                               // 1526\n      });                                                                                                              // 1527\n      try {                                                                                                            // 1528\n        var result = DDP._CurrentInvocation.withValue(invocation, function () {                                        // 1529\n          return maybeAuditArgumentChecks(                                                                             // 1530\n            handler, invocation, EJSON.clone(args), \"internal call to '\" +                                             // 1531\n              name + \"'\");                                                                                             // 1532\n        });                                                                                                            // 1533\n        result = EJSON.clone(result);                                                                                  // 1534\n      } catch (e) {                                                                                                    // 1535\n        exception = e;                                                                                                 // 1536\n      }                                                                                                                // 1537\n    }                                                                                                                  // 1538\n                                                                                                                       // 1539\n    // Return the result in whichever way the caller asked for it. Note that we                                        // 1540\n    // do NOT block on the write fence in an analogous way to how the client                                           // 1541\n    // blocks on the relevant data being visible, so you are NOT guaranteed that                                       // 1542\n    // cursor observe callbacks have fired when your callback is invoked. (We                                          // 1543\n    // can change this if there's a real use case.)                                                                    // 1544\n    if (callback) {                                                                                                    // 1545\n      callback(exception, result);                                                                                     // 1546\n      return undefined;                                                                                                // 1547\n    }                                                                                                                  // 1548\n    if (exception)                                                                                                     // 1549\n      throw exception;                                                                                                 // 1550\n    return result;                                                                                                     // 1551\n  },                                                                                                                   // 1552\n                                                                                                                       // 1553\n  _urlForSession: function (sessionId) {                                                                               // 1554\n    var self = this;                                                                                                   // 1555\n    var session = self.sessions[sessionId];                                                                            // 1556\n    if (session)                                                                                                       // 1557\n      return session._socketUrl;                                                                                       // 1558\n    else                                                                                                               // 1559\n      return null;                                                                                                     // 1560\n  }                                                                                                                    // 1561\n});                                                                                                                    // 1562\n                                                                                                                       // 1563\nvar calculateVersion = function (clientSupportedVersions,                                                              // 1564\n                                 serverSupportedVersions) {                                                            // 1565\n  var correctVersion = _.find(clientSupportedVersions, function (version) {                                            // 1566\n    return _.contains(serverSupportedVersions, version);                                                               // 1567\n  });                                                                                                                  // 1568\n  if (!correctVersion) {                                                                                               // 1569\n    correctVersion = serverSupportedVersions[0];                                                                       // 1570\n  }                                                                                                                    // 1571\n  return correctVersion;                                                                                               // 1572\n};                                                                                                                     // 1573\n                                                                                                                       // 1574\nLivedataTest.calculateVersion = calculateVersion;                                                                      // 1575\n                                                                                                                       // 1576\n                                                                                                                       // 1577\n// \"blind\" exceptions other than those that were deliberately thrown to signal                                         // 1578\n// errors to the client                                                                                                // 1579\nvar wrapInternalException = function (exception, context) {                                                            // 1580\n  if (!exception || exception instanceof Meteor.Error)                                                                 // 1581\n    return exception;                                                                                                  // 1582\n                                                                                                                       // 1583\n  // tests can set the 'expected' flag on an exception so it won't go to the                                           // 1584\n  // server log                                                                                                        // 1585\n  if (!exception.expected) {                                                                                           // 1586\n    Meteor._debug(\"Exception \" + context, exception.stack);                                                            // 1587\n    if (exception.sanitizedError) {                                                                                    // 1588\n      Meteor._debug(\"Sanitized and reported to the client as:\", exception.sanitizedError.message);                     // 1589\n      Meteor._debug();                                                                                                 // 1590\n    }                                                                                                                  // 1591\n  }                                                                                                                    // 1592\n                                                                                                                       // 1593\n  // Did the error contain more details that could have been useful if caught in                                       // 1594\n  // server code (or if thrown from non-client-originated code), but also                                              // 1595\n  // provided a \"sanitized\" version with more context than 500 Internal server                                         // 1596\n  // error? Use that.                                                                                                  // 1597\n  if (exception.sanitizedError) {                                                                                      // 1598\n    if (exception.sanitizedError instanceof Meteor.Error)                                                              // 1599\n      return exception.sanitizedError;                                                                                 // 1600\n    Meteor._debug(\"Exception \" + context + \" provides a sanitizedError that \" +                                        // 1601\n                  \"is not a Meteor.Error; ignoring\");                                                                  // 1602\n  }                                                                                                                    // 1603\n                                                                                                                       // 1604\n  return new Meteor.Error(500, \"Internal server error\");                                                               // 1605\n};                                                                                                                     // 1606\n                                                                                                                       // 1607\n                                                                                                                       // 1608\n// Audit argument checks, if the audit-argument-checks package exists (it is a                                         // 1609\n// weak dependency of this package).                                                                                   // 1610\nvar maybeAuditArgumentChecks = function (f, context, args, description) {                                              // 1611\n  args = args || [];                                                                                                   // 1612\n  if (Package['audit-argument-checks']) {                                                                              // 1613\n    return Match._failIfArgumentsAreNotAllChecked(                                                                     // 1614\n      f, context, args, description);                                                                                  // 1615\n  }                                                                                                                    // 1616\n  return f.apply(context, args);                                                                                       // 1617\n};                                                                                                                     // 1618\n                                                                                                                       // 1619\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function () {\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/ddp/writefence.js                                                                                          //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar path = Npm.require('path');                                                                                        // 1\nvar Future = Npm.require(path.join('fibers', 'future'));                                                               // 2\n                                                                                                                       // 3\n// A write fence collects a group of writes, and provides a callback                                                   // 4\n// when all of the writes are fully committed and propagated (all                                                      // 5\n// observers have been notified of the write and acknowledged it.)                                                     // 6\n//                                                                                                                     // 7\nDDPServer._WriteFence = function () {                                                                                  // 8\n  var self = this;                                                                                                     // 9\n                                                                                                                       // 10\n  self.armed = false;                                                                                                  // 11\n  self.fired = false;                                                                                                  // 12\n  self.retired = false;                                                                                                // 13\n  self.outstanding_writes = 0;                                                                                         // 14\n  self.completion_callbacks = [];                                                                                      // 15\n};                                                                                                                     // 16\n                                                                                                                       // 17\n// The current write fence. When there is a current write fence, code                                                  // 18\n// that writes to databases should register their writes with it using                                                 // 19\n// beginWrite().                                                                                                       // 20\n//                                                                                                                     // 21\nDDPServer._CurrentWriteFence = new Meteor.EnvironmentVariable;                                                         // 22\n                                                                                                                       // 23\n_.extend(DDPServer._WriteFence.prototype, {                                                                            // 24\n  // Start tracking a write, and return an object to represent it. The                                                 // 25\n  // object has a single method, committed(). This method should be                                                    // 26\n  // called when the write is fully committed and propagated. You can                                                  // 27\n  // continue to add writes to the WriteFence up until it is triggered                                                 // 28\n  // (calls its callbacks because all writes have committed.)                                                          // 29\n  beginWrite: function () {                                                                                            // 30\n    var self = this;                                                                                                   // 31\n                                                                                                                       // 32\n    if (self.retired)                                                                                                  // 33\n      return { committed: function () {} };                                                                            // 34\n                                                                                                                       // 35\n    if (self.fired)                                                                                                    // 36\n      throw new Error(\"fence has already activated -- too late to add writes\");                                        // 37\n                                                                                                                       // 38\n    self.outstanding_writes++;                                                                                         // 39\n    var committed = false;                                                                                             // 40\n    return {                                                                                                           // 41\n      committed: function () {                                                                                         // 42\n        if (committed)                                                                                                 // 43\n          throw new Error(\"committed called twice on the same write\");                                                 // 44\n        committed = true;                                                                                              // 45\n        self.outstanding_writes--;                                                                                     // 46\n        self._maybeFire();                                                                                             // 47\n      }                                                                                                                // 48\n    };                                                                                                                 // 49\n  },                                                                                                                   // 50\n                                                                                                                       // 51\n  // Arm the fence. Once the fence is armed, and there are no more                                                     // 52\n  // uncommitted writes, it will activate.                                                                             // 53\n  arm: function () {                                                                                                   // 54\n    var self = this;                                                                                                   // 55\n    if (self === DDPServer._CurrentWriteFence.get())                                                                   // 56\n      throw Error(\"Can't arm the current fence\");                                                                      // 57\n    self.armed = true;                                                                                                 // 58\n    self._maybeFire();                                                                                                 // 59\n  },                                                                                                                   // 60\n                                                                                                                       // 61\n  // Register a function to be called when the fence fires.                                                            // 62\n  onAllCommitted: function (func) {                                                                                    // 63\n    var self = this;                                                                                                   // 64\n    if (self.fired)                                                                                                    // 65\n      throw new Error(\"fence has already activated -- too late to \" +                                                  // 66\n                      \"add a callback\");                                                                               // 67\n    self.completion_callbacks.push(func);                                                                              // 68\n  },                                                                                                                   // 69\n                                                                                                                       // 70\n  // Convenience function. Arms the fence, then blocks until it fires.                                                 // 71\n  armAndWait: function () {                                                                                            // 72\n    var self = this;                                                                                                   // 73\n    var future = new Future;                                                                                           // 74\n    self.onAllCommitted(function () {                                                                                  // 75\n      future['return']();                                                                                              // 76\n    });                                                                                                                // 77\n    self.arm();                                                                                                        // 78\n    future.wait();                                                                                                     // 79\n  },                                                                                                                   // 80\n                                                                                                                       // 81\n  _maybeFire: function () {                                                                                            // 82\n    var self = this;                                                                                                   // 83\n    if (self.fired)                                                                                                    // 84\n      throw new Error(\"write fence already activated?\");                                                               // 85\n    if (self.armed && !self.outstanding_writes) {                                                                      // 86\n      self.fired = true;                                                                                               // 87\n      _.each(self.completion_callbacks, function (f) {f(self);});                                                      // 88\n      self.completion_callbacks = [];                                                                                  // 89\n    }                                                                                                                  // 90\n  },                                                                                                                   // 91\n                                                                                                                       // 92\n  // Deactivate this fence so that adding more writes has no effect.                                                   // 93\n  // The fence must have already fired.                                                                                // 94\n  retire: function () {                                                                                                // 95\n    var self = this;                                                                                                   // 96\n    if (! self.fired)                                                                                                  // 97\n      throw new Error(\"Can't retire a fence that hasn't fired.\");                                                      // 98\n    self.retired = true;                                                                                               // 99\n  }                                                                                                                    // 100\n});                                                                                                                    // 101\n                                                                                                                       // 102\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function () {\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/ddp/crossbar.js                                                                                            //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n// A \"crossbar\" is a class that provides structured notification registration.                                         // 1\n// See _match for the definition of how a notification matches a trigger.                                              // 2\n// All notifications and triggers must have a string key named 'collection'.                                           // 3\n                                                                                                                       // 4\nDDPServer._Crossbar = function (options) {                                                                             // 5\n  var self = this;                                                                                                     // 6\n  options = options || {};                                                                                             // 7\n                                                                                                                       // 8\n  self.nextId = 1;                                                                                                     // 9\n  // map from collection name (string) -> listener id -> object. each object has                                       // 10\n  // keys 'trigger', 'callback'.                                                                                       // 11\n  self.listenersByCollection = {};                                                                                     // 12\n  self.factPackage = options.factPackage || \"livedata\";                                                                // 13\n  self.factName = options.factName || null;                                                                            // 14\n};                                                                                                                     // 15\n                                                                                                                       // 16\n_.extend(DDPServer._Crossbar.prototype, {                                                                              // 17\n  // Listen for notification that match 'trigger'. A notification                                                      // 18\n  // matches if it has the key-value pairs in trigger as a                                                             // 19\n  // subset. When a notification matches, call 'callback', passing                                                     // 20\n  // the actual notification.                                                                                          // 21\n  //                                                                                                                   // 22\n  // Returns a listen handle, which is an object with a method                                                         // 23\n  // stop(). Call stop() to stop listening.                                                                            // 24\n  //                                                                                                                   // 25\n  // XXX It should be legal to call fire() from inside a listen()                                                      // 26\n  // callback?                                                                                                         // 27\n  listen: function (trigger, callback) {                                                                               // 28\n    var self = this;                                                                                                   // 29\n    var id = self.nextId++;                                                                                            // 30\n                                                                                                                       // 31\n    if (typeof(trigger.collection) !== 'string') {                                                                     // 32\n      throw Error(\"Trigger lacks collection!\");                                                                        // 33\n    }                                                                                                                  // 34\n                                                                                                                       // 35\n    var collection = trigger.collection;  // save in case trigger is mutated                                           // 36\n    var record = {trigger: EJSON.clone(trigger), callback: callback};                                                  // 37\n    if (! _.has(self.listenersByCollection, collection)) {                                                             // 38\n      self.listenersByCollection[collection] = {};                                                                     // 39\n    }                                                                                                                  // 40\n    self.listenersByCollection[collection][id] = record;                                                               // 41\n                                                                                                                       // 42\n    if (self.factName && Package.facts) {                                                                              // 43\n      Package.facts.Facts.incrementServerFact(                                                                         // 44\n        self.factPackage, self.factName, 1);                                                                           // 45\n    }                                                                                                                  // 46\n                                                                                                                       // 47\n    return {                                                                                                           // 48\n      stop: function () {                                                                                              // 49\n        if (self.factName && Package.facts) {                                                                          // 50\n          Package.facts.Facts.incrementServerFact(                                                                     // 51\n            self.factPackage, self.factName, -1);                                                                      // 52\n        }                                                                                                              // 53\n        delete self.listenersByCollection[collection][id];                                                             // 54\n        if (_.isEmpty(self.listenersByCollection[collection])) {                                                       // 55\n          delete self.listenersByCollection[collection];                                                               // 56\n        }                                                                                                              // 57\n      }                                                                                                                // 58\n    };                                                                                                                 // 59\n  },                                                                                                                   // 60\n                                                                                                                       // 61\n  // Fire the provided 'notification' (an object whose attribute                                                       // 62\n  // values are all JSON-compatibile) -- inform all matching listeners                                                 // 63\n  // (registered with listen()).                                                                                       // 64\n  //                                                                                                                   // 65\n  // If fire() is called inside a write fence, then each of the                                                        // 66\n  // listener callbacks will be called inside the write fence as well.                                                 // 67\n  //                                                                                                                   // 68\n  // The listeners may be invoked in parallel, rather than serially.                                                   // 69\n  fire: function (notification) {                                                                                      // 70\n    var self = this;                                                                                                   // 71\n                                                                                                                       // 72\n    if (typeof(notification.collection) !== 'string') {                                                                // 73\n      throw Error(\"Notification lacks collection!\");                                                                   // 74\n    }                                                                                                                  // 75\n                                                                                                                       // 76\n    if (! _.has(self.listenersByCollection, notification.collection))                                                  // 77\n      return;                                                                                                          // 78\n                                                                                                                       // 79\n    var listenersForCollection =                                                                                       // 80\n          self.listenersByCollection[notification.collection];                                                         // 81\n    var callbackIds = [];                                                                                              // 82\n    _.each(listenersForCollection, function (l, id) {                                                                  // 83\n      if (self._matches(notification, l.trigger)) {                                                                    // 84\n        callbackIds.push(id);                                                                                          // 85\n      }                                                                                                                // 86\n    });                                                                                                                // 87\n                                                                                                                       // 88\n    // Listener callbacks can yield, so we need to first find all the ones that                                        // 89\n    // match in a single iteration over self.listenersByCollection (which can't                                        // 90\n    // be mutated during this iteration), and then invoke the matching                                                 // 91\n    // callbacks, checking before each call to ensure they haven't stopped.                                            // 92\n    // Note that we don't have to check that                                                                           // 93\n    // self.listenersByCollection[notification.collection] still ===                                                   // 94\n    // listenersForCollection, because the only way that stops being true is if                                        // 95\n    // listenersForCollection first gets reduced down to the empty object (and                                         // 96\n    // then never gets increased again).                                                                               // 97\n    _.each(callbackIds, function (id) {                                                                                // 98\n      if (_.has(listenersForCollection, id)) {                                                                         // 99\n        listenersForCollection[id].callback(notification);                                                             // 100\n      }                                                                                                                // 101\n    });                                                                                                                // 102\n  },                                                                                                                   // 103\n                                                                                                                       // 104\n  // A notification matches a trigger if all keys that exist in both are equal.                                        // 105\n  //                                                                                                                   // 106\n  // Examples:                                                                                                         // 107\n  //  N:{collection: \"C\"} matches T:{collection: \"C\"}                                                                  // 108\n  //    (a non-targeted write to a collection matches a                                                                // 109\n  //     non-targeted query)                                                                                           // 110\n  //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\"}                                                         // 111\n  //    (a targeted write to a collection matches a non-targeted query)                                                // 112\n  //  N:{collection: \"C\"} matches T:{collection: \"C\", id: \"X\"}                                                         // 113\n  //    (a non-targeted write to a collection matches a                                                                // 114\n  //     targeted query)                                                                                               // 115\n  //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\", id: \"X\"}                                                // 116\n  //    (a targeted write to a collection matches a targeted query targeted                                            // 117\n  //     at the same document)                                                                                         // 118\n  //  N:{collection: \"C\", id: \"X\"} does not match T:{collection: \"C\", id: \"Y\"}                                         // 119\n  //    (a targeted write to a collection does not match a targeted query                                              // 120\n  //     targeted at a different document)                                                                             // 121\n  _matches: function (notification, trigger) {                                                                         // 122\n    // Most notifications that use the crossbar have a string `collection` and                                         // 123\n    // maybe an `id` that is a string or ObjectID. We're already dividing up                                           // 124\n    // triggers by collection, but let's fast-track \"nope, different ID\" (and                                          // 125\n    // avoid the overly generic EJSON.equals). This makes a noticeable                                                 // 126\n    // performance difference; see https://github.com/meteor/meteor/pull/3697                                          // 127\n    if (typeof(notification.id) === 'string' &&                                                                        // 128\n        typeof(trigger.id) === 'string' &&                                                                             // 129\n        notification.id !== trigger.id) {                                                                              // 130\n      return false;                                                                                                    // 131\n    }                                                                                                                  // 132\n    if (notification.id instanceof LocalCollection._ObjectID &&                                                        // 133\n        trigger.id instanceof LocalCollection._ObjectID &&                                                             // 134\n        ! notification.id.equals(trigger.id)) {                                                                        // 135\n      return false;                                                                                                    // 136\n    }                                                                                                                  // 137\n                                                                                                                       // 138\n    return _.all(trigger, function (triggerValue, key) {                                                               // 139\n      return !_.has(notification, key) ||                                                                              // 140\n        EJSON.equals(triggerValue, notification[key]);                                                                 // 141\n    });                                                                                                                // 142\n  }                                                                                                                    // 143\n});                                                                                                                    // 144\n                                                                                                                       // 145\n// The \"invalidation crossbar\" is a specific instance used by the DDP server to                                        // 146\n// implement write fence notifications. Listener callbacks on this crossbar                                            // 147\n// should call beginWrite on the current write fence before they return, if they                                       // 148\n// want to delay the write fence from firing (ie, the DDP method-data-updated                                          // 149\n// message from being sent).                                                                                           // 150\nDDPServer._InvalidationCrossbar = new DDPServer._Crossbar({                                                            // 151\n  factName: \"invalidation-crossbar-listeners\"                                                                          // 152\n});                                                                                                                    // 153\n                                                                                                                       // 154\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function () {\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/ddp/livedata_common.js                                                                                     //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n// All the supported versions (for both the client and server)                                                         // 1\n// These must be in order of preference; most favored-first                                                            // 2\nSUPPORTED_DDP_VERSIONS = [ '1', 'pre2', 'pre1' ];                                                                      // 3\n                                                                                                                       // 4\nLivedataTest.SUPPORTED_DDP_VERSIONS = SUPPORTED_DDP_VERSIONS;                                                          // 5\n                                                                                                                       // 6\n// Instance name is this because it is usually referred to as this inside a                                            // 7\n// method definition                                                                                                   // 8\n/**                                                                                                                    // 9\n * @summary The state for a single invocation of a method, referenced by this                                          // 10\n * inside a method definition.                                                                                         // 11\n * @param {Object} options                                                                                             // 12\n * @instanceName this                                                                                                  // 13\n */                                                                                                                    // 14\nMethodInvocation = function (options) {                                                                                // 15\n  var self = this;                                                                                                     // 16\n                                                                                                                       // 17\n  // true if we're running not the actual method, but a stub (that is,                                                 // 18\n  // if we're on a client (which may be a browser, or in the future a                                                  // 19\n  // server connecting to another server) and presently running a                                                      // 20\n  // simulation of a server-side method for latency compensation                                                       // 21\n  // purposes). not currently true except in a client such as a browser,                                               // 22\n  // since there's usually no point in running stubs unless you have a                                                 // 23\n  // zero-latency connection to the user.                                                                              // 24\n                                                                                                                       // 25\n  /**                                                                                                                  // 26\n   * @summary Access inside a method invocation.  Boolean value, true if this invocation is a stub.                    // 27\n   * @locus Anywhere                                                                                                   // 28\n   * @name  isSimulation                                                                                               // 29\n   * @memberOf MethodInvocation                                                                                        // 30\n   * @instance                                                                                                         // 31\n   * @type {Boolean}                                                                                                   // 32\n   */                                                                                                                  // 33\n  this.isSimulation = options.isSimulation;                                                                            // 34\n                                                                                                                       // 35\n  // call this function to allow other method invocations (from the                                                    // 36\n  // same client) to continue running without waiting for this one to                                                  // 37\n  // complete.                                                                                                         // 38\n  this._unblock = options.unblock || function () {};                                                                   // 39\n  this._calledUnblock = false;                                                                                         // 40\n                                                                                                                       // 41\n  // current user id                                                                                                   // 42\n                                                                                                                       // 43\n  /**                                                                                                                  // 44\n   * @summary The id of the user that made this method call, or `null` if no user was logged in.                       // 45\n   * @locus Anywhere                                                                                                   // 46\n   * @name  userId                                                                                                     // 47\n   * @memberOf MethodInvocation                                                                                        // 48\n   * @instance                                                                                                         // 49\n   */                                                                                                                  // 50\n  this.userId = options.userId;                                                                                        // 51\n                                                                                                                       // 52\n  // sets current user id in all appropriate server contexts and                                                       // 53\n  // reruns subscriptions                                                                                              // 54\n  this._setUserId = options.setUserId || function () {};                                                               // 55\n                                                                                                                       // 56\n  // On the server, the connection this method call came in on.                                                        // 57\n                                                                                                                       // 58\n  /**                                                                                                                  // 59\n   * @summary Access inside a method invocation. The [connection](#meteor_onconnection) that this method was received on. `null` if the method is not associated with a connection, eg. a server initiated method call.\n   * @locus Server                                                                                                     // 61\n   * @name  connection                                                                                                 // 62\n   * @memberOf MethodInvocation                                                                                        // 63\n   * @instance                                                                                                         // 64\n   */                                                                                                                  // 65\n  this.connection = options.connection;                                                                                // 66\n                                                                                                                       // 67\n  // The seed for randomStream value generation                                                                        // 68\n  this.randomSeed = options.randomSeed;                                                                                // 69\n                                                                                                                       // 70\n  // This is set by RandomStream.get; and holds the random stream state                                                // 71\n  this.randomStream = null;                                                                                            // 72\n};                                                                                                                     // 73\n                                                                                                                       // 74\n_.extend(MethodInvocation.prototype, {                                                                                 // 75\n  /**                                                                                                                  // 76\n   * @summary Call inside a method invocation.  Allow subsequent method from this client to begin running in a new fiber.\n   * @locus Server                                                                                                     // 78\n   * @memberOf MethodInvocation                                                                                        // 79\n   * @instance                                                                                                         // 80\n   */                                                                                                                  // 81\n  unblock: function () {                                                                                               // 82\n    var self = this;                                                                                                   // 83\n    self._calledUnblock = true;                                                                                        // 84\n    self._unblock();                                                                                                   // 85\n  },                                                                                                                   // 86\n                                                                                                                       // 87\n  /**                                                                                                                  // 88\n   * @summary Set the logged in user.                                                                                  // 89\n   * @locus Server                                                                                                     // 90\n   * @memberOf MethodInvocation                                                                                        // 91\n   * @instance                                                                                                         // 92\n   * @param {String | null} userId The value that should be returned by `userId` on this connection.                   // 93\n   */                                                                                                                  // 94\n  setUserId: function(userId) {                                                                                        // 95\n    var self = this;                                                                                                   // 96\n    if (self._calledUnblock)                                                                                           // 97\n      throw new Error(\"Can't call setUserId in a method after calling unblock\");                                       // 98\n    self.userId = userId;                                                                                              // 99\n    self._setUserId(userId);                                                                                           // 100\n  }                                                                                                                    // 101\n});                                                                                                                    // 102\n                                                                                                                       // 103\nparseDDP = function (stringMessage) {                                                                                  // 104\n  try {                                                                                                                // 105\n    var msg = JSON.parse(stringMessage);                                                                               // 106\n  } catch (e) {                                                                                                        // 107\n    Meteor._debug(\"Discarding message with invalid JSON\", stringMessage);                                              // 108\n    return null;                                                                                                       // 109\n  }                                                                                                                    // 110\n  // DDP messages must be objects.                                                                                     // 111\n  if (msg === null || typeof msg !== 'object') {                                                                       // 112\n    Meteor._debug(\"Discarding non-object DDP message\", stringMessage);                                                 // 113\n    return null;                                                                                                       // 114\n  }                                                                                                                    // 115\n                                                                                                                       // 116\n  // massage msg to get it into \"abstract ddp\" rather than \"wire ddp\" format.                                          // 117\n                                                                                                                       // 118\n  // switch between \"cleared\" rep of unsetting fields and \"undefined\"                                                  // 119\n  // rep of same                                                                                                       // 120\n  if (_.has(msg, 'cleared')) {                                                                                         // 121\n    if (!_.has(msg, 'fields'))                                                                                         // 122\n      msg.fields = {};                                                                                                 // 123\n    _.each(msg.cleared, function (clearKey) {                                                                          // 124\n      msg.fields[clearKey] = undefined;                                                                                // 125\n    });                                                                                                                // 126\n    delete msg.cleared;                                                                                                // 127\n  }                                                                                                                    // 128\n                                                                                                                       // 129\n  _.each(['fields', 'params', 'result'], function (field) {                                                            // 130\n    if (_.has(msg, field))                                                                                             // 131\n      msg[field] = EJSON._adjustTypesFromJSONValue(msg[field]);                                                        // 132\n  });                                                                                                                  // 133\n                                                                                                                       // 134\n  return msg;                                                                                                          // 135\n};                                                                                                                     // 136\n                                                                                                                       // 137\nstringifyDDP = function (msg) {                                                                                        // 138\n  var copy = EJSON.clone(msg);                                                                                         // 139\n  // swizzle 'changed' messages from 'fields undefined' rep to 'fields                                                 // 140\n  // and cleared' rep                                                                                                  // 141\n  if (_.has(msg, 'fields')) {                                                                                          // 142\n    var cleared = [];                                                                                                  // 143\n    _.each(msg.fields, function (value, key) {                                                                         // 144\n      if (value === undefined) {                                                                                       // 145\n        cleared.push(key);                                                                                             // 146\n        delete copy.fields[key];                                                                                       // 147\n      }                                                                                                                // 148\n    });                                                                                                                // 149\n    if (!_.isEmpty(cleared))                                                                                           // 150\n      copy.cleared = cleared;                                                                                          // 151\n    if (_.isEmpty(copy.fields))                                                                                        // 152\n      delete copy.fields;                                                                                              // 153\n  }                                                                                                                    // 154\n  // adjust types to basic                                                                                             // 155\n  _.each(['fields', 'params', 'result'], function (field) {                                                            // 156\n    if (_.has(copy, field))                                                                                            // 157\n      copy[field] = EJSON._adjustTypesToJSONValue(copy[field]);                                                        // 158\n  });                                                                                                                  // 159\n  if (msg.id && typeof msg.id !== 'string') {                                                                          // 160\n    throw new Error(\"Message id is not a string\");                                                                     // 161\n  }                                                                                                                    // 162\n  return JSON.stringify(copy);                                                                                         // 163\n};                                                                                                                     // 164\n                                                                                                                       // 165\n// This is private but it's used in a few places. accounts-base uses                                                   // 166\n// it to get the current user. accounts-password uses it to stash SRP                                                  // 167\n// state in the DDP session. Meteor.setTimeout and friends clear                                                       // 168\n// it. We can probably find a better way to factor this.                                                               // 169\nDDP._CurrentInvocation = new Meteor.EnvironmentVariable;                                                               // 170\n                                                                                                                       // 171\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function () {\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/ddp/random_stream.js                                                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n// RandomStream allows for generation of pseudo-random values, from a seed.                                            // 1\n//                                                                                                                     // 2\n// We use this for consistent 'random' numbers across the client and server.                                           // 3\n// We want to generate probably-unique IDs on the client, and we ideally want                                          // 4\n// the server to generate the same IDs when it executes the method.                                                    // 5\n//                                                                                                                     // 6\n// For generated values to be the same, we must seed ourselves the same way,                                           // 7\n// and we must keep track of the current state of our pseudo-random generators.                                        // 8\n// We call this state the scope. By default, we use the current DDP method                                             // 9\n// invocation as our scope.  DDP now allows the client to specify a randomSeed.                                        // 10\n// If a randomSeed is provided it will be used to seed our random sequences.                                           // 11\n// In this way, client and server method calls will generate the same values.                                          // 12\n//                                                                                                                     // 13\n// We expose multiple named streams; each stream is independent                                                        // 14\n// and is seeded differently (but predictably from the name).                                                          // 15\n// By using multiple streams, we support reordering of requests,                                                       // 16\n// as long as they occur on different streams.                                                                         // 17\n//                                                                                                                     // 18\n// @param options {Optional Object}                                                                                    // 19\n//   seed: Array or value - Seed value(s) for the generator.                                                           // 20\n//                          If an array, will be used as-is                                                            // 21\n//                          If a value, will be converted to a single-value array                                      // 22\n//                          If omitted, a random array will be used as the seed.                                       // 23\nRandomStream = function (options) {                                                                                    // 24\n  var self = this;                                                                                                     // 25\n                                                                                                                       // 26\n  this.seed = [].concat(options.seed || randomToken());                                                                // 27\n                                                                                                                       // 28\n  this.sequences = {};                                                                                                 // 29\n};                                                                                                                     // 30\n                                                                                                                       // 31\n// Returns a random string of sufficient length for a random seed.                                                     // 32\n// This is a placeholder function; a similar function is planned                                                       // 33\n// for Random itself; when that is added we should remove this function,                                               // 34\n// and call Random's randomToken instead.                                                                              // 35\nfunction randomToken() {                                                                                               // 36\n  return Random.hexString(20);                                                                                         // 37\n};                                                                                                                     // 38\n                                                                                                                       // 39\n// Returns the random stream with the specified name, in the specified scope.                                          // 40\n// If scope is null (or otherwise falsey) then we will use Random, which will                                          // 41\n// give us as random numbers as possible, but won't produce the same                                                   // 42\n// values across client and server.                                                                                    // 43\n// However, scope will normally be the current DDP method invocation, so                                               // 44\n// we'll use the stream with the specified name, and we should get consistent                                          // 45\n// values on the client and server sides of a method call.                                                             // 46\nRandomStream.get = function (scope, name) {                                                                            // 47\n  if (!name) {                                                                                                         // 48\n    name = \"default\";                                                                                                  // 49\n  }                                                                                                                    // 50\n  if (!scope) {                                                                                                        // 51\n    // There was no scope passed in;                                                                                   // 52\n    // the sequence won't actually be reproducible.                                                                    // 53\n    return Random;                                                                                                     // 54\n  }                                                                                                                    // 55\n  var randomStream = scope.randomStream;                                                                               // 56\n  if (!randomStream) {                                                                                                 // 57\n    scope.randomStream = randomStream = new RandomStream({                                                             // 58\n      seed: scope.randomSeed                                                                                           // 59\n    });                                                                                                                // 60\n  }                                                                                                                    // 61\n  return randomStream._sequence(name);                                                                                 // 62\n};                                                                                                                     // 63\n                                                                                                                       // 64\n// Returns the named sequence of pseudo-random values.                                                                 // 65\n// The scope will be DDP._CurrentInvocation.get(), so the stream will produce                                          // 66\n// consistent values for method calls on the client and server.                                                        // 67\nDDP.randomStream = function (name) {                                                                                   // 68\n  var scope = DDP._CurrentInvocation.get();                                                                            // 69\n  return RandomStream.get(scope, name);                                                                                // 70\n};                                                                                                                     // 71\n                                                                                                                       // 72\n// Creates a randomSeed for passing to a method call.                                                                  // 73\n// Note that we take enclosing as an argument,                                                                         // 74\n// though we expect it to be DDP._CurrentInvocation.get()                                                              // 75\n// However, we often evaluate makeRpcSeed lazily, and thus the relevant                                                // 76\n// invocation may not be the one currently in scope.                                                                   // 77\n// If enclosing is null, we'll use Random and values won't be repeatable.                                              // 78\nmakeRpcSeed = function (enclosing, methodName) {                                                                       // 79\n  var stream = RandomStream.get(enclosing, '/rpc/' + methodName);                                                      // 80\n  return stream.hexString(20);                                                                                         // 81\n};                                                                                                                     // 82\n                                                                                                                       // 83\n_.extend(RandomStream.prototype, {                                                                                     // 84\n  // Get a random sequence with the specified name, creating it if does not exist.                                     // 85\n  // New sequences are seeded with the seed concatenated with the name.                                                // 86\n  // By passing a seed into Random.create, we use the Alea generator.                                                  // 87\n  _sequence: function (name) {                                                                                         // 88\n    var self = this;                                                                                                   // 89\n                                                                                                                       // 90\n    var sequence = self.sequences[name] || null;                                                                       // 91\n    if (sequence === null) {                                                                                           // 92\n      var sequenceSeed = self.seed.concat(name);                                                                       // 93\n      for (var i = 0; i < sequenceSeed.length; i++) {                                                                  // 94\n        if (_.isFunction(sequenceSeed[i])) {                                                                           // 95\n          sequenceSeed[i] = sequenceSeed[i]();                                                                         // 96\n        }                                                                                                              // 97\n      }                                                                                                                // 98\n      self.sequences[name] = sequence = Random.createWithSeeds.apply(null, sequenceSeed);                              // 99\n    }                                                                                                                  // 100\n    return sequence;                                                                                                   // 101\n  }                                                                                                                    // 102\n});                                                                                                                    // 103\n                                                                                                                       // 104\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function () {\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/ddp/livedata_connection.js                                                                                 //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nif (Meteor.isServer) {                                                                                                 // 1\n  var path = Npm.require('path');                                                                                      // 2\n  var Fiber = Npm.require('fibers');                                                                                   // 3\n  var Future = Npm.require(path.join('fibers', 'future'));                                                             // 4\n}                                                                                                                      // 5\n                                                                                                                       // 6\n// @param url {String|Object} URL to Meteor app,                                                                       // 7\n//   or an object as a test hook (see code)                                                                            // 8\n// Options:                                                                                                            // 9\n//   reloadWithOutstanding: is it OK to reload if there are outstanding methods?                                       // 10\n//   headers: extra headers to send on the websockets connection, for                                                  // 11\n//     server-to-server DDP only                                                                                       // 12\n//   _sockjsOptions: Specifies options to pass through to the sockjs client                                            // 13\n//   onDDPNegotiationVersionFailure: callback when version negotiation fails.                                          // 14\n//                                                                                                                     // 15\n// XXX There should be a way to destroy a DDP connection, causing all                                                  // 16\n// outstanding method calls to fail.                                                                                   // 17\n//                                                                                                                     // 18\n// XXX Our current way of handling failure and reconnection is great                                                   // 19\n// for an app (where we want to tolerate being disconnected as an                                                      // 20\n// expect state, and keep trying forever to reconnect) but cumbersome                                                  // 21\n// for something like a command line tool that wants to make a                                                         // 22\n// connection, call a method, and print an error if connection                                                         // 23\n// fails. We should have better usability in the latter case (while                                                    // 24\n// still transparently reconnecting if it's just a transient failure                                                   // 25\n// or the server migrating us).                                                                                        // 26\nvar Connection = function (url, options) {                                                                             // 27\n  var self = this;                                                                                                     // 28\n  options = _.extend({                                                                                                 // 29\n    onConnected: function () {},                                                                                       // 30\n    onDDPVersionNegotiationFailure: function (description) {                                                           // 31\n      Meteor._debug(description);                                                                                      // 32\n    },                                                                                                                 // 33\n    heartbeatInterval: 35000,                                                                                          // 34\n    heartbeatTimeout: 15000,                                                                                           // 35\n    // These options are only for testing.                                                                             // 36\n    reloadWithOutstanding: false,                                                                                      // 37\n    supportedDDPVersions: SUPPORTED_DDP_VERSIONS,                                                                      // 38\n    retry: true,                                                                                                       // 39\n    respondToPings: true                                                                                               // 40\n  }, options);                                                                                                         // 41\n                                                                                                                       // 42\n  // If set, called when we reconnect, queuing method calls _before_ the                                               // 43\n  // existing outstanding ones. This is the only data member that is part of the                                       // 44\n  // public API!                                                                                                       // 45\n  self.onReconnect = null;                                                                                             // 46\n                                                                                                                       // 47\n  // as a test hook, allow passing a stream instead of a url.                                                          // 48\n  if (typeof url === \"object\") {                                                                                       // 49\n    self._stream = url;                                                                                                // 50\n  } else {                                                                                                             // 51\n    self._stream = new LivedataTest.ClientStream(url, {                                                                // 52\n      retry: options.retry,                                                                                            // 53\n      headers: options.headers,                                                                                        // 54\n      _sockjsOptions: options._sockjsOptions,                                                                          // 55\n      // Used to keep some tests quiet, or for other cases in which                                                    // 56\n      // the right thing to do with connection errors is to silently                                                   // 57\n      // fail (e.g. sending package usage stats). At some point we                                                     // 58\n      // should have a real API for handling client-stream-level                                                       // 59\n      // errors.                                                                                                       // 60\n      _dontPrintErrors: options._dontPrintErrors,                                                                      // 61\n      connectTimeoutMs: options.connectTimeoutMs                                                                       // 62\n    });                                                                                                                // 63\n  }                                                                                                                    // 64\n                                                                                                                       // 65\n  self._lastSessionId = null;                                                                                          // 66\n  self._versionSuggestion = null;  // The last proposed DDP version.                                                   // 67\n  self._version = null;   // The DDP version agreed on by client and server.                                           // 68\n  self._stores = {}; // name -> object with methods                                                                    // 69\n  self._methodHandlers = {}; // name -> func                                                                           // 70\n  self._nextMethodId = 1;                                                                                              // 71\n  self._supportedDDPVersions = options.supportedDDPVersions;                                                           // 72\n                                                                                                                       // 73\n  self._heartbeatInterval = options.heartbeatInterval;                                                                 // 74\n  self._heartbeatTimeout = options.heartbeatTimeout;                                                                   // 75\n                                                                                                                       // 76\n  // Tracks methods which the user has tried to call but which have not yet                                            // 77\n  // called their user callback (ie, they are waiting on their result or for all                                       // 78\n  // of their writes to be written to the local cache). Map from method ID to                                          // 79\n  // MethodInvoker object.                                                                                             // 80\n  self._methodInvokers = {};                                                                                           // 81\n                                                                                                                       // 82\n  // Tracks methods which the user has called but whose result messages have not                                       // 83\n  // arrived yet.                                                                                                      // 84\n  //                                                                                                                   // 85\n  // _outstandingMethodBlocks is an array of blocks of methods. Each block                                             // 86\n  // represents a set of methods that can run at the same time. The first block                                        // 87\n  // represents the methods which are currently in flight; subsequent blocks                                           // 88\n  // must wait for previous blocks to be fully finished before they can be sent                                        // 89\n  // to the server.                                                                                                    // 90\n  //                                                                                                                   // 91\n  // Each block is an object with the following fields:                                                                // 92\n  // - methods: a list of MethodInvoker objects                                                                        // 93\n  // - wait: a boolean; if true, this block had a single method invoked with                                           // 94\n  //         the \"wait\" option                                                                                         // 95\n  //                                                                                                                   // 96\n  // There will never be adjacent blocks with wait=false, because the only thing                                       // 97\n  // that makes methods need to be serialized is a wait method.                                                        // 98\n  //                                                                                                                   // 99\n  // Methods are removed from the first block when their \"result\" is                                                   // 100\n  // received. The entire first block is only removed when all of the in-flight                                        // 101\n  // methods have received their results (so the \"methods\" list is empty) *AND*                                        // 102\n  // all of the data written by those methods are visible in the local cache. So                                       // 103\n  // it is possible for the first block's methods list to be empty, if we are                                          // 104\n  // still waiting for some objects to quiesce.                                                                        // 105\n  //                                                                                                                   // 106\n  // Example:                                                                                                          // 107\n  //  _outstandingMethodBlocks = [                                                                                     // 108\n  //    {wait: false, methods: []},                                                                                    // 109\n  //    {wait: true, methods: [<MethodInvoker for 'login'>]},                                                          // 110\n  //    {wait: false, methods: [<MethodInvoker for 'foo'>,                                                             // 111\n  //                            <MethodInvoker for 'bar'>]}]                                                           // 112\n  // This means that there were some methods which were sent to the server and                                         // 113\n  // which have returned their results, but some of the data written by                                                // 114\n  // the methods may not be visible in the local cache. Once all that data is                                          // 115\n  // visible, we will send a 'login' method. Once the login method has returned                                        // 116\n  // and all the data is visible (including re-running subs if userId changes),                                        // 117\n  // we will send the 'foo' and 'bar' methods in parallel.                                                             // 118\n  self._outstandingMethodBlocks = [];                                                                                  // 119\n                                                                                                                       // 120\n  // method ID -> array of objects with keys 'collection' and 'id', listing                                            // 121\n  // documents written by a given method's stub. keys are associated with                                              // 122\n  // methods whose stub wrote at least one document, and whose data-done message                                       // 123\n  // has not yet been received.                                                                                        // 124\n  self._documentsWrittenByStub = {};                                                                                   // 125\n  // collection -> IdMap of \"server document\" object. A \"server document\" has:                                         // 126\n  // - \"document\": the version of the document according the                                                           // 127\n  //   server (ie, the snapshot before a stub wrote it, amended by any changes                                         // 128\n  //   received from the server)                                                                                       // 129\n  //   It is undefined if we think the document does not exist                                                         // 130\n  // - \"writtenByStubs\": a set of method IDs whose stubs wrote to the document                                         // 131\n  //   whose \"data done\" messages have not yet been processed                                                          // 132\n  self._serverDocuments = {};                                                                                          // 133\n                                                                                                                       // 134\n  // Array of callbacks to be called after the next update of the local                                                // 135\n  // cache. Used for:                                                                                                  // 136\n  //  - Calling methodInvoker.dataVisible and sub ready callbacks after                                                // 137\n  //    the relevant data is flushed.                                                                                  // 138\n  //  - Invoking the callbacks of \"half-finished\" methods after reconnect                                              // 139\n  //    quiescence. Specifically, methods whose result was received over the old                                       // 140\n  //    connection (so we don't re-send it) but whose data had not been made                                           // 141\n  //    visible.                                                                                                       // 142\n  self._afterUpdateCallbacks = [];                                                                                     // 143\n                                                                                                                       // 144\n  // In two contexts, we buffer all incoming data messages and then process them                                       // 145\n  // all at once in a single update:                                                                                   // 146\n  //   - During reconnect, we buffer all data messages until all subs that had                                         // 147\n  //     been ready before reconnect are ready again, and all methods that are                                         // 148\n  //     active have returned their \"data done message\"; then                                                          // 149\n  //   - During the execution of a \"wait\" method, we buffer all data messages                                          // 150\n  //     until the wait method gets its \"data done\" message. (If the wait method                                       // 151\n  //     occurs during reconnect, it doesn't get any special handling.)                                                // 152\n  // all data messages are processed in one update.                                                                    // 153\n  //                                                                                                                   // 154\n  // The following fields are used for this \"quiescence\" process.                                                      // 155\n                                                                                                                       // 156\n  // This buffers the messages that aren't being processed yet.                                                        // 157\n  self._messagesBufferedUntilQuiescence = [];                                                                          // 158\n  // Map from method ID -> true. Methods are removed from this when their                                              // 159\n  // \"data done\" message is received, and we will not quiesce until it is                                              // 160\n  // empty.                                                                                                            // 161\n  self._methodsBlockingQuiescence = {};                                                                                // 162\n  // map from sub ID -> true for subs that were ready (ie, called the sub                                              // 163\n  // ready callback) before reconnect but haven't become ready again yet                                               // 164\n  self._subsBeingRevived = {}; // map from sub._id -> true                                                             // 165\n  // if true, the next data update should reset all stores. (set during                                                // 166\n  // reconnect.)                                                                                                       // 167\n  self._resetStores = false;                                                                                           // 168\n                                                                                                                       // 169\n  // name -> array of updates for (yet to be created) collections                                                      // 170\n  self._updatesForUnknownStores = {};                                                                                  // 171\n  // if we're blocking a migration, the retry func                                                                     // 172\n  self._retryMigrate = null;                                                                                           // 173\n                                                                                                                       // 174\n  // metadata for subscriptions.  Map from sub ID to object with keys:                                                 // 175\n  //   - id                                                                                                            // 176\n  //   - name                                                                                                          // 177\n  //   - params                                                                                                        // 178\n  //   - inactive (if true, will be cleaned up if not reused in re-run)                                                // 179\n  //   - ready (has the 'ready' message been received?)                                                                // 180\n  //   - readyCallback (an optional callback to call when ready)                                                       // 181\n  //   - errorCallback (an optional callback to call if the sub terminates with                                        // 182\n  //                    an error, XXX COMPAT WITH 1.0.3.1)                                                             // 183\n  //   - stopCallback (an optional callback to call when the sub terminates                                            // 184\n  //     for any reason, with an error argument if an error triggered the stop)                                        // 185\n  self._subscriptions = {};                                                                                            // 186\n                                                                                                                       // 187\n  // Reactive userId.                                                                                                  // 188\n  self._userId = null;                                                                                                 // 189\n  self._userIdDeps = new Tracker.Dependency;                                                                           // 190\n                                                                                                                       // 191\n  // Block auto-reload while we're waiting for method responses.                                                       // 192\n  if (Meteor.isClient && Package.reload && !options.reloadWithOutstanding) {                                           // 193\n    Package.reload.Reload._onMigrate(function (retry) {                                                                // 194\n      if (!self._readyToMigrate()) {                                                                                   // 195\n        if (self._retryMigrate)                                                                                        // 196\n          throw new Error(\"Two migrations in progress?\");                                                              // 197\n        self._retryMigrate = retry;                                                                                    // 198\n        return false;                                                                                                  // 199\n      } else {                                                                                                         // 200\n        return [true];                                                                                                 // 201\n      }                                                                                                                // 202\n    });                                                                                                                // 203\n  }                                                                                                                    // 204\n                                                                                                                       // 205\n  var onMessage = function (raw_msg) {                                                                                 // 206\n    try {                                                                                                              // 207\n      var msg = parseDDP(raw_msg);                                                                                     // 208\n    } catch (e) {                                                                                                      // 209\n      Meteor._debug(\"Exception while parsing DDP\", e);                                                                 // 210\n      return;                                                                                                          // 211\n    }                                                                                                                  // 212\n                                                                                                                       // 213\n    if (msg === null || !msg.msg) {                                                                                    // 214\n      // XXX COMPAT WITH 0.6.6. ignore the old welcome message for back                                                // 215\n      // compat.  Remove this 'if' once the server stops sending welcome                                               // 216\n      // messages (stream_server.js).                                                                                  // 217\n      if (! (msg && msg.server_id))                                                                                    // 218\n        Meteor._debug(\"discarding invalid livedata message\", msg);                                                     // 219\n      return;                                                                                                          // 220\n    }                                                                                                                  // 221\n                                                                                                                       // 222\n    if (msg.msg === 'connected') {                                                                                     // 223\n      self._version = self._versionSuggestion;                                                                         // 224\n      self._livedata_connected(msg);                                                                                   // 225\n      options.onConnected();                                                                                           // 226\n    }                                                                                                                  // 227\n    else if (msg.msg == 'failed') {                                                                                    // 228\n      if (_.contains(self._supportedDDPVersions, msg.version)) {                                                       // 229\n        self._versionSuggestion = msg.version;                                                                         // 230\n        self._stream.reconnect({_force: true});                                                                        // 231\n      } else {                                                                                                         // 232\n        var description =                                                                                              // 233\n              \"DDP version negotiation failed; server requested version \" + msg.version;                               // 234\n        self._stream.disconnect({_permanent: true, _error: description});                                              // 235\n        options.onDDPVersionNegotiationFailure(description);                                                           // 236\n      }                                                                                                                // 237\n    }                                                                                                                  // 238\n    else if (msg.msg === 'ping') {                                                                                     // 239\n      if (options.respondToPings)                                                                                      // 240\n        self._send({msg: \"pong\", id: msg.id});                                                                         // 241\n      if (self._heartbeat)                                                                                             // 242\n        self._heartbeat.pingReceived();                                                                                // 243\n    }                                                                                                                  // 244\n    else if (msg.msg === 'pong') {                                                                                     // 245\n      if (self._heartbeat) {                                                                                           // 246\n        self._heartbeat.pongReceived();                                                                                // 247\n      }                                                                                                                // 248\n    }                                                                                                                  // 249\n    else if (_.include(['added', 'changed', 'removed', 'ready', 'updated'], msg.msg))                                  // 250\n      self._livedata_data(msg);                                                                                        // 251\n    else if (msg.msg === 'nosub')                                                                                      // 252\n      self._livedata_nosub(msg);                                                                                       // 253\n    else if (msg.msg === 'result')                                                                                     // 254\n      self._livedata_result(msg);                                                                                      // 255\n    else if (msg.msg === 'error')                                                                                      // 256\n      self._livedata_error(msg);                                                                                       // 257\n    else                                                                                                               // 258\n      Meteor._debug(\"discarding unknown livedata message type\", msg);                                                  // 259\n  };                                                                                                                   // 260\n                                                                                                                       // 261\n  var onReset = function () {                                                                                          // 262\n    // Send a connect message at the beginning of the stream.                                                          // 263\n    // NOTE: reset is called even on the first connection, so this is                                                  // 264\n    // the only place we send this message.                                                                            // 265\n    var msg = {msg: 'connect'};                                                                                        // 266\n    if (self._lastSessionId)                                                                                           // 267\n      msg.session = self._lastSessionId;                                                                               // 268\n    msg.version = self._versionSuggestion || self._supportedDDPVersions[0];                                            // 269\n    self._versionSuggestion = msg.version;                                                                             // 270\n    msg.support = self._supportedDDPVersions;                                                                          // 271\n    self._send(msg);                                                                                                   // 272\n                                                                                                                       // 273\n    // Now, to minimize setup latency, go ahead and blast out all of                                                   // 274\n    // our pending methods ands subscriptions before we've even taken                                                  // 275\n    // the necessary RTT to know if we successfully reconnected. (1)                                                   // 276\n    // They're supposed to be idempotent; (2) even if we did                                                           // 277\n    // reconnect, we're not sure what messages might have gotten lost                                                  // 278\n    // (in either direction) since we were disconnected (TCP being                                                     // 279\n    // sloppy about that.)                                                                                             // 280\n                                                                                                                       // 281\n    // If the current block of methods all got their results (but didn't all get                                       // 282\n    // their data visible), discard the empty block now.                                                               // 283\n    if (! _.isEmpty(self._outstandingMethodBlocks) &&                                                                  // 284\n        _.isEmpty(self._outstandingMethodBlocks[0].methods)) {                                                         // 285\n      self._outstandingMethodBlocks.shift();                                                                           // 286\n    }                                                                                                                  // 287\n                                                                                                                       // 288\n    // Mark all messages as unsent, they have not yet been sent on this                                                // 289\n    // connection.                                                                                                     // 290\n    _.each(self._methodInvokers, function (m) {                                                                        // 291\n      m.sentMessage = false;                                                                                           // 292\n    });                                                                                                                // 293\n                                                                                                                       // 294\n    // If an `onReconnect` handler is set, call it first. Go through                                                   // 295\n    // some hoops to ensure that methods that are called from within                                                   // 296\n    // `onReconnect` get executed _before_ ones that were originally                                                   // 297\n    // outstanding (since `onReconnect` is used to re-establish auth                                                   // 298\n    // certificates)                                                                                                   // 299\n    if (self.onReconnect)                                                                                              // 300\n      self._callOnReconnectAndSendAppropriateOutstandingMethods();                                                     // 301\n    else                                                                                                               // 302\n      self._sendOutstandingMethods();                                                                                  // 303\n                                                                                                                       // 304\n    // add new subscriptions at the end. this way they take effect after                                               // 305\n    // the handlers and we don't see flicker.                                                                          // 306\n    _.each(self._subscriptions, function (sub, id) {                                                                   // 307\n      self._send({                                                                                                     // 308\n        msg: 'sub',                                                                                                    // 309\n        id: id,                                                                                                        // 310\n        name: sub.name,                                                                                                // 311\n        params: sub.params                                                                                             // 312\n      });                                                                                                              // 313\n    });                                                                                                                // 314\n  };                                                                                                                   // 315\n                                                                                                                       // 316\n  var onDisconnect = function () {                                                                                     // 317\n    if (self._heartbeat) {                                                                                             // 318\n      self._heartbeat.stop();                                                                                          // 319\n      self._heartbeat = null;                                                                                          // 320\n    }                                                                                                                  // 321\n  };                                                                                                                   // 322\n                                                                                                                       // 323\n  if (Meteor.isServer) {                                                                                               // 324\n    self._stream.on('message', Meteor.bindEnvironment(onMessage, Meteor._debug));                                      // 325\n    self._stream.on('reset', Meteor.bindEnvironment(onReset, Meteor._debug));                                          // 326\n    self._stream.on('disconnect', Meteor.bindEnvironment(onDisconnect, Meteor._debug));                                // 327\n  } else {                                                                                                             // 328\n    self._stream.on('message', onMessage);                                                                             // 329\n    self._stream.on('reset', onReset);                                                                                 // 330\n    self._stream.on('disconnect', onDisconnect);                                                                       // 331\n  }                                                                                                                    // 332\n};                                                                                                                     // 333\n                                                                                                                       // 334\n// A MethodInvoker manages sending a method to the server and calling the user's                                       // 335\n// callbacks. On construction, it registers itself in the connection's                                                 // 336\n// _methodInvokers map; it removes itself once the method is fully finished and                                        // 337\n// the callback is invoked. This occurs when it has both received a result,                                            // 338\n// and the data written by it is fully visible.                                                                        // 339\nvar MethodInvoker = function (options) {                                                                               // 340\n  var self = this;                                                                                                     // 341\n                                                                                                                       // 342\n  // Public (within this file) fields.                                                                                 // 343\n  self.methodId = options.methodId;                                                                                    // 344\n  self.sentMessage = false;                                                                                            // 345\n                                                                                                                       // 346\n  self._callback = options.callback;                                                                                   // 347\n  self._connection = options.connection;                                                                               // 348\n  self._message = options.message;                                                                                     // 349\n  self._onResultReceived = options.onResultReceived || function () {};                                                 // 350\n  self._wait = options.wait;                                                                                           // 351\n  self._methodResult = null;                                                                                           // 352\n  self._dataVisible = false;                                                                                           // 353\n                                                                                                                       // 354\n  // Register with the connection.                                                                                     // 355\n  self._connection._methodInvokers[self.methodId] = self;                                                              // 356\n};                                                                                                                     // 357\n_.extend(MethodInvoker.prototype, {                                                                                    // 358\n  // Sends the method message to the server. May be called additional times if                                         // 359\n  // we lose the connection and reconnect before receiving a result.                                                   // 360\n  sendMessage: function () {                                                                                           // 361\n    var self = this;                                                                                                   // 362\n    // This function is called before sending a method (including resending on                                         // 363\n    // reconnect). We should only (re)send methods where we don't already have a                                       // 364\n    // result!                                                                                                         // 365\n    if (self.gotResult())                                                                                              // 366\n      throw new Error(\"sendingMethod is called on method with result\");                                                // 367\n                                                                                                                       // 368\n    // If we're re-sending it, it doesn't matter if data was written the first                                         // 369\n    // time.                                                                                                           // 370\n    self._dataVisible = false;                                                                                         // 371\n                                                                                                                       // 372\n    self.sentMessage = true;                                                                                           // 373\n                                                                                                                       // 374\n    // If this is a wait method, make all data messages be buffered until it is                                        // 375\n    // done.                                                                                                           // 376\n    if (self._wait)                                                                                                    // 377\n      self._connection._methodsBlockingQuiescence[self.methodId] = true;                                               // 378\n                                                                                                                       // 379\n    // Actually send the message.                                                                                      // 380\n    self._connection._send(self._message);                                                                             // 381\n  },                                                                                                                   // 382\n  // Invoke the callback, if we have both a result and know that all data has                                          // 383\n  // been written to the local cache.                                                                                  // 384\n  _maybeInvokeCallback: function () {                                                                                  // 385\n    var self = this;                                                                                                   // 386\n    if (self._methodResult && self._dataVisible) {                                                                     // 387\n      // Call the callback. (This won't throw: the callback was wrapped with                                           // 388\n      // bindEnvironment.)                                                                                             // 389\n      self._callback(self._methodResult[0], self._methodResult[1]);                                                    // 390\n                                                                                                                       // 391\n      // Forget about this method.                                                                                     // 392\n      delete self._connection._methodInvokers[self.methodId];                                                          // 393\n                                                                                                                       // 394\n      // Let the connection know that this method is finished, so it can try to                                        // 395\n      // move on to the next block of methods.                                                                         // 396\n      self._connection._outstandingMethodFinished();                                                                   // 397\n    }                                                                                                                  // 398\n  },                                                                                                                   // 399\n  // Call with the result of the method from the server. Only may be called                                            // 400\n  // once; once it is called, you should not call sendMessage again.                                                   // 401\n  // If the user provided an onResultReceived callback, call it immediately.                                           // 402\n  // Then invoke the main callback if data is also visible.                                                            // 403\n  receiveResult: function (err, result) {                                                                              // 404\n    var self = this;                                                                                                   // 405\n    if (self.gotResult())                                                                                              // 406\n      throw new Error(\"Methods should only receive results once\");                                                     // 407\n    self._methodResult = [err, result];                                                                                // 408\n    self._onResultReceived(err, result);                                                                               // 409\n    self._maybeInvokeCallback();                                                                                       // 410\n  },                                                                                                                   // 411\n  // Call this when all data written by the method is visible. This means that                                         // 412\n  // the method has returns its \"data is done\" message *AND* all server                                                // 413\n  // documents that are buffered at that time have been written to the local                                           // 414\n  // cache. Invokes the main callback if the result has been received.                                                 // 415\n  dataVisible: function () {                                                                                           // 416\n    var self = this;                                                                                                   // 417\n    self._dataVisible = true;                                                                                          // 418\n    self._maybeInvokeCallback();                                                                                       // 419\n  },                                                                                                                   // 420\n  // True if receiveResult has been called.                                                                            // 421\n  gotResult: function () {                                                                                             // 422\n    var self = this;                                                                                                   // 423\n    return !!self._methodResult;                                                                                       // 424\n  }                                                                                                                    // 425\n});                                                                                                                    // 426\n                                                                                                                       // 427\n_.extend(Connection.prototype, {                                                                                       // 428\n  // 'name' is the name of the data on the wire that should go in the                                                  // 429\n  // store. 'wrappedStore' should be an object with methods beginUpdate, update,                                       // 430\n  // endUpdate, saveOriginals, retrieveOriginals. see Collection for an example.                                       // 431\n  registerStore: function (name, wrappedStore) {                                                                       // 432\n    var self = this;                                                                                                   // 433\n                                                                                                                       // 434\n    if (name in self._stores)                                                                                          // 435\n      return false;                                                                                                    // 436\n                                                                                                                       // 437\n    // Wrap the input object in an object which makes any store method not                                             // 438\n    // implemented by 'store' into a no-op.                                                                            // 439\n    var store = {};                                                                                                    // 440\n    _.each(['update', 'beginUpdate', 'endUpdate', 'saveOriginals',                                                     // 441\n            'retrieveOriginals'], function (method) {                                                                  // 442\n              store[method] = function () {                                                                            // 443\n                return (wrappedStore[method]                                                                           // 444\n                        ? wrappedStore[method].apply(wrappedStore, arguments)                                          // 445\n                        : undefined);                                                                                  // 446\n              };                                                                                                       // 447\n            });                                                                                                        // 448\n                                                                                                                       // 449\n    self._stores[name] = store;                                                                                        // 450\n                                                                                                                       // 451\n    var queued = self._updatesForUnknownStores[name];                                                                  // 452\n    if (queued) {                                                                                                      // 453\n      store.beginUpdate(queued.length, false);                                                                         // 454\n      _.each(queued, function (msg) {                                                                                  // 455\n        store.update(msg);                                                                                             // 456\n      });                                                                                                              // 457\n      store.endUpdate();                                                                                               // 458\n      delete self._updatesForUnknownStores[name];                                                                      // 459\n    }                                                                                                                  // 460\n                                                                                                                       // 461\n    return true;                                                                                                       // 462\n  },                                                                                                                   // 463\n                                                                                                                       // 464\n  /**                                                                                                                  // 465\n   * @memberOf Meteor                                                                                                  // 466\n   * @summary Subscribe to a record set.  Returns a handle that provides                                               // 467\n   * `stop()` and `ready()` methods.                                                                                   // 468\n   * @locus Client                                                                                                     // 469\n   * @param {String} name Name of the subscription.  Matches the name of the                                           // 470\n   * server's `publish()` call.                                                                                        // 471\n   * @param {Any} [arg1,arg2...] Optional arguments passed to publisher                                                // 472\n   * function on server.                                                                                               // 473\n   * @param {Function|Object} [callbacks] Optional. May include `onStop`                                               // 474\n   * and `onReady` callbacks. If there is an error, it is passed as an                                                 // 475\n   * argument to `onStop`. If a function is passed instead of an object, it                                            // 476\n   * is interpreted as an `onReady` callback.                                                                          // 477\n   */                                                                                                                  // 478\n  subscribe: function (name /* .. [arguments] .. (callback|callbacks) */) {                                            // 479\n    var self = this;                                                                                                   // 480\n                                                                                                                       // 481\n    var params = Array.prototype.slice.call(arguments, 1);                                                             // 482\n    var callbacks = {};                                                                                                // 483\n    if (params.length) {                                                                                               // 484\n      var lastParam = params[params.length - 1];                                                                       // 485\n      if (_.isFunction(lastParam)) {                                                                                   // 486\n        callbacks.onReady = params.pop();                                                                              // 487\n      } else if (lastParam &&                                                                                          // 488\n        // XXX COMPAT WITH 1.0.3.1 onError used to exist, but now we use                                               // 489\n        // onStop with an error callback instead.                                                                      // 490\n        _.any([lastParam.onReady, lastParam.onError, lastParam.onStop],                                                // 491\n          _.isFunction)) {                                                                                             // 492\n        callbacks = params.pop();                                                                                      // 493\n      }                                                                                                                // 494\n    }                                                                                                                  // 495\n                                                                                                                       // 496\n    // Is there an existing sub with the same name and param, run in an                                                // 497\n    // invalidated Computation? This will happen if we are rerunning an                                                // 498\n    // existing computation.                                                                                           // 499\n    //                                                                                                                 // 500\n    // For example, consider a rerun of:                                                                               // 501\n    //                                                                                                                 // 502\n    //     Tracker.autorun(function () {                                                                               // 503\n    //       Meteor.subscribe(\"foo\", Session.get(\"foo\"));                                                              // 504\n    //       Meteor.subscribe(\"bar\", Session.get(\"bar\"));                                                              // 505\n    //     });                                                                                                         // 506\n    //                                                                                                                 // 507\n    // If \"foo\" has changed but \"bar\" has not, we will match the \"bar\"                                                 // 508\n    // subcribe to an existing inactive subscription in order to not                                                   // 509\n    // unsub and resub the subscription unnecessarily.                                                                 // 510\n    //                                                                                                                 // 511\n    // We only look for one such sub; if there are N apparently-identical subs                                         // 512\n    // being invalidated, we will require N matching subscribe calls to keep                                           // 513\n    // them all active.                                                                                                // 514\n    var existing = _.find(self._subscriptions, function (sub) {                                                        // 515\n      return sub.inactive && sub.name === name &&                                                                      // 516\n        EJSON.equals(sub.params, params);                                                                              // 517\n    });                                                                                                                // 518\n                                                                                                                       // 519\n    var id;                                                                                                            // 520\n    if (existing) {                                                                                                    // 521\n      id = existing.id;                                                                                                // 522\n      existing.inactive = false; // reactivate                                                                         // 523\n                                                                                                                       // 524\n      if (callbacks.onReady) {                                                                                         // 525\n        // If the sub is not already ready, replace any ready callback with the                                        // 526\n        // one provided now. (It's not really clear what users would expect for                                        // 527\n        // an onReady callback inside an autorun; the semantics we provide is                                          // 528\n        // that at the time the sub first becomes ready, we call the last                                              // 529\n        // onReady callback provided, if any.)                                                                         // 530\n        if (!existing.ready)                                                                                           // 531\n          existing.readyCallback = callbacks.onReady;                                                                  // 532\n      }                                                                                                                // 533\n                                                                                                                       // 534\n      // XXX COMPAT WITH 1.0.3.1 we used to have onError but now we call                                               // 535\n      // onStop with an optional error argument                                                                        // 536\n      if (callbacks.onError) {                                                                                         // 537\n        // Replace existing callback if any, so that errors aren't                                                     // 538\n        // double-reported.                                                                                            // 539\n        existing.errorCallback = callbacks.onError;                                                                    // 540\n      }                                                                                                                // 541\n                                                                                                                       // 542\n      if (callbacks.onStop) {                                                                                          // 543\n        existing.stopCallback = callbacks.onStop;                                                                      // 544\n      }                                                                                                                // 545\n    } else {                                                                                                           // 546\n      // New sub! Generate an id, save it locally, and send message.                                                   // 547\n      id = Random.id();                                                                                                // 548\n      self._subscriptions[id] = {                                                                                      // 549\n        id: id,                                                                                                        // 550\n        name: name,                                                                                                    // 551\n        params: EJSON.clone(params),                                                                                   // 552\n        inactive: false,                                                                                               // 553\n        ready: false,                                                                                                  // 554\n        readyDeps: new Tracker.Dependency,                                                                             // 555\n        readyCallback: callbacks.onReady,                                                                              // 556\n        // XXX COMPAT WITH 1.0.3.1 #errorCallback                                                                      // 557\n        errorCallback: callbacks.onError,                                                                              // 558\n        stopCallback: callbacks.onStop,                                                                                // 559\n        connection: self,                                                                                              // 560\n        remove: function() {                                                                                           // 561\n          delete this.connection._subscriptions[this.id];                                                              // 562\n          this.ready && this.readyDeps.changed();                                                                      // 563\n        },                                                                                                             // 564\n        stop: function() {                                                                                             // 565\n          this.connection._send({msg: 'unsub', id: id});                                                               // 566\n          this.remove();                                                                                               // 567\n                                                                                                                       // 568\n          if (callbacks.onStop) {                                                                                      // 569\n            callbacks.onStop();                                                                                        // 570\n          }                                                                                                            // 571\n        }                                                                                                              // 572\n      };                                                                                                               // 573\n      self._send({msg: 'sub', id: id, name: name, params: params});                                                    // 574\n    }                                                                                                                  // 575\n                                                                                                                       // 576\n    // return a handle to the application.                                                                             // 577\n    var handle = {                                                                                                     // 578\n      stop: function () {                                                                                              // 579\n        if (!_.has(self._subscriptions, id))                                                                           // 580\n          return;                                                                                                      // 581\n                                                                                                                       // 582\n        self._subscriptions[id].stop();                                                                                // 583\n      },                                                                                                               // 584\n      ready: function () {                                                                                             // 585\n        // return false if we've unsubscribed.                                                                         // 586\n        if (!_.has(self._subscriptions, id))                                                                           // 587\n          return false;                                                                                                // 588\n        var record = self._subscriptions[id];                                                                          // 589\n        record.readyDeps.depend();                                                                                     // 590\n        return record.ready;                                                                                           // 591\n      },                                                                                                               // 592\n      subscriptionId: id                                                                                               // 593\n    };                                                                                                                 // 594\n                                                                                                                       // 595\n    if (Tracker.active) {                                                                                              // 596\n      // We're in a reactive computation, so we'd like to unsubscribe when the                                         // 597\n      // computation is invalidated... but not if the rerun just re-subscribes                                         // 598\n      // to the same subscription!  When a rerun happens, we use onInvalidate                                          // 599\n      // as a change to mark the subscription \"inactive\" so that it can                                                // 600\n      // be reused from the rerun.  If it isn't reused, it's killed from                                               // 601\n      // an afterFlush.                                                                                                // 602\n      Tracker.onInvalidate(function (c) {                                                                              // 603\n        if (_.has(self._subscriptions, id))                                                                            // 604\n          self._subscriptions[id].inactive = true;                                                                     // 605\n                                                                                                                       // 606\n        Tracker.afterFlush(function () {                                                                               // 607\n          if (_.has(self._subscriptions, id) &&                                                                        // 608\n              self._subscriptions[id].inactive)                                                                        // 609\n            handle.stop();                                                                                             // 610\n        });                                                                                                            // 611\n      });                                                                                                              // 612\n    }                                                                                                                  // 613\n                                                                                                                       // 614\n    return handle;                                                                                                     // 615\n  },                                                                                                                   // 616\n                                                                                                                       // 617\n  // options:                                                                                                          // 618\n  // - onLateError {Function(error)} called if an error was received after the ready event.                            // 619\n  //     (errors received before ready cause an error to be thrown)                                                    // 620\n  _subscribeAndWait: function (name, args, options) {                                                                  // 621\n    var self = this;                                                                                                   // 622\n    var f = new Future();                                                                                              // 623\n    var ready = false;                                                                                                 // 624\n    var handle;                                                                                                        // 625\n    args = args || [];                                                                                                 // 626\n    args.push({                                                                                                        // 627\n      onReady: function () {                                                                                           // 628\n        ready = true;                                                                                                  // 629\n        f['return']();                                                                                                 // 630\n      },                                                                                                               // 631\n      onError: function (e) {                                                                                          // 632\n        if (!ready)                                                                                                    // 633\n          f['throw'](e);                                                                                               // 634\n        else                                                                                                           // 635\n          options && options.onLateError && options.onLateError(e);                                                    // 636\n      }                                                                                                                // 637\n    });                                                                                                                // 638\n                                                                                                                       // 639\n    handle = self.subscribe.apply(self, [name].concat(args));                                                          // 640\n    f.wait();                                                                                                          // 641\n    return handle;                                                                                                     // 642\n  },                                                                                                                   // 643\n                                                                                                                       // 644\n  methods: function (methods) {                                                                                        // 645\n    var self = this;                                                                                                   // 646\n    _.each(methods, function (func, name) {                                                                            // 647\n      if (self._methodHandlers[name])                                                                                  // 648\n        throw new Error(\"A method named '\" + name + \"' is already defined\");                                           // 649\n      self._methodHandlers[name] = func;                                                                               // 650\n    });                                                                                                                // 651\n  },                                                                                                                   // 652\n                                                                                                                       // 653\n  /**                                                                                                                  // 654\n   * @memberOf Meteor                                                                                                  // 655\n   * @summary Invokes a method passing any number of arguments.                                                        // 656\n   * @locus Anywhere                                                                                                   // 657\n   * @param {String} name Name of method to invoke                                                                     // 658\n   * @param {EJSONable} [arg1,arg2...] Optional method arguments                                                       // 659\n   * @param {Function} [asyncCallback] Optional callback, which is called asynchronously with the error or result after the method is complete. If not provided, the method runs synchronously if possible (see below).\n   */                                                                                                                  // 661\n  call: function (name /* .. [arguments] .. callback */) {                                                             // 662\n    // if it's a function, the last argument is the result callback,                                                   // 663\n    // not a parameter to the remote method.                                                                           // 664\n    var args = Array.prototype.slice.call(arguments, 1);                                                               // 665\n    if (args.length && typeof args[args.length - 1] === \"function\")                                                    // 666\n      var callback = args.pop();                                                                                       // 667\n    return this.apply(name, args, callback);                                                                           // 668\n  },                                                                                                                   // 669\n                                                                                                                       // 670\n  // @param options {Optional Object}                                                                                  // 671\n  //   wait: Boolean - Should we wait to call this until all current methods                                           // 672\n  //                   are fully finished, and block subsequent method calls                                           // 673\n  //                   until this method is fully finished?                                                            // 674\n  //                   (does not affect methods called from within this method)                                        // 675\n  //   onResultReceived: Function - a callback to call as soon as the method                                           // 676\n  //                                result is received. the data written by                                            // 677\n  //                                the method may not yet be in the cache!                                            // 678\n  //   returnStubValue: Boolean - If true then in cases where we would have                                            // 679\n  //                              otherwise discarded the stub's return value                                          // 680\n  //                              and returned undefined, instead we go ahead                                          // 681\n  //                              and return it.  Specifically, this is any                                            // 682\n  //                              time other than when (a) we are already                                              // 683\n  //                              inside a stub or (b) we are in Node and no                                           // 684\n  //                              callback was provided.  Currently we require                                         // 685\n  //                              this flag to be explicitly passed to reduce                                          // 686\n  //                              the likelihood that stub return values will                                          // 687\n  //                              be confused with server return values; we                                            // 688\n  //                              may improve this in future.                                                          // 689\n  // @param callback {Optional Function}                                                                               // 690\n                                                                                                                       // 691\n  /**                                                                                                                  // 692\n   * @memberOf Meteor                                                                                                  // 693\n   * @summary Invoke a method passing an array of arguments.                                                           // 694\n   * @locus Anywhere                                                                                                   // 695\n   * @param {String} name Name of method to invoke                                                                     // 696\n   * @param {EJSONable[]} args Method arguments                                                                        // 697\n   * @param {Object} [options]                                                                                         // 698\n   * @param {Boolean} options.wait (Client only) If true, don't send this method until all previous method calls have completed, and don't send any subsequent method calls until this one is completed.\n   * @param {Function} options.onResultReceived (Client only) This callback is invoked with the error or result of the method (just like `asyncCallback`) as soon as the error or result is available. The local cache may not yet reflect the writes performed by the method.\n   * @param {Function} [asyncCallback] Optional callback; same semantics as in [`Meteor.call`](#meteor_call).          // 701\n   */                                                                                                                  // 702\n  apply: function (name, args, options, callback) {                                                                    // 703\n    var self = this;                                                                                                   // 704\n                                                                                                                       // 705\n    // We were passed 3 arguments. They may be either (name, args, options)                                            // 706\n    // or (name, args, callback)                                                                                       // 707\n    if (!callback && typeof options === 'function') {                                                                  // 708\n      callback = options;                                                                                              // 709\n      options = {};                                                                                                    // 710\n    }                                                                                                                  // 711\n    options = options || {};                                                                                           // 712\n                                                                                                                       // 713\n    if (callback) {                                                                                                    // 714\n      // XXX would it be better form to do the binding in stream.on,                                                   // 715\n      // or caller, instead of here?                                                                                   // 716\n      // XXX improve error message (and how we report it)                                                              // 717\n      callback = Meteor.bindEnvironment(                                                                               // 718\n        callback,                                                                                                      // 719\n        \"delivering result of invoking '\" + name + \"'\"                                                                 // 720\n      );                                                                                                               // 721\n    }                                                                                                                  // 722\n                                                                                                                       // 723\n    // Keep our args safe from mutation (eg if we don't send the message for a                                         // 724\n    // while because of a wait method).                                                                                // 725\n    args = EJSON.clone(args);                                                                                          // 726\n                                                                                                                       // 727\n    // Lazily allocate method ID once we know that it'll be needed.                                                    // 728\n    var methodId = (function () {                                                                                      // 729\n      var id;                                                                                                          // 730\n      return function () {                                                                                             // 731\n        if (id === undefined)                                                                                          // 732\n          id = '' + (self._nextMethodId++);                                                                            // 733\n        return id;                                                                                                     // 734\n      };                                                                                                               // 735\n    })();                                                                                                              // 736\n                                                                                                                       // 737\n    var enclosing = DDP._CurrentInvocation.get();                                                                      // 738\n    var alreadyInSimulation = enclosing && enclosing.isSimulation;                                                     // 739\n                                                                                                                       // 740\n    // Lazily generate a randomSeed, only if it is requested by the stub.                                              // 741\n    // The random streams only have utility if they're used on both the client                                         // 742\n    // and the server; if the client doesn't generate any 'random' values                                              // 743\n    // then we don't expect the server to generate any either.                                                         // 744\n    // Less commonly, the server may perform different actions from the client,                                        // 745\n    // and may in fact generate values where the client did not, but we don't                                          // 746\n    // have any client-side values to match, so even here we may as well just                                          // 747\n    // use a random seed on the server.  In that case, we don't pass the                                               // 748\n    // randomSeed to save bandwidth, and we don't even generate it to save a                                           // 749\n    // bit of CPU and to avoid consuming entropy.                                                                      // 750\n    var randomSeed = null;                                                                                             // 751\n    var randomSeedGenerator = function () {                                                                            // 752\n      if (randomSeed === null) {                                                                                       // 753\n        randomSeed = makeRpcSeed(enclosing, name);                                                                     // 754\n      }                                                                                                                // 755\n      return randomSeed;                                                                                               // 756\n    };                                                                                                                 // 757\n                                                                                                                       // 758\n    // Run the stub, if we have one. The stub is supposed to make some                                                 // 759\n    // temporary writes to the database to give the user a smooth experience                                           // 760\n    // until the actual result of executing the method comes back from the                                             // 761\n    // server (whereupon the temporary writes to the database will be reversed                                         // 762\n    // during the beginUpdate/endUpdate process.)                                                                      // 763\n    //                                                                                                                 // 764\n    // Normally, we ignore the return value of the stub (even if it is an                                              // 765\n    // exception), in favor of the real return value from the server. The                                              // 766\n    // exception is if the *caller* is a stub. In that case, we're not going                                           // 767\n    // to do a RPC, so we use the return value of the stub as our return                                               // 768\n    // value.                                                                                                          // 769\n                                                                                                                       // 770\n    var stub = self._methodHandlers[name];                                                                             // 771\n    if (stub) {                                                                                                        // 772\n      var setUserId = function(userId) {                                                                               // 773\n        self.setUserId(userId);                                                                                        // 774\n      };                                                                                                               // 775\n                                                                                                                       // 776\n      var invocation = new MethodInvocation({                                                                          // 777\n        isSimulation: true,                                                                                            // 778\n        userId: self.userId(),                                                                                         // 779\n        setUserId: setUserId,                                                                                          // 780\n        randomSeed: function () { return randomSeedGenerator(); }                                                      // 781\n      });                                                                                                              // 782\n                                                                                                                       // 783\n      if (!alreadyInSimulation)                                                                                        // 784\n        self._saveOriginals();                                                                                         // 785\n                                                                                                                       // 786\n      try {                                                                                                            // 787\n        // Note that unlike in the corresponding server code, we never audit                                           // 788\n        // that stubs check() their arguments.                                                                         // 789\n        var stubReturnValue = DDP._CurrentInvocation.withValue(invocation, function () {                               // 790\n          if (Meteor.isServer) {                                                                                       // 791\n            // Because saveOriginals and retrieveOriginals aren't reentrant,                                           // 792\n            // don't allow stubs to yield.                                                                             // 793\n            return Meteor._noYieldsAllowed(function () {                                                               // 794\n              // re-clone, so that the stub can't affect our caller's values                                           // 795\n              return stub.apply(invocation, EJSON.clone(args));                                                        // 796\n            });                                                                                                        // 797\n          } else {                                                                                                     // 798\n            return stub.apply(invocation, EJSON.clone(args));                                                          // 799\n          }                                                                                                            // 800\n        });                                                                                                            // 801\n      }                                                                                                                // 802\n      catch (e) {                                                                                                      // 803\n        var exception = e;                                                                                             // 804\n      }                                                                                                                // 805\n                                                                                                                       // 806\n      if (!alreadyInSimulation)                                                                                        // 807\n        self._retrieveAndStoreOriginals(methodId());                                                                   // 808\n    }                                                                                                                  // 809\n                                                                                                                       // 810\n    // If we're in a simulation, stop and return the result we have,                                                   // 811\n    // rather than going on to do an RPC. If there was no stub,                                                        // 812\n    // we'll end up returning undefined.                                                                               // 813\n    if (alreadyInSimulation) {                                                                                         // 814\n      if (callback) {                                                                                                  // 815\n        callback(exception, stubReturnValue);                                                                          // 816\n        return undefined;                                                                                              // 817\n      }                                                                                                                // 818\n      if (exception)                                                                                                   // 819\n        throw exception;                                                                                               // 820\n      return stubReturnValue;                                                                                          // 821\n    }                                                                                                                  // 822\n                                                                                                                       // 823\n    // If an exception occurred in a stub, and we're ignoring it                                                       // 824\n    // because we're doing an RPC and want to use what the server                                                      // 825\n    // returns instead, log it so the developer knows.                                                                 // 826\n    //                                                                                                                 // 827\n    // Tests can set the 'expected' flag on an exception so it won't                                                   // 828\n    // go to log.                                                                                                      // 829\n    if (exception && !exception.expected) {                                                                            // 830\n      Meteor._debug(\"Exception while simulating the effect of invoking '\" +                                            // 831\n                    name + \"'\", exception, exception.stack);                                                           // 832\n    }                                                                                                                  // 833\n                                                                                                                       // 834\n                                                                                                                       // 835\n    // At this point we're definitely doing an RPC, and we're going to                                                 // 836\n    // return the value of the RPC to the caller.                                                                      // 837\n                                                                                                                       // 838\n    // If the caller didn't give a callback, decide what to do.                                                        // 839\n    if (!callback) {                                                                                                   // 840\n      if (Meteor.isClient) {                                                                                           // 841\n        // On the client, we don't have fibers, so we can't block. The                                                 // 842\n        // only thing we can do is to return undefined and discard the                                                 // 843\n        // result of the RPC. If an error occurred then print the error                                                // 844\n        // to the console.                                                                                             // 845\n        callback = function (err) {                                                                                    // 846\n          err && Meteor._debug(\"Error invoking Method '\" + name + \"':\",                                                // 847\n                               err.message);                                                                           // 848\n        };                                                                                                             // 849\n      } else {                                                                                                         // 850\n        // On the server, make the function synchronous. Throw on                                                      // 851\n        // errors, return on success.                                                                                  // 852\n        var future = new Future;                                                                                       // 853\n        callback = future.resolver();                                                                                  // 854\n      }                                                                                                                // 855\n    }                                                                                                                  // 856\n    // Send the RPC. Note that on the client, it is important that the                                                 // 857\n    // stub have finished before we send the RPC, so that we know we have                                              // 858\n    // a complete list of which local documents the stub wrote.                                                        // 859\n    var message = {                                                                                                    // 860\n      msg: 'method',                                                                                                   // 861\n      method: name,                                                                                                    // 862\n      params: args,                                                                                                    // 863\n      id: methodId()                                                                                                   // 864\n    };                                                                                                                 // 865\n                                                                                                                       // 866\n    // Send the randomSeed only if we used it                                                                          // 867\n    if (randomSeed !== null) {                                                                                         // 868\n      message.randomSeed = randomSeed;                                                                                 // 869\n    }                                                                                                                  // 870\n                                                                                                                       // 871\n    var methodInvoker = new MethodInvoker({                                                                            // 872\n      methodId: methodId(),                                                                                            // 873\n      callback: callback,                                                                                              // 874\n      connection: self,                                                                                                // 875\n      onResultReceived: options.onResultReceived,                                                                      // 876\n      wait: !!options.wait,                                                                                            // 877\n      message: message                                                                                                 // 878\n    });                                                                                                                // 879\n                                                                                                                       // 880\n    if (options.wait) {                                                                                                // 881\n      // It's a wait method! Wait methods go in their own block.                                                       // 882\n      self._outstandingMethodBlocks.push(                                                                              // 883\n        {wait: true, methods: [methodInvoker]});                                                                       // 884\n    } else {                                                                                                           // 885\n      // Not a wait method. Start a new block if the previous block was a wait                                         // 886\n      // block, and add it to the last block of methods.                                                               // 887\n      if (_.isEmpty(self._outstandingMethodBlocks) ||                                                                  // 888\n          _.last(self._outstandingMethodBlocks).wait)                                                                  // 889\n        self._outstandingMethodBlocks.push({wait: false, methods: []});                                                // 890\n      _.last(self._outstandingMethodBlocks).methods.push(methodInvoker);                                               // 891\n    }                                                                                                                  // 892\n                                                                                                                       // 893\n    // If we added it to the first block, send it out now.                                                             // 894\n    if (self._outstandingMethodBlocks.length === 1)                                                                    // 895\n      methodInvoker.sendMessage();                                                                                     // 896\n                                                                                                                       // 897\n    // If we're using the default callback on the server,                                                              // 898\n    // block waiting for the result.                                                                                   // 899\n    if (future) {                                                                                                      // 900\n      return future.wait();                                                                                            // 901\n    }                                                                                                                  // 902\n    return options.returnStubValue ? stubReturnValue : undefined;                                                      // 903\n  },                                                                                                                   // 904\n                                                                                                                       // 905\n  // Before calling a method stub, prepare all stores to track changes and allow                                       // 906\n  // _retrieveAndStoreOriginals to get the original versions of changed                                                // 907\n  // documents.                                                                                                        // 908\n  _saveOriginals: function () {                                                                                        // 909\n    var self = this;                                                                                                   // 910\n    _.each(self._stores, function (s) {                                                                                // 911\n      s.saveOriginals();                                                                                               // 912\n    });                                                                                                                // 913\n  },                                                                                                                   // 914\n  // Retrieves the original versions of all documents modified by the stub for                                         // 915\n  // method 'methodId' from all stores and saves them to _serverDocuments (keyed                                       // 916\n  // by document) and _documentsWrittenByStub (keyed by method ID).                                                    // 917\n  _retrieveAndStoreOriginals: function (methodId) {                                                                    // 918\n    var self = this;                                                                                                   // 919\n    if (self._documentsWrittenByStub[methodId])                                                                        // 920\n      throw new Error(\"Duplicate methodId in _retrieveAndStoreOriginals\");                                             // 921\n                                                                                                                       // 922\n    var docsWritten = [];                                                                                              // 923\n    _.each(self._stores, function (s, collection) {                                                                    // 924\n      var originals = s.retrieveOriginals();                                                                           // 925\n      // not all stores define retrieveOriginals                                                                       // 926\n      if (!originals)                                                                                                  // 927\n        return;                                                                                                        // 928\n      originals.forEach(function (doc, id) {                                                                           // 929\n        docsWritten.push({collection: collection, id: id});                                                            // 930\n        if (!_.has(self._serverDocuments, collection))                                                                 // 931\n          self._serverDocuments[collection] = new LocalCollection._IdMap;                                              // 932\n        var serverDoc = self._serverDocuments[collection].setDefault(id, {});                                          // 933\n        if (serverDoc.writtenByStubs) {                                                                                // 934\n          // We're not the first stub to write this doc. Just add our method ID                                        // 935\n          // to the record.                                                                                            // 936\n          serverDoc.writtenByStubs[methodId] = true;                                                                   // 937\n        } else {                                                                                                       // 938\n          // First stub! Save the original value and our method ID.                                                    // 939\n          serverDoc.document = doc;                                                                                    // 940\n          serverDoc.flushCallbacks = [];                                                                               // 941\n          serverDoc.writtenByStubs = {};                                                                               // 942\n          serverDoc.writtenByStubs[methodId] = true;                                                                   // 943\n        }                                                                                                              // 944\n      });                                                                                                              // 945\n    });                                                                                                                // 946\n    if (!_.isEmpty(docsWritten)) {                                                                                     // 947\n      self._documentsWrittenByStub[methodId] = docsWritten;                                                            // 948\n    }                                                                                                                  // 949\n  },                                                                                                                   // 950\n                                                                                                                       // 951\n  // This is very much a private function we use to make the tests                                                     // 952\n  // take up fewer server resources after they complete.                                                               // 953\n  _unsubscribeAll: function () {                                                                                       // 954\n    var self = this;                                                                                                   // 955\n    _.each(_.clone(self._subscriptions), function (sub, id) {                                                          // 956\n      // Avoid killing the autoupdate subscription so that developers                                                  // 957\n      // still get hot code pushes when writing tests.                                                                 // 958\n      //                                                                                                               // 959\n      // XXX it's a hack to encode knowledge about autoupdate here,                                                    // 960\n      // but it doesn't seem worth it yet to have a special API for                                                    // 961\n      // subscriptions to preserve after unit tests.                                                                   // 962\n      if (sub.name !== 'meteor_autoupdate_clientVersions') {                                                           // 963\n        self._subscriptions[id].stop();                                                                                // 964\n      }                                                                                                                // 965\n    });                                                                                                                // 966\n  },                                                                                                                   // 967\n                                                                                                                       // 968\n  // Sends the DDP stringification of the given message object                                                         // 969\n  _send: function (obj) {                                                                                              // 970\n    var self = this;                                                                                                   // 971\n    self._stream.send(stringifyDDP(obj));                                                                              // 972\n  },                                                                                                                   // 973\n                                                                                                                       // 974\n  // We detected via DDP-level heartbeats that we've lost the                                                          // 975\n  // connection.  Unlike `disconnect` or `close`, a lost connection                                                    // 976\n  // will be automatically retried.                                                                                    // 977\n  _lostConnection: function (error) {                                                                                  // 978\n    var self = this;                                                                                                   // 979\n    self._stream._lostConnection(error);                                                                               // 980\n  },                                                                                                                   // 981\n                                                                                                                       // 982\n  /**                                                                                                                  // 983\n   * @summary Get the current connection status. A reactive data source.                                               // 984\n   * @locus Client                                                                                                     // 985\n   * @memberOf Meteor                                                                                                  // 986\n   */                                                                                                                  // 987\n  status: function (/*passthrough args*/) {                                                                            // 988\n    var self = this;                                                                                                   // 989\n    return self._stream.status.apply(self._stream, arguments);                                                         // 990\n  },                                                                                                                   // 991\n                                                                                                                       // 992\n  /**                                                                                                                  // 993\n   * @summary Force an immediate reconnection attempt if the client is not connected to the server.                    // 994\n                                                                                                                       // 995\n  This method does nothing if the client is already connected.                                                         // 996\n   * @locus Client                                                                                                     // 997\n   * @memberOf Meteor                                                                                                  // 998\n   */                                                                                                                  // 999\n  reconnect: function (/*passthrough args*/) {                                                                         // 1000\n    var self = this;                                                                                                   // 1001\n    return self._stream.reconnect.apply(self._stream, arguments);                                                      // 1002\n  },                                                                                                                   // 1003\n                                                                                                                       // 1004\n  /**                                                                                                                  // 1005\n   * @summary Disconnect the client from the server.                                                                   // 1006\n   * @locus Client                                                                                                     // 1007\n   * @memberOf Meteor                                                                                                  // 1008\n   */                                                                                                                  // 1009\n  disconnect: function (/*passthrough args*/) {                                                                        // 1010\n    var self = this;                                                                                                   // 1011\n    return self._stream.disconnect.apply(self._stream, arguments);                                                     // 1012\n  },                                                                                                                   // 1013\n                                                                                                                       // 1014\n  close: function () {                                                                                                 // 1015\n    var self = this;                                                                                                   // 1016\n    return self._stream.disconnect({_permanent: true});                                                                // 1017\n  },                                                                                                                   // 1018\n                                                                                                                       // 1019\n  ///                                                                                                                  // 1020\n  /// Reactive user system                                                                                             // 1021\n  ///                                                                                                                  // 1022\n  userId: function () {                                                                                                // 1023\n    var self = this;                                                                                                   // 1024\n    if (self._userIdDeps)                                                                                              // 1025\n      self._userIdDeps.depend();                                                                                       // 1026\n    return self._userId;                                                                                               // 1027\n  },                                                                                                                   // 1028\n                                                                                                                       // 1029\n  setUserId: function (userId) {                                                                                       // 1030\n    var self = this;                                                                                                   // 1031\n    // Avoid invalidating dependents if setUserId is called with current value.                                        // 1032\n    if (self._userId === userId)                                                                                       // 1033\n      return;                                                                                                          // 1034\n    self._userId = userId;                                                                                             // 1035\n    if (self._userIdDeps)                                                                                              // 1036\n      self._userIdDeps.changed();                                                                                      // 1037\n  },                                                                                                                   // 1038\n                                                                                                                       // 1039\n  // Returns true if we are in a state after reconnect of waiting for subs to be                                       // 1040\n  // revived or early methods to finish their data, or we are waiting for a                                            // 1041\n  // \"wait\" method to finish.                                                                                          // 1042\n  _waitingForQuiescence: function () {                                                                                 // 1043\n    var self = this;                                                                                                   // 1044\n    return (! _.isEmpty(self._subsBeingRevived) ||                                                                     // 1045\n            ! _.isEmpty(self._methodsBlockingQuiescence));                                                             // 1046\n  },                                                                                                                   // 1047\n                                                                                                                       // 1048\n  // Returns true if any method whose message has been sent to the server has                                          // 1049\n  // not yet invoked its user callback.                                                                                // 1050\n  _anyMethodsAreOutstanding: function () {                                                                             // 1051\n    var self = this;                                                                                                   // 1052\n    return _.any(_.pluck(self._methodInvokers, 'sentMessage'));                                                        // 1053\n  },                                                                                                                   // 1054\n                                                                                                                       // 1055\n  _livedata_connected: function (msg) {                                                                                // 1056\n    var self = this;                                                                                                   // 1057\n                                                                                                                       // 1058\n    if (self._version !== 'pre1' && self._heartbeatInterval !== 0) {                                                   // 1059\n      self._heartbeat = new Heartbeat({                                                                                // 1060\n        heartbeatInterval: self._heartbeatInterval,                                                                    // 1061\n        heartbeatTimeout: self._heartbeatTimeout,                                                                      // 1062\n        onTimeout: function () {                                                                                       // 1063\n          self._lostConnection(                                                                                        // 1064\n            new DDP.ConnectionError(\"DDP heartbeat timed out\"));                                                       // 1065\n        },                                                                                                             // 1066\n        sendPing: function () {                                                                                        // 1067\n          self._send({msg: 'ping'});                                                                                   // 1068\n        }                                                                                                              // 1069\n      });                                                                                                              // 1070\n      self._heartbeat.start();                                                                                         // 1071\n    }                                                                                                                  // 1072\n                                                                                                                       // 1073\n    // If this is a reconnect, we'll have to reset all stores.                                                         // 1074\n    if (self._lastSessionId)                                                                                           // 1075\n      self._resetStores = true;                                                                                        // 1076\n                                                                                                                       // 1077\n    if (typeof (msg.session) === \"string\") {                                                                           // 1078\n      var reconnectedToPreviousSession = (self._lastSessionId === msg.session);                                        // 1079\n      self._lastSessionId = msg.session;                                                                               // 1080\n    }                                                                                                                  // 1081\n                                                                                                                       // 1082\n    if (reconnectedToPreviousSession) {                                                                                // 1083\n      // Successful reconnection -- pick up where we left off.  Note that right                                        // 1084\n      // now, this never happens: the server never connects us to a previous                                           // 1085\n      // session, because DDP doesn't provide enough data for the server to know                                       // 1086\n      // what messages the client has processed. We need to improve DDP to make                                        // 1087\n      // this possible, at which point we'll probably need more code here.                                             // 1088\n      return;                                                                                                          // 1089\n    }                                                                                                                  // 1090\n                                                                                                                       // 1091\n    // Server doesn't have our data any more. Re-sync a new session.                                                   // 1092\n                                                                                                                       // 1093\n    // Forget about messages we were buffering for unknown collections. They'll                                        // 1094\n    // be resent if still relevant.                                                                                    // 1095\n    self._updatesForUnknownStores = {};                                                                                // 1096\n                                                                                                                       // 1097\n    if (self._resetStores) {                                                                                           // 1098\n      // Forget about the effects of stubs. We'll be resetting all collections                                         // 1099\n      // anyway.                                                                                                       // 1100\n      self._documentsWrittenByStub = {};                                                                               // 1101\n      self._serverDocuments = {};                                                                                      // 1102\n    }                                                                                                                  // 1103\n                                                                                                                       // 1104\n    // Clear _afterUpdateCallbacks.                                                                                    // 1105\n    self._afterUpdateCallbacks = [];                                                                                   // 1106\n                                                                                                                       // 1107\n    // Mark all named subscriptions which are ready (ie, we already called the                                         // 1108\n    // ready callback) as needing to be revived.                                                                       // 1109\n    // XXX We should also block reconnect quiescence until unnamed subscriptions                                       // 1110\n    //     (eg, autopublish) are done re-publishing to avoid flicker!                                                  // 1111\n    self._subsBeingRevived = {};                                                                                       // 1112\n    _.each(self._subscriptions, function (sub, id) {                                                                   // 1113\n      if (sub.ready)                                                                                                   // 1114\n        self._subsBeingRevived[id] = true;                                                                             // 1115\n    });                                                                                                                // 1116\n                                                                                                                       // 1117\n    // Arrange for \"half-finished\" methods to have their callbacks run, and                                            // 1118\n    // track methods that were sent on this connection so that we don't                                                // 1119\n    // quiesce until they are all done.                                                                                // 1120\n    //                                                                                                                 // 1121\n    // Start by clearing _methodsBlockingQuiescence: methods sent before                                               // 1122\n    // reconnect don't matter, and any \"wait\" methods sent on the new connection                                       // 1123\n    // that we drop here will be restored by the loop below.                                                           // 1124\n    self._methodsBlockingQuiescence = {};                                                                              // 1125\n    if (self._resetStores) {                                                                                           // 1126\n      _.each(self._methodInvokers, function (invoker) {                                                                // 1127\n        if (invoker.gotResult()) {                                                                                     // 1128\n          // This method already got its result, but it didn't call its callback                                       // 1129\n          // because its data didn't become visible. We did not resend the                                             // 1130\n          // method RPC. We'll call its callback when we get a full quiesce,                                           // 1131\n          // since that's as close as we'll get to \"data must be visible\".                                             // 1132\n          self._afterUpdateCallbacks.push(_.bind(invoker.dataVisible, invoker));                                       // 1133\n        } else if (invoker.sentMessage) {                                                                              // 1134\n          // This method has been sent on this connection (maybe as a resend                                           // 1135\n          // from the last connection, maybe from onReconnect, maybe just very                                         // 1136\n          // quickly before processing the connected message).                                                         // 1137\n          //                                                                                                           // 1138\n          // We don't need to do anything special to ensure its callbacks get                                          // 1139\n          // called, but we'll count it as a method which is preventing                                                // 1140\n          // reconnect quiescence. (eg, it might be a login method that was run                                        // 1141\n          // from onReconnect, and we don't want to see flicker by seeing a                                            // 1142\n          // logged-out state.)                                                                                        // 1143\n          self._methodsBlockingQuiescence[invoker.methodId] = true;                                                    // 1144\n        }                                                                                                              // 1145\n      });                                                                                                              // 1146\n    }                                                                                                                  // 1147\n                                                                                                                       // 1148\n    self._messagesBufferedUntilQuiescence = [];                                                                        // 1149\n                                                                                                                       // 1150\n    // If we're not waiting on any methods or subs, we can reset the stores and                                        // 1151\n    // call the callbacks immediately.                                                                                 // 1152\n    if (!self._waitingForQuiescence()) {                                                                               // 1153\n      if (self._resetStores) {                                                                                         // 1154\n        _.each(self._stores, function (s) {                                                                            // 1155\n          s.beginUpdate(0, true);                                                                                      // 1156\n          s.endUpdate();                                                                                               // 1157\n        });                                                                                                            // 1158\n        self._resetStores = false;                                                                                     // 1159\n      }                                                                                                                // 1160\n      self._runAfterUpdateCallbacks();                                                                                 // 1161\n    }                                                                                                                  // 1162\n  },                                                                                                                   // 1163\n                                                                                                                       // 1164\n                                                                                                                       // 1165\n  _processOneDataMessage: function (msg, updates) {                                                                    // 1166\n    var self = this;                                                                                                   // 1167\n    // Using underscore here so as not to need to capitalize.                                                          // 1168\n    self['_process_' + msg.msg](msg, updates);                                                                         // 1169\n  },                                                                                                                   // 1170\n                                                                                                                       // 1171\n                                                                                                                       // 1172\n  _livedata_data: function (msg) {                                                                                     // 1173\n    var self = this;                                                                                                   // 1174\n                                                                                                                       // 1175\n    // collection name -> array of messages                                                                            // 1176\n    var updates = {};                                                                                                  // 1177\n                                                                                                                       // 1178\n    if (self._waitingForQuiescence()) {                                                                                // 1179\n      self._messagesBufferedUntilQuiescence.push(msg);                                                                 // 1180\n                                                                                                                       // 1181\n      if (msg.msg === \"nosub\")                                                                                         // 1182\n        delete self._subsBeingRevived[msg.id];                                                                         // 1183\n                                                                                                                       // 1184\n      _.each(msg.subs || [], function (subId) {                                                                        // 1185\n        delete self._subsBeingRevived[subId];                                                                          // 1186\n      });                                                                                                              // 1187\n      _.each(msg.methods || [], function (methodId) {                                                                  // 1188\n        delete self._methodsBlockingQuiescence[methodId];                                                              // 1189\n      });                                                                                                              // 1190\n                                                                                                                       // 1191\n      if (self._waitingForQuiescence())                                                                                // 1192\n        return;                                                                                                        // 1193\n                                                                                                                       // 1194\n      // No methods or subs are blocking quiescence!                                                                   // 1195\n      // We'll now process and all of our buffered messages, reset all stores,                                         // 1196\n      // and apply them all at once.                                                                                   // 1197\n      _.each(self._messagesBufferedUntilQuiescence, function (bufferedMsg) {                                           // 1198\n        self._processOneDataMessage(bufferedMsg, updates);                                                             // 1199\n      });                                                                                                              // 1200\n      self._messagesBufferedUntilQuiescence = [];                                                                      // 1201\n    } else {                                                                                                           // 1202\n      self._processOneDataMessage(msg, updates);                                                                       // 1203\n    }                                                                                                                  // 1204\n                                                                                                                       // 1205\n    if (self._resetStores || !_.isEmpty(updates)) {                                                                    // 1206\n      // Begin a transactional update of each store.                                                                   // 1207\n      _.each(self._stores, function (s, storeName) {                                                                   // 1208\n        s.beginUpdate(_.has(updates, storeName) ? updates[storeName].length : 0,                                       // 1209\n                      self._resetStores);                                                                              // 1210\n      });                                                                                                              // 1211\n      self._resetStores = false;                                                                                       // 1212\n                                                                                                                       // 1213\n      _.each(updates, function (updateMessages, storeName) {                                                           // 1214\n        var store = self._stores[storeName];                                                                           // 1215\n        if (store) {                                                                                                   // 1216\n          _.each(updateMessages, function (updateMessage) {                                                            // 1217\n            store.update(updateMessage);                                                                               // 1218\n          });                                                                                                          // 1219\n        } else {                                                                                                       // 1220\n          // Nobody's listening for this data. Queue it up until                                                       // 1221\n          // someone wants it.                                                                                         // 1222\n          // XXX memory use will grow without bound if you forget to                                                   // 1223\n          // create a collection or just don't care about it... going                                                  // 1224\n          // to have to do something about that.                                                                       // 1225\n          if (!_.has(self._updatesForUnknownStores, storeName))                                                        // 1226\n            self._updatesForUnknownStores[storeName] = [];                                                             // 1227\n          Array.prototype.push.apply(self._updatesForUnknownStores[storeName],                                         // 1228\n                                     updateMessages);                                                                  // 1229\n        }                                                                                                              // 1230\n      });                                                                                                              // 1231\n                                                                                                                       // 1232\n      // End update transaction.                                                                                       // 1233\n      _.each(self._stores, function (s) { s.endUpdate(); });                                                           // 1234\n    }                                                                                                                  // 1235\n                                                                                                                       // 1236\n    self._runAfterUpdateCallbacks();                                                                                   // 1237\n  },                                                                                                                   // 1238\n                                                                                                                       // 1239\n  // Call any callbacks deferred with _runWhenAllServerDocsAreFlushed whose                                            // 1240\n  // relevant docs have been flushed, as well as dataVisible callbacks at                                              // 1241\n  // reconnect-quiescence time.                                                                                        // 1242\n  _runAfterUpdateCallbacks: function () {                                                                              // 1243\n    var self = this;                                                                                                   // 1244\n    var callbacks = self._afterUpdateCallbacks;                                                                        // 1245\n    self._afterUpdateCallbacks = [];                                                                                   // 1246\n    _.each(callbacks, function (c) {                                                                                   // 1247\n      c();                                                                                                             // 1248\n    });                                                                                                                // 1249\n  },                                                                                                                   // 1250\n                                                                                                                       // 1251\n  _pushUpdate: function (updates, collection, msg) {                                                                   // 1252\n    var self = this;                                                                                                   // 1253\n    if (!_.has(updates, collection)) {                                                                                 // 1254\n      updates[collection] = [];                                                                                        // 1255\n    }                                                                                                                  // 1256\n    updates[collection].push(msg);                                                                                     // 1257\n  },                                                                                                                   // 1258\n                                                                                                                       // 1259\n  _getServerDoc: function (collection, id) {                                                                           // 1260\n    var self = this;                                                                                                   // 1261\n    if (!_.has(self._serverDocuments, collection))                                                                     // 1262\n      return null;                                                                                                     // 1263\n    var serverDocsForCollection = self._serverDocuments[collection];                                                   // 1264\n    return serverDocsForCollection.get(id) || null;                                                                    // 1265\n  },                                                                                                                   // 1266\n                                                                                                                       // 1267\n  _process_added: function (msg, updates) {                                                                            // 1268\n    var self = this;                                                                                                   // 1269\n    var id = LocalCollection._idParse(msg.id);                                                                         // 1270\n    var serverDoc = self._getServerDoc(msg.collection, id);                                                            // 1271\n    if (serverDoc) {                                                                                                   // 1272\n      // Some outstanding stub wrote here.                                                                             // 1273\n      if (serverDoc.document !== undefined)                                                                            // 1274\n        throw new Error(\"Server sent add for existing id: \" + msg.id);                                                 // 1275\n      serverDoc.document = msg.fields || {};                                                                           // 1276\n      serverDoc.document._id = id;                                                                                     // 1277\n    } else {                                                                                                           // 1278\n      self._pushUpdate(updates, msg.collection, msg);                                                                  // 1279\n    }                                                                                                                  // 1280\n  },                                                                                                                   // 1281\n                                                                                                                       // 1282\n  _process_changed: function (msg, updates) {                                                                          // 1283\n    var self = this;                                                                                                   // 1284\n    var serverDoc = self._getServerDoc(                                                                                // 1285\n      msg.collection, LocalCollection._idParse(msg.id));                                                               // 1286\n    if (serverDoc) {                                                                                                   // 1287\n      if (serverDoc.document === undefined)                                                                            // 1288\n        throw new Error(\"Server sent changed for nonexisting id: \" + msg.id);                                          // 1289\n      LocalCollection._applyChanges(serverDoc.document, msg.fields);                                                   // 1290\n    } else {                                                                                                           // 1291\n      self._pushUpdate(updates, msg.collection, msg);                                                                  // 1292\n    }                                                                                                                  // 1293\n  },                                                                                                                   // 1294\n                                                                                                                       // 1295\n  _process_removed: function (msg, updates) {                                                                          // 1296\n    var self = this;                                                                                                   // 1297\n    var serverDoc = self._getServerDoc(                                                                                // 1298\n      msg.collection, LocalCollection._idParse(msg.id));                                                               // 1299\n    if (serverDoc) {                                                                                                   // 1300\n      // Some outstanding stub wrote here.                                                                             // 1301\n      if (serverDoc.document === undefined)                                                                            // 1302\n        throw new Error(\"Server sent removed for nonexisting id:\" + msg.id);                                           // 1303\n      serverDoc.document = undefined;                                                                                  // 1304\n    } else {                                                                                                           // 1305\n      self._pushUpdate(updates, msg.collection, {                                                                      // 1306\n        msg: 'removed',                                                                                                // 1307\n        collection: msg.collection,                                                                                    // 1308\n        id: msg.id                                                                                                     // 1309\n      });                                                                                                              // 1310\n    }                                                                                                                  // 1311\n  },                                                                                                                   // 1312\n                                                                                                                       // 1313\n  _process_updated: function (msg, updates) {                                                                          // 1314\n    var self = this;                                                                                                   // 1315\n    // Process \"method done\" messages.                                                                                 // 1316\n    _.each(msg.methods, function (methodId) {                                                                          // 1317\n      _.each(self._documentsWrittenByStub[methodId], function (written) {                                              // 1318\n        var serverDoc = self._getServerDoc(written.collection, written.id);                                            // 1319\n        if (!serverDoc)                                                                                                // 1320\n          throw new Error(\"Lost serverDoc for \" + JSON.stringify(written));                                            // 1321\n        if (!serverDoc.writtenByStubs[methodId])                                                                       // 1322\n          throw new Error(\"Doc \" + JSON.stringify(written) +                                                           // 1323\n                          \" not written by  method \" + methodId);                                                      // 1324\n        delete serverDoc.writtenByStubs[methodId];                                                                     // 1325\n        if (_.isEmpty(serverDoc.writtenByStubs)) {                                                                     // 1326\n          // All methods whose stubs wrote this method have completed! We can                                          // 1327\n          // now copy the saved document to the database (reverting the stub's                                         // 1328\n          // change if the server did not write to this object, or applying the                                        // 1329\n          // server's writes if it did).                                                                               // 1330\n                                                                                                                       // 1331\n          // This is a fake ddp 'replace' message.  It's just for talking                                              // 1332\n          // between livedata connections and minimongo.  (We have to stringify                                        // 1333\n          // the ID because it's supposed to look like a wire message.)                                                // 1334\n          self._pushUpdate(updates, written.collection, {                                                              // 1335\n            msg: 'replace',                                                                                            // 1336\n            id: LocalCollection._idStringify(written.id),                                                              // 1337\n            replace: serverDoc.document                                                                                // 1338\n          });                                                                                                          // 1339\n          // Call all flush callbacks.                                                                                 // 1340\n          _.each(serverDoc.flushCallbacks, function (c) {                                                              // 1341\n            c();                                                                                                       // 1342\n          });                                                                                                          // 1343\n                                                                                                                       // 1344\n          // Delete this completed serverDocument. Don't bother to GC empty                                            // 1345\n          // IdMaps inside self._serverDocuments, since there probably aren't                                          // 1346\n          // many collections and they'll be written repeatedly.                                                       // 1347\n          self._serverDocuments[written.collection].remove(written.id);                                                // 1348\n        }                                                                                                              // 1349\n      });                                                                                                              // 1350\n      delete self._documentsWrittenByStub[methodId];                                                                   // 1351\n                                                                                                                       // 1352\n      // We want to call the data-written callback, but we can't do so until all                                       // 1353\n      // currently buffered messages are flushed.                                                                      // 1354\n      var callbackInvoker = self._methodInvokers[methodId];                                                            // 1355\n      if (!callbackInvoker)                                                                                            // 1356\n        throw new Error(\"No callback invoker for method \" + methodId);                                                 // 1357\n      self._runWhenAllServerDocsAreFlushed(                                                                            // 1358\n        _.bind(callbackInvoker.dataVisible, callbackInvoker));                                                         // 1359\n    });                                                                                                                // 1360\n  },                                                                                                                   // 1361\n                                                                                                                       // 1362\n  _process_ready: function (msg, updates) {                                                                            // 1363\n    var self = this;                                                                                                   // 1364\n    // Process \"sub ready\" messages. \"sub ready\" messages don't take effect                                            // 1365\n    // until all current server documents have been flushed to the local                                               // 1366\n    // database. We can use a write fence to implement this.                                                           // 1367\n    _.each(msg.subs, function (subId) {                                                                                // 1368\n      self._runWhenAllServerDocsAreFlushed(function () {                                                               // 1369\n        var subRecord = self._subscriptions[subId];                                                                    // 1370\n        // Did we already unsubscribe?                                                                                 // 1371\n        if (!subRecord)                                                                                                // 1372\n          return;                                                                                                      // 1373\n        // Did we already receive a ready message? (Oops!)                                                             // 1374\n        if (subRecord.ready)                                                                                           // 1375\n          return;                                                                                                      // 1376\n        subRecord.readyCallback && subRecord.readyCallback();                                                          // 1377\n        subRecord.ready = true;                                                                                        // 1378\n        subRecord.readyDeps.changed();                                                                                 // 1379\n      });                                                                                                              // 1380\n    });                                                                                                                // 1381\n  },                                                                                                                   // 1382\n                                                                                                                       // 1383\n  // Ensures that \"f\" will be called after all documents currently in                                                  // 1384\n  // _serverDocuments have been written to the local cache. f will not be called                                       // 1385\n  // if the connection is lost before then!                                                                            // 1386\n  _runWhenAllServerDocsAreFlushed: function (f) {                                                                      // 1387\n    var self = this;                                                                                                   // 1388\n    var runFAfterUpdates = function () {                                                                               // 1389\n      self._afterUpdateCallbacks.push(f);                                                                              // 1390\n    };                                                                                                                 // 1391\n    var unflushedServerDocCount = 0;                                                                                   // 1392\n    var onServerDocFlush = function () {                                                                               // 1393\n      --unflushedServerDocCount;                                                                                       // 1394\n      if (unflushedServerDocCount === 0) {                                                                             // 1395\n        // This was the last doc to flush! Arrange to run f after the updates                                          // 1396\n        // have been applied.                                                                                          // 1397\n        runFAfterUpdates();                                                                                            // 1398\n      }                                                                                                                // 1399\n    };                                                                                                                 // 1400\n    _.each(self._serverDocuments, function (collectionDocs) {                                                          // 1401\n      collectionDocs.forEach(function (serverDoc) {                                                                    // 1402\n        var writtenByStubForAMethodWithSentMessage = _.any(                                                            // 1403\n          serverDoc.writtenByStubs, function (dummy, methodId) {                                                       // 1404\n            var invoker = self._methodInvokers[methodId];                                                              // 1405\n            return invoker && invoker.sentMessage;                                                                     // 1406\n          });                                                                                                          // 1407\n        if (writtenByStubForAMethodWithSentMessage) {                                                                  // 1408\n          ++unflushedServerDocCount;                                                                                   // 1409\n          serverDoc.flushCallbacks.push(onServerDocFlush);                                                             // 1410\n        }                                                                                                              // 1411\n      });                                                                                                              // 1412\n    });                                                                                                                // 1413\n    if (unflushedServerDocCount === 0) {                                                                               // 1414\n      // There aren't any buffered docs --- we can call f as soon as the current                                       // 1415\n      // round of updates is applied!                                                                                  // 1416\n      runFAfterUpdates();                                                                                              // 1417\n    }                                                                                                                  // 1418\n  },                                                                                                                   // 1419\n                                                                                                                       // 1420\n  _livedata_nosub: function (msg) {                                                                                    // 1421\n    var self = this;                                                                                                   // 1422\n                                                                                                                       // 1423\n    // First pass it through _livedata_data, which only uses it to help get                                            // 1424\n    // towards quiescence.                                                                                             // 1425\n    self._livedata_data(msg);                                                                                          // 1426\n                                                                                                                       // 1427\n    // Do the rest of our processing immediately, with no                                                              // 1428\n    // buffering-until-quiescence.                                                                                     // 1429\n                                                                                                                       // 1430\n    // we weren't subbed anyway, or we initiated the unsub.                                                            // 1431\n    if (!_.has(self._subscriptions, msg.id))                                                                           // 1432\n      return;                                                                                                          // 1433\n                                                                                                                       // 1434\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback                                                                          // 1435\n    var errorCallback = self._subscriptions[msg.id].errorCallback;                                                     // 1436\n    var stopCallback = self._subscriptions[msg.id].stopCallback;                                                       // 1437\n                                                                                                                       // 1438\n    self._subscriptions[msg.id].remove();                                                                              // 1439\n                                                                                                                       // 1440\n    var meteorErrorFromMsg = function (msgArg) {                                                                       // 1441\n      return msgArg && msgArg.error && new Meteor.Error(                                                               // 1442\n        msgArg.error.error, msgArg.error.reason, msgArg.error.details);                                                // 1443\n    }                                                                                                                  // 1444\n                                                                                                                       // 1445\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback                                                                          // 1446\n    if (errorCallback && msg.error) {                                                                                  // 1447\n      errorCallback(meteorErrorFromMsg(msg));                                                                          // 1448\n    }                                                                                                                  // 1449\n                                                                                                                       // 1450\n    if (stopCallback) {                                                                                                // 1451\n      stopCallback(meteorErrorFromMsg(msg));                                                                           // 1452\n    }                                                                                                                  // 1453\n  },                                                                                                                   // 1454\n                                                                                                                       // 1455\n  _process_nosub: function () {                                                                                        // 1456\n    // This is called as part of the \"buffer until quiescence\" process, but                                            // 1457\n    // nosub's effect is always immediate. It only goes in the buffer at all                                           // 1458\n    // because it's possible for a nosub to be the thing that triggers                                                 // 1459\n    // quiescence, if we were waiting for a sub to be revived and it dies                                              // 1460\n    // instead.                                                                                                        // 1461\n  },                                                                                                                   // 1462\n                                                                                                                       // 1463\n  _livedata_result: function (msg) {                                                                                   // 1464\n    // id, result or error. error has error (code), reason, details                                                    // 1465\n                                                                                                                       // 1466\n    var self = this;                                                                                                   // 1467\n                                                                                                                       // 1468\n    // find the outstanding request                                                                                    // 1469\n    // should be O(1) in nearly all realistic use cases                                                                // 1470\n    if (_.isEmpty(self._outstandingMethodBlocks)) {                                                                    // 1471\n      Meteor._debug(\"Received method result but no methods outstanding\");                                              // 1472\n      return;                                                                                                          // 1473\n    }                                                                                                                  // 1474\n    var currentMethodBlock = self._outstandingMethodBlocks[0].methods;                                                 // 1475\n    var m;                                                                                                             // 1476\n    for (var i = 0; i < currentMethodBlock.length; i++) {                                                              // 1477\n      m = currentMethodBlock[i];                                                                                       // 1478\n      if (m.methodId === msg.id)                                                                                       // 1479\n        break;                                                                                                         // 1480\n    }                                                                                                                  // 1481\n                                                                                                                       // 1482\n    if (!m) {                                                                                                          // 1483\n      Meteor._debug(\"Can't match method response to original method call\", msg);                                       // 1484\n      return;                                                                                                          // 1485\n    }                                                                                                                  // 1486\n                                                                                                                       // 1487\n    // Remove from current method block. This may leave the block empty, but we                                        // 1488\n    // don't move on to the next block until the callback has been delivered, in                                       // 1489\n    // _outstandingMethodFinished.                                                                                     // 1490\n    currentMethodBlock.splice(i, 1);                                                                                   // 1491\n                                                                                                                       // 1492\n    if (_.has(msg, 'error')) {                                                                                         // 1493\n      m.receiveResult(new Meteor.Error(                                                                                // 1494\n        msg.error.error, msg.error.reason,                                                                             // 1495\n        msg.error.details));                                                                                           // 1496\n    } else {                                                                                                           // 1497\n      // msg.result may be undefined if the method didn't return a                                                     // 1498\n      // value                                                                                                         // 1499\n      m.receiveResult(undefined, msg.result);                                                                          // 1500\n    }                                                                                                                  // 1501\n  },                                                                                                                   // 1502\n                                                                                                                       // 1503\n  // Called by MethodInvoker after a method's callback is invoked.  If this was                                        // 1504\n  // the last outstanding method in the current block, runs the next block. If                                         // 1505\n  // there are no more methods, consider accepting a hot code push.                                                    // 1506\n  _outstandingMethodFinished: function () {                                                                            // 1507\n    var self = this;                                                                                                   // 1508\n    if (self._anyMethodsAreOutstanding())                                                                              // 1509\n      return;                                                                                                          // 1510\n                                                                                                                       // 1511\n    // No methods are outstanding. This should mean that the first block of                                            // 1512\n    // methods is empty. (Or it might not exist, if this was a method that                                             // 1513\n    // half-finished before disconnect/reconnect.)                                                                     // 1514\n    if (! _.isEmpty(self._outstandingMethodBlocks)) {                                                                  // 1515\n      var firstBlock = self._outstandingMethodBlocks.shift();                                                          // 1516\n      if (! _.isEmpty(firstBlock.methods))                                                                             // 1517\n        throw new Error(\"No methods outstanding but nonempty block: \" +                                                // 1518\n                        JSON.stringify(firstBlock));                                                                   // 1519\n                                                                                                                       // 1520\n      // Send the outstanding methods now in the first block.                                                          // 1521\n      if (!_.isEmpty(self._outstandingMethodBlocks))                                                                   // 1522\n        self._sendOutstandingMethods();                                                                                // 1523\n    }                                                                                                                  // 1524\n                                                                                                                       // 1525\n    // Maybe accept a hot code push.                                                                                   // 1526\n    self._maybeMigrate();                                                                                              // 1527\n  },                                                                                                                   // 1528\n                                                                                                                       // 1529\n  // Sends messages for all the methods in the first block in                                                          // 1530\n  // _outstandingMethodBlocks.                                                                                         // 1531\n  _sendOutstandingMethods: function() {                                                                                // 1532\n    var self = this;                                                                                                   // 1533\n    if (_.isEmpty(self._outstandingMethodBlocks))                                                                      // 1534\n      return;                                                                                                          // 1535\n    _.each(self._outstandingMethodBlocks[0].methods, function (m) {                                                    // 1536\n      m.sendMessage();                                                                                                 // 1537\n    });                                                                                                                // 1538\n  },                                                                                                                   // 1539\n                                                                                                                       // 1540\n  _livedata_error: function (msg) {                                                                                    // 1541\n    Meteor._debug(\"Received error from server: \", msg.reason);                                                         // 1542\n    if (msg.offendingMessage)                                                                                          // 1543\n      Meteor._debug(\"For: \", msg.offendingMessage);                                                                    // 1544\n  },                                                                                                                   // 1545\n                                                                                                                       // 1546\n  _callOnReconnectAndSendAppropriateOutstandingMethods: function() {                                                   // 1547\n    var self = this;                                                                                                   // 1548\n    var oldOutstandingMethodBlocks = self._outstandingMethodBlocks;                                                    // 1549\n    self._outstandingMethodBlocks = [];                                                                                // 1550\n                                                                                                                       // 1551\n    self.onReconnect();                                                                                                // 1552\n                                                                                                                       // 1553\n    if (_.isEmpty(oldOutstandingMethodBlocks))                                                                         // 1554\n      return;                                                                                                          // 1555\n                                                                                                                       // 1556\n    // We have at least one block worth of old outstanding methods to try                                              // 1557\n    // again. First: did onReconnect actually send anything? If not, we just                                           // 1558\n    // restore all outstanding methods and run the first block.                                                        // 1559\n    if (_.isEmpty(self._outstandingMethodBlocks)) {                                                                    // 1560\n      self._outstandingMethodBlocks = oldOutstandingMethodBlocks;                                                      // 1561\n      self._sendOutstandingMethods();                                                                                  // 1562\n      return;                                                                                                          // 1563\n    }                                                                                                                  // 1564\n                                                                                                                       // 1565\n    // OK, there are blocks on both sides. Special case: merge the last block of                                       // 1566\n    // the reconnect methods with the first block of the original methods, if                                          // 1567\n    // neither of them are \"wait\" blocks.                                                                              // 1568\n    if (!_.last(self._outstandingMethodBlocks).wait &&                                                                 // 1569\n        !oldOutstandingMethodBlocks[0].wait) {                                                                         // 1570\n      _.each(oldOutstandingMethodBlocks[0].methods, function (m) {                                                     // 1571\n        _.last(self._outstandingMethodBlocks).methods.push(m);                                                         // 1572\n                                                                                                                       // 1573\n        // If this \"last block\" is also the first block, send the message.                                             // 1574\n        if (self._outstandingMethodBlocks.length === 1)                                                                // 1575\n          m.sendMessage();                                                                                             // 1576\n      });                                                                                                              // 1577\n                                                                                                                       // 1578\n      oldOutstandingMethodBlocks.shift();                                                                              // 1579\n    }                                                                                                                  // 1580\n                                                                                                                       // 1581\n    // Now add the rest of the original blocks on.                                                                     // 1582\n    _.each(oldOutstandingMethodBlocks, function (block) {                                                              // 1583\n      self._outstandingMethodBlocks.push(block);                                                                       // 1584\n    });                                                                                                                // 1585\n  },                                                                                                                   // 1586\n                                                                                                                       // 1587\n  // We can accept a hot code push if there are no methods in flight.                                                  // 1588\n  _readyToMigrate: function() {                                                                                        // 1589\n    var self = this;                                                                                                   // 1590\n    return _.isEmpty(self._methodInvokers);                                                                            // 1591\n  },                                                                                                                   // 1592\n                                                                                                                       // 1593\n  // If we were blocking a migration, see if it's now possible to continue.                                            // 1594\n  // Call whenever the set of outstanding/blocked methods shrinks.                                                     // 1595\n  _maybeMigrate: function () {                                                                                         // 1596\n    var self = this;                                                                                                   // 1597\n    if (self._retryMigrate && self._readyToMigrate()) {                                                                // 1598\n      self._retryMigrate();                                                                                            // 1599\n      self._retryMigrate = null;                                                                                       // 1600\n    }                                                                                                                  // 1601\n  }                                                                                                                    // 1602\n});                                                                                                                    // 1603\n                                                                                                                       // 1604\nLivedataTest.Connection = Connection;                                                                                  // 1605\n                                                                                                                       // 1606\n// @param url {String} URL to Meteor app,                                                                              // 1607\n//     e.g.:                                                                                                           // 1608\n//     \"subdomain.meteor.com\",                                                                                         // 1609\n//     \"http://subdomain.meteor.com\",                                                                                  // 1610\n//     \"/\",                                                                                                            // 1611\n//     \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"                                                                  // 1612\n                                                                                                                       // 1613\n/**                                                                                                                    // 1614\n * @summary Connect to the server of a different Meteor application to subscribe to its document sets and invoke its remote methods.\n * @locus Anywhere                                                                                                     // 1616\n * @param {String} url The URL of another Meteor application.                                                          // 1617\n */                                                                                                                    // 1618\nDDP.connect = function (url, options) {                                                                                // 1619\n  var ret = new Connection(url, options);                                                                              // 1620\n  allConnections.push(ret); // hack. see below.                                                                        // 1621\n  return ret;                                                                                                          // 1622\n};                                                                                                                     // 1623\n                                                                                                                       // 1624\n// Hack for `spiderable` package: a way to see if the page is done                                                     // 1625\n// loading all the data it needs.                                                                                      // 1626\n//                                                                                                                     // 1627\nallConnections = [];                                                                                                   // 1628\nDDP._allSubscriptionsReady = function () {                                                                             // 1629\n  return _.all(allConnections, function (conn) {                                                                       // 1630\n    return _.all(conn._subscriptions, function (sub) {                                                                 // 1631\n      return sub.ready;                                                                                                // 1632\n    });                                                                                                                // 1633\n  });                                                                                                                  // 1634\n};                                                                                                                     // 1635\n                                                                                                                       // 1636\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function () {\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/ddp/server_convenience.js                                                                                  //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n// Only create a server if we are in an environment with a HTTP server                                                 // 1\n// (as opposed to, eg, a command-line tool).                                                                           // 2\n//                                                                                                                     // 3\n// Note: this whole conditional is a total hack to get around the fact that this                                       // 4\n// package logically should be split into a ddp-client and ddp-server package;                                         // 5\n// see https://github.com/meteor/meteor/issues/3452                                                                    // 6\n//                                                                                                                     // 7\n// Until we do that, this conditional (and the weak dependency on webapp that                                          // 8\n// should really be a strong dependency of the ddp-server package) allows you to                                       // 9\n// build projects which use `ddp` in Node without wanting to run a DDP server                                          // 10\n// (ie, allows you to act as if you were using the nonexistent `ddp-client`                                            // 11\n// server package).                                                                                                    // 12\nif (Package.webapp) {                                                                                                  // 13\n  if (process.env.DDP_DEFAULT_CONNECTION_URL) {                                                                        // 14\n    __meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL =                                                             // 15\n      process.env.DDP_DEFAULT_CONNECTION_URL;                                                                          // 16\n  }                                                                                                                    // 17\n                                                                                                                       // 18\n  Meteor.server = new Server;                                                                                          // 19\n                                                                                                                       // 20\n  Meteor.refresh = function (notification) {                                                                           // 21\n    DDPServer._InvalidationCrossbar.fire(notification);                                                                // 22\n  };                                                                                                                   // 23\n                                                                                                                       // 24\n  // Proxy the public methods of Meteor.server so they can                                                             // 25\n  // be called directly on Meteor.                                                                                     // 26\n  _.each(['publish', 'methods', 'call', 'apply', 'onConnection'],                                                      // 27\n         function (name) {                                                                                             // 28\n           Meteor[name] = _.bind(Meteor.server[name], Meteor.server);                                                  // 29\n         });                                                                                                           // 30\n} else {                                                                                                               // 31\n  // No server? Make these empty/no-ops.                                                                               // 32\n  Meteor.server = null;                                                                                                // 33\n  Meteor.refresh = function (notification) {                                                                           // 34\n  };                                                                                                                   // 35\n                                                                                                                       // 36\n  // Make these empty/no-ops too, so that non-webapp apps can still                                                    // 37\n  // depend on/use packages that use those functions.                                                                  // 38\n  _.each(['publish', 'methods', 'onConnection'],                                                                       // 39\n      function (name) {                                                                                                // 40\n        Meteor[name] = function () { };                                                                                // 41\n      });                                                                                                              // 42\n}                                                                                                                      // 43\n                                                                                                                       // 44\n// Meteor.server used to be called Meteor.default_server. Provide                                                      // 45\n// backcompat as a courtesy even though it was never documented.                                                       // 46\n// XXX COMPAT WITH 0.6.4                                                                                               // 47\nMeteor.default_server = Meteor.server;                                                                                 // 48\n                                                                                                                       // 49\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage.ddp = {\n  DDP: DDP,\n  DDPServer: DDPServer,\n  LivedataTest: LivedataTest\n};\n\n})();\n\n//# sourceMappingURL=ddp.js.map\n",
			"file": ".meteor/local/build/programs/server/packages/ddp.js",
			"file_size": 586070,
			"file_write_time": 130765779657035851,
			"settings":
			{
				"buffer_size": 586070,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 392.0,
		"last_filter": "paclk",
		"selected_items":
		[
			[
				"paclk",
				"Package Control: Install Package"
			],
			[
				"coff",
				"CoffeeToJs: Convert file"
			],
			[
				"pac",
				"Package Control: Install Package"
			],
			[
				"pack",
				"Package Control: Remove Package"
			],
			[
				"git",
				"Git: Commit"
			],
			[
				"doc",
				"DocBlockr: Decorate line comment"
			],
			[
				"do",
				"DocBlockr: Decorate line comment"
			],
			[
				"g",
				"Git: Commit"
			],
			[
				"in",
				"Package Control: Install Package"
			],
			[
				"insta",
				"Package Control: Install Package"
			],
			[
				"ftp",
				"SFTP: Browse Server"
			],
			[
				"json",
				"JsonTree: Show Tree"
			],
			[
				"js",
				"JsonTree: Show Tree"
			],
			[
				"pa",
				"Package Control: Install Package"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"instal",
				"Package Control: Install Package"
			],
			[
				"Snippet: d",
				"Snippet: d3.selectAll"
			],
			[
				"bea",
				"HTMLBeautify"
			],
			[
				"html",
				"HTMLBeautify"
			],
			[
				"Snippet: ",
				"Snippet: bs3-navbar-inverse"
			],
			[
				"beau",
				"HTMLBeautify"
			]
		],
		"width": 528.0
	},
	"console":
	{
		"height": 126.0,
		"history":
		[
			"import urllib.request,os,sys; exec(\"if sys.version_info < (3,) or os.name != 'nt': raise OSError('This code is for Windows ST3 only!')\"); pr='Preferences.sublime-settings'; ip='ignored_packages'; n='Package Control'; s=sublime.load_settings(pr); ig=s.get(ip); ig.append(n); s.set(ip,ig); sublime.save_settings('Preferences.sublime-settings'); pf=n+'.sublime-package'; urllib.request.install_opener(urllib.request.build_opener(urllib.request.ProxyHandler())); by=urllib.request.urlopen('https://packagecontrol.io/'+pf.replace(' ','%20')).read(); open(os.path.join(sublime.installed_packages_path(),pf),'wb').write(by); ig.remove(n); s.set(ip,ig); sublime.save_settings(pr); print('Package Control: 3.0.0 upgrade successful!')",
			"import urllib.request,os,hashlib; h = '7183a2d3e96f11eeadd761d777e62404' + 'e330c659d4bb41d3bdf022e94cab3cd0'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/C/socialite",
		"/C/socialite/both",
		"/C/socialite/both/lib",
		"/C/socialite/both/router",
		"/C/socialite/client",
		"/C/socialite/client/layouts",
		"/C/socialite/client/layouts/frontend",
		"/C/socialite/client/views",
		"/C/socialite/client/views/dashboard",
		"/C/socialite/client/views/invitation",
		"/C/socialite/client/views/landing",
		"/C/socialite/public",
		"/C/socialite/resources"
	],
	"file_history":
	[
		"/C/socialite/client/views/landing/landing.html",
		"/C/socialite/.meteor/local/build/programs/server/app/collections/bugs/lib/schema.coffee.js",
		"/C/socialite/client/views/invitation/invitation.html",
		"/C/socialite/client/views/landing/landing.sass",
		"/C/socialite/client/views/landing/login/sign_up.html",
		"/C/socialite/collections/users/lib/sign_up_schema.coffee",
		"/C/socialite/collections/bugs/lib/schema.coffee",
		"/C/socialite/both/controllers/dashboard_controller.coffee",
		"/C/socialite/client/layouts/frontend/general_layout.html",
		"/C/socialite/collections/votes/lib/definition.coffee",
		"/C/socialite/collections/bugs/server/publish.coffee",
		"/C/atmosphere/app/.meteor/release",
		"/C/socialite/.meteor/packages",
		"/C/atmosphere/app/.meteor/packages",
		"/C/atmosphere/app/client/accounts.js",
		"/C/atmosphere/app/client/accounts.html",
		"/C/atmosphere/app/atmosphere.html",
		"/C/atmosphere/app/docs.html",
		"/C/atmosphere/app/server/_settings.js",
		"/C/atmosphere/app/server/data.js",
		"/C/socialite/.meteor/release",
		"/C/socialite/both/controllers/dashboard_controller.js",
		"/C/socialite/collections/bugs/lib/definition.js",
		"/C/socialite/collections/bugs/lib/schema.js",
		"/C/Users/darren/AppData/Roaming/Sublime Text 3/Packages/CoffeeCompile/CoffeeCompile.sublime-settings",
		"/C/dd/both/collections/customers.js",
		"/C/serviceme/ServiceMe/server/startup/loadFixtures.js",
		"/C/serviceme/ServiceMe/server/config/security.js",
		"/C/serviceme/ServiceMe/routes/mainRoutes.js",
		"/C/serviceme/ServiceMe/README.md",
		"/C/serviceme/ServiceMe/client/lib/semantic-ui/.custom.semantic.json",
		"/C/serviceme/ServiceMe/models/servicelist.js",
		"/C/Users/darren/AppData/Roaming/npm/node_modules/bower/node_modules/handlebars/package.json",
		"/C/socialite/.meteor/platforms",
		"/C/serviceme/ServiceMe/COMMIT_EDITMSG.COMMIT_EDITMSG",
		"/C/serviceme/ServiceMe/.git/config",
		"/C/Users/darren/AppData/Roaming/Sublime Text 3/Packages/Git/Git.sublime-settings",
		"/C/Users/darren/AppData/Roaming/Sublime Text 3/Packages/User/Git.sublime-settings",
		"/C/serviceme/ServiceMe/client/lib/semantic-ui/custom.semantic.json",
		"/C/serviceme/ServiceMe/models/users.js",
		"/C/serviceme/ServiceMe/server/publications/usersPub.js",
		"/C/Users/darren/AppData/Roaming/npm/node_modules/orion-cli/lib/fileManager.js",
		"/C/lamp/www/lazyservices/resources/views/backend/layouts/master.blade.php",
		"/C/lamp/www/lazyservices/resources/views/backend/dashboard.blade.php",
		"/C/composer-demo/vendor/autoload.php",
		"/C/composer-demo/vendor/composer/autoload_real.php",
		"/C/composer-demo/vendor/composer/autoload_classmap.php",
		"/C/composer-demo/vendor/composer/autoload_psr4.php",
		"/C/lamp/bin/php/php-5.6.7/php.ini",
		"/C/wamp/bin/php/php5.5.12/php.ini",
		"/C/Users/darren/Downloads/auction.sql",
		"/C/lamp/www/serviceme/database/seeds/DatabaseSeeder.php",
		"/C/lamp/www/serviceme/database/migrations/2015_05_11_055604_create_raychatmessages_table.php",
		"/C/lamp/www/serviceme/composer.json",
		"/C/lamp/www/serviceme/config/app.php",
		"/C/lamp/www/auction/yourauctions.php",
		"/C/lamp/www/auction/themes/default/auction_watch.tpl",
		"/C/lamp/www/auction2/app/config/app.php",
		"/C/lamp/www/auction2/app/config/database.php",
		"/C/lamp/www/auction2/server.php",
		"/C/lamp/www/lazyservices/.env",
		"/C/lamp/www/lazyservices/database/seeds/UserTableSeeder.php",
		"/C/Users/darren/Downloads/getmybusiness.sql",
		"/C/lamp/www/serviceme_admin/index.html",
		"/C/lamp/www/serviceme_admin/javascript/home.js",
		"/C/wamp/www/dd/index.php",
		"/C/wamp/www/fuel/.htaccess",
		"/C/lamp/www/serviceme/package.json",
		"/C/composer-demo/composer.json",
		"/C/lamp/www/serviceme_admin/stylesheets/home.css",
		"/C/wamp/www/iProduct/system/core/Config.php",
		"/C/wamp/www/iProduct/system/database/DB_driver.php",
		"/C/wamp/www/iProduct/application/config/config.php",
		"/C/wamp/www/iProduct/application/config/database.php",
		"/C/wamp/www/serviceme/application/config/config.php",
		"/C/wamp/www/application/config/config.php",
		"/C/wamp/www/index (2).php",
		"/C/lamp/www/serviceme_admin/customize.html",
		"/C/lamp/www/serviceme_admin/src/definitions/collections/breadcrumb.less",
		"/C/lamp/www/serviceme_admin/src/definitions/collections/form.less",
		"/C/lamp/www/serviceme_admin/src/definitions/collections/grid.less",
		"/C/lamp/www/serviceme_admin/src/definitions/collections/menu.less",
		"/C/lamp/www/serviceme_admin/src/definitions/collections/message.less",
		"/C/lamp/www/serviceme_admin/src/definitions/collections/table.less",
		"/C/lamp/www/serviceme_admin/src/definitions/elements/button.less",
		"/C/lamp/www/serviceme_admin/src/definitions/elements/divider.less",
		"/C/lamp/www/serviceme_admin/src/definitions/elements/flag.less",
		"/C/lamp/www/serviceme_admin/src/definitions/elements/header.less",
		"/C/lamp/www/serviceme_admin/src/definitions/elements/icon.less",
		"/C/lamp/www/serviceme_admin/src/definitions/elements/image.less",
		"/C/lamp/www/serviceme_admin/src/definitions/elements/input.less",
		"/C/lamp/www/serviceme_admin/src/definitions/elements/label.less",
		"/C/lamp/www/serviceme_admin/src/definitions/elements/list.less",
		"/C/lamp/www/serviceme_admin/src/definitions/elements/loader.less",
		"/C/lamp/www/serviceme_admin/src/definitions/elements/rail.less",
		"/C/lamp/www/serviceme_admin/src/definitions/elements/reveal.less",
		"/C/lamp/www/serviceme_admin/src/definitions/elements/segment.less",
		"/C/lamp/www/serviceme_admin/src/definitions/elements/step.less",
		"/C/lamp/www/serviceme_admin/src/definitions/globals/reset.less",
		"/C/lamp/www/serviceme_admin/src/definitions/globals/site.less",
		"/C/lamp/www/serviceme_admin/src/definitions/modules/accordion.less",
		"/C/lamp/www/serviceme_admin/src/definitions/modules/checkbox.less",
		"/C/lamp/www/serviceme_admin/src/definitions/modules/dimmer.less",
		"/C/lamp/www/serviceme_admin/src/definitions/modules/dropdown.less",
		"/C/lamp/www/serviceme_admin/src/definitions/modules/modal.less",
		"/C/lamp/www/serviceme_admin/src/definitions/modules/nag.less",
		"/C/lamp/www/serviceme_admin/src/definitions/modules/popup.less",
		"/C/lamp/www/serviceme_admin/src/definitions/modules/progress.less",
		"/C/lamp/www/serviceme_admin/src/definitions/modules/rating.less",
		"/C/lamp/www/serviceme_admin/src/definitions/modules/search.less",
		"/C/lamp/www/serviceme_admin/src/definitions/modules/shape.less",
		"/C/lamp/www/serviceme_admin/src/definitions/modules/sidebar.less",
		"/C/lamp/www/serviceme_admin/src/definitions/modules/sticky.less",
		"/C/lamp/www/serviceme_admin/src/definitions/modules/tab.less",
		"/C/lamp/www/serviceme_admin/src/definitions/modules/transition.less",
		"/C/lamp/www/serviceme_admin/src/definitions/modules/video.less",
		"/C/lamp/www/serviceme_admin/src/definitions/views/ad.less",
		"/C/lamp/www/serviceme_admin/src/definitions/views/card.less",
		"/C/lamp/www/serviceme_admin/src/definitions/views/comment.less",
		"/C/lamp/www/serviceme_admin/src/definitions/views/feed.less",
		"/C/lamp/www/serviceme_admin/src/definitions/views/item.less",
		"/C/lamp/www/serviceme_admin/src/definitions/views/statistic.less",
		"/C/lamp/www/serviceme_admin/src/README.md",
		"/C/lamp/www/serviceme/user/behaviors/api.html",
		"/C/lamp/www/serviceme/user/behaviors/form.html",
		"/C/lamp/www/serviceme/user/behaviors/visibility.html",
		"/C/lamp/www/serviceme/user/collections/breadcrumb.html",
		"/C/lamp/www/serviceme/user/collections/form.html"
	],
	"find":
	{
		"height": 34.0
	},
	"find_in_files":
	{
		"height": 92.0,
		"where_history":
		[
			"<project>",
			"C:\\socialite",
			"<project>",
			"C:\\lamp\\www\\serviceme_admin",
			"C:\\lamp\\www\\serviceme\\user",
			"<project>",
			"C:\\Users\\darren\\Desktop\\kula",
			"C:\\lightning\\fathomless-cliffs-2571",
			"C:\\airtaskr\\kulafencing\\website\\kulafencing\\kulafencing.com,<open files>,C:\\airtaskr\\kulafencing\\website\\kulafencing\\kulafencing.com",
			"C:\\airtaskr\\kulafencing\\website\\kulafencing\\kulafencing.com,<open files>",
			"C:\\airtaskr\\kulafencing\\website\\kulafencing\\kulafencing.com\\",
			"C:\\airtaskr\\kulafencing\\website\\kulafencing\\kulafencing.com",
			"C:\\wamp\\www\\flat\\demo.flatlogic.com\\sing-bootstrapbay\\ajax"
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"pickadateOptions",
			"pickadate",
			"date",
			"datep",
			"invitation-form",
			"logo.png",
			"sockjs",
			"what bugs you",
			"smart.json",
			"`users",
			"'users",
			"alter table `u",
			"users",
			"pgsql",
			"'",
			"`",
			"introdu",
			"iteration",
			"header",
			"make",
			"library",
			"learn",
			"theme.config",
			".js",
			"theme",
			"theme.config",
			"? '",
			"src=\"images",
			"src=\"javascript",
			"src=\"dist",
			"href=\"dist",
			": '/",
			"? '/",
			"src=\"/",
			"href=\"/",
			"http",
			"twitter",
			"src=\"/",
			"href=\"/",
			"src=\"/",
			"href=\"/",
			"face",
			".ini",
			"about",
			"blog",
			"soc",
			"loading screen",
			"loading",
			"modal",
			"Hello",
			"todo",
			"addTodo",
			"<!-- [a-z][0-9]g -->",
			"<!-- [a-z][0-9] -->",
			"./HTML 5 PivotViewer_files",
			"http://kulafencing.com/php/",
			"d3",
			"scatter",
			"find out more",
			"pages",
			"home/",
			"<img alt=\"Kula Fencing\" class=\"img-responsive\" src=\"img/logo.png\">",
			"alt=\"Kula Fencing\" class=\"img-responsive\" src=\"img/logo.png\" alt=\"logo\"",
			"timber",
			"logo",
			"address",
			"get in touch",
			"</a></a>",
			"<a href=\"tel:0481216070\"><a href=\"tel:0481216070\">",
			"Get in touch",
			"<span>Get in Touch</span>",
			"<div class=\"footer-ribbon\">\n						<span>Get in Touch</span>\n					</div>",
			"Get in Touch",
			"pool fencing",
			"get started",
			"14722",
			"residen",
			"resident",
			"481",
			"tel",
			"fram",
			"framl",
			"fram",
			"detect-deviceatlas-com.appspot.com",
			"detect",
			"full website",
			"fa-angle-right",
			"social-spri",
			"social-icons",
			"social",
			"        <h5 class=\"sidebar-nav-title\">Labels <a class=\"action-link\" href=\"#\"><i class=\"glyphicon glyphicon-plus\"></i></a></h5>\n        <!-- some styled links in sidebar. ready to use as links to email folders, projects, groups, etc -->\n        <ul class=\"sidebar-labels\">\n            <li>\n                <a href=\"#\">\n                    <!-- yep, .circle again -->\n                    <i class=\"fa fa-circle text-warning mr-xs\"></i>\n                    <span class=\"label-name\">My Recent</span>\n                </a>\n            </li>\n            <li>\n                <a href=\"#\">\n                    <i class=\"fa fa-circle text-gray mr-xs\"></i>\n                    <span class=\"label-name\">Starred</span>\n                </a>\n            </li>\n            <li>\n                <a href=\"#\">\n                    <i class=\"fa fa-circle text-danger mr-xs\"></i>\n                    <span class=\"label-name\">Background</span>\n                </a>\n            </li>\n        </ul>\n        <h5 class=\"sidebar-nav-title\">Projects</h5>\n        <!-- A place for sidebar notifications & alerts -->\n        <div class=\"sidebar-alerts\">\n            <div class=\"alert fade in\">\n                <a href=\"#\" class=\"close\" data-dismiss=\"alert\" aria-hidden=\"true\">&times;</a>\n                <span class=\"text-white fw-semi-bold\">Sales Report</span> <br>\n                <div class=\"progress progress-xs mt-xs mb-0\">\n                    <div class=\"progress-bar progress-bar-gray-light\" style=\"width: 16%\"></div>\n                </div>\n                <small>Calculating x-axis bias... 65%</small>\n            </div>\n            <div class=\"alert fade in\">\n                <a href=\"#\" class=\"close\" data-dismiss=\"alert\" aria-hidden=\"true\">&times;</a>\n                <span class=\"text-white fw-semi-bold\">Personal Responsibility</span> <br>\n                <div class=\"progress progress-xs mt-xs mb-0\">\n                    <div class=\"progress-bar progress-bar-danger\" style=\"width: 23%\"></div>\n                </div>\n                <small>Provide required notes</small>\n            </div>\n        </div>",
			"dashboard",
			"widgets",
			"label-da",
			"-->",
			"<title>Sing",
			"grouped",
			"stacked",
			"   <a href=\"index.html\">sing</a>",
			"<h3 class=\"mt-lg mb-lg\">Sing - <span class=\"fw-semi-bold\">Next Generation</span> Admin Dashboard\n                                Template</h3>\n",
			"   &nbsp;\n                sing\n                &nbsp;",
			"  <h5 class=\"sidebar-nav-title\">Template <a class=\"action-link\" href=\"#\"><i class=\"glyphicon glyphicon-refresh\"></i></a></h5>",
			"TEMPLATE",
			" <li>\n                <a href=\"inbox.html\">\n                    <span class=\"icon\">\n                        <i class=\"fa fa-envelope\"></i>\n                    </span>\n                    Email\n                    <span class=\"label label-danger\">\n                        9\n                    </span>\n                </a>\n            </li>",
			"email",
			"d3",
			"nv3",
			"jess",
			"S",
			"list__item__2",
			"form<"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"",
			"'",
			"theme.configx",
			"? '../",
			"src=\"../images",
			"src=\"../javascript",
			"src=\"../dist",
			"href=\"../dist",
			": '",
			"? '",
			"src=\"",
			"href=\"",
			"src=\"",
			"href=\"",
			"src=\"",
			"href=\"",
			"/lex/js",
			"/js",
			"http://kulafencing.com/",
			"<img alt=\"Kula Fencing\" class=\"img-responsive hidden-xs\" src=\"img/logo.png\">",
			"alt=\"Kula Fencing\" class=\"img-responsive hidden-xs\" src=\"img/logo.png\" alt=\"logo\"",
			"</a>",
			"<a href=\"tel:0481216070\">",
			"<a href=\"tel:0481216070\"><span>Get in Touch</span></a>",
			"<div class=\"footer-ribbon\">\n						<a href=\"tel:0481216070\"><span>Get in Touch</a></span></a>\n					</div>",
			"",
			"<title>FundWatch",
			"   <a href=\"index.html\">FundWatch</a>",
			"<h3 class=\"mt-lg mb-lg\">FundWatch - <span class=\"fw-semi-bold\">Next Generation</span> Fund Dashboard\n                                </h3>\n",
			"   &nbsp;\n                FundWatch\n                &nbsp;",
			"  <h5 class=\"sidebar-nav-title\">Item Demos<a class=\"action-link\" href=\"#\"><i class=\"glyphicon glyphicon-refresh\"></i></a></h5>",
			"<!--  <li>\n                <a href=\"inbox.html\">\n                    <span class=\"icon\">\n                        <i class=\"fa fa-envelope\"></i>\n                    </span>\n                    Email\n                    <span class=\"label label-danger\">\n                        9\n                    </span>\n                </a>\n            </li> -->"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "client/views/dashboard/dashboard_header.html",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1830,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content"
							],
							"color_scheme": "Packages/User/Color Highlighter/themes/Monokai.tmTheme",
							"syntax": "Packages/HTML/HTML.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "/C/autoform/books.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 720,
						"regions":
						{
						},
						"selection":
						[
							[
								719,
								692
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content"
							],
							"color_scheme": "Packages/User/Color Highlighter/themes/Monokai.tmTheme",
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "/C/autoform/.meteor/local/build/programs/server/packages/materialize_materialize.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 234,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content"
							],
							"color_scheme": "Packages/User/Color Highlighter/themes/Monokai.tmTheme",
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "/C/autoform/.meteor/local/build/programs/server/packages/gildaspk_autoform-materialize.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 374,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content"
							],
							"color_scheme": "Packages/User/Color Highlighter/themes/Monokai.tmTheme",
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "/C/autoform/.meteor/local/build/programs/server/app/autoform-materialize.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 90,
						"regions":
						{
						},
						"selection":
						[
							[
								90,
								90
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content"
							],
							"color_scheme": "Packages/User/Color Highlighter/themes/Monokai.tmTheme",
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "/C/autoform/.meteor/local/build/programs/server/app/books.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 739,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content"
							],
							"color_scheme": "Packages/User/Color Highlighter/themes/Monokai.tmTheme",
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "/C/autoform/.meteor/local/build/programs/web.browser/packages/materialize_materialize.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 122007,
						"regions":
						{
						},
						"selection":
						[
							[
								1095,
								1095
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content"
							],
							"color_scheme": "Packages/User/Color Highlighter/themes/Monokai.tmTheme",
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "/C/autoform/.meteor/local/build/programs/web.browser/packages/materialize_materialize.js.map",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 123532,
						"regions":
						{
						},
						"selection":
						[
							[
								109686,
								109690
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content"
							],
							"color_scheme": "Packages/User/Color Highlighter/themes/Monokai.tmTheme",
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 21096.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "/C/autoform/.meteor/local/build/programs/web.browser/packages/gildaspk_autoform-materialize.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 124877,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content"
							],
							"color_scheme": "Packages/User/Color Highlighter/themes/Monokai.tmTheme",
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 18220.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "/C/autoform/autoform-materialize.html",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 158,
						"regions":
						{
						},
						"selection":
						[
							[
								146,
								77
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content"
							],
							"color_scheme": "Packages/User/Color Highlighter/themes/Monokai.tmTheme",
							"syntax": "Packages/HTML/HTML.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "/C/autoform/autoform-materialize.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 71,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content"
							],
							"color_scheme": "Packages/User/Color Highlighter/themes/Monokai.tmTheme",
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "client/views/dashboard/dashboard_header.coffee",
					"semi_transient": true,
					"settings":
					{
						"buffer_size": 663,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content"
							],
							"color_scheme": "Packages/User/Color Highlighter/themes/Monokai.tmTheme",
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"type": "text"
				},
				{
					"buffer": 12,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 520388,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										188,
										194
									],
									[
										672,
										678
									],
									[
										699,
										705
									],
									[
										1384,
										1390
									],
									[
										1484,
										1490
									],
									[
										2183,
										2189
									],
									[
										2804,
										2810
									],
									[
										2838,
										2844
									],
									[
										3089,
										3095
									],
									[
										3221,
										3227
									],
									[
										3234,
										3240
									],
									[
										3361,
										3367
									],
									[
										4026,
										4032
									],
									[
										4653,
										4659
									],
									[
										4819,
										4825
									],
									[
										5464,
										5470
									],
									[
										5478,
										5484
									],
									[
										6134,
										6140
									],
									[
										6270,
										6276
									],
									[
										6295,
										6301
									],
									[
										6950,
										6956
									],
									[
										7597,
										7603
									],
									[
										7723,
										7729
									],
									[
										7745,
										7751
									],
									[
										8416,
										8422
									],
									[
										8654,
										8660
									],
									[
										8822,
										8828
									],
									[
										9497,
										9503
									],
									[
										10127,
										10133
									],
									[
										10656,
										10662
									],
									[
										10953,
										10959
									],
									[
										11600,
										11606
									],
									[
										11709,
										11715
									],
									[
										12243,
										12249
									],
									[
										12661,
										12667
									],
									[
										12668,
										12674
									],
									[
										13361,
										13367
									],
									[
										13997,
										14003
									],
									[
										14679,
										14685
									],
									[
										15328,
										15334
									],
									[
										15384,
										15390
									],
									[
										15995,
										16001
									],
									[
										16019,
										16025
									],
									[
										16670,
										16676
									],
									[
										16704,
										16710
									],
									[
										49531,
										49537
									],
									[
										49558,
										49564
									],
									[
										49822,
										49828
									],
									[
										49873,
										49879
									],
									[
										54171,
										54177
									],
									[
										56521,
										56527
									],
									[
										56555,
										56561
									],
									[
										56687,
										56693
									],
									[
										56732,
										56738
									],
									[
										56747,
										56753
									],
									[
										56800,
										56806
									],
									[
										56977,
										56983
									],
									[
										58986,
										58992
									],
									[
										59055,
										59061
									],
									[
										59199,
										59205
									],
									[
										59213,
										59219
									],
									[
										60642,
										60648
									],
									[
										60680,
										60686
									],
									[
										60705,
										60711
									],
									[
										64550,
										64556
									],
									[
										64815,
										64821
									],
									[
										64829,
										64835
									],
									[
										64851,
										64857
									],
									[
										65203,
										65209
									],
									[
										65332,
										65338
									],
									[
										65446,
										65452
									],
									[
										65938,
										65944
									],
									[
										66173,
										66179
									],
									[
										66339,
										66345
									],
									[
										66531,
										66537
									],
									[
										68385,
										68391
									],
									[
										68431,
										68437
									],
									[
										68622,
										68628
									],
									[
										68828,
										68834
									],
									[
										68835,
										68841
									],
									[
										69492,
										69498
									],
									[
										81582,
										81588
									],
									[
										115911,
										115917
									],
									[
										148953,
										148959
									],
									[
										149009,
										149015
									],
									[
										150674,
										150680
									],
									[
										150698,
										150704
									],
									[
										210829,
										210835
									],
									[
										210863,
										210869
									],
									[
										213822,
										213828
									],
									[
										213932,
										213938
									],
									[
										216033,
										216039
									],
									[
										216088,
										216094
									],
									[
										220322,
										220328
									],
									[
										220813,
										220819
									],
									[
										231603,
										231609
									],
									[
										233821,
										233827
									],
									[
										255018,
										255024
									],
									[
										255028,
										255034
									],
									[
										255482,
										255488
									],
									[
										256099,
										256105
									],
									[
										256136,
										256142
									],
									[
										256734,
										256740
									],
									[
										257399,
										257405
									],
									[
										257406,
										257412
									],
									[
										258062,
										258068
									],
									[
										258465,
										258471
									],
									[
										259080,
										259086
									],
									[
										259208,
										259214
									],
									[
										259843,
										259849
									],
									[
										260502,
										260508
									],
									[
										261123,
										261129
									],
									[
										261273,
										261279
									],
									[
										261522,
										261528
									],
									[
										262189,
										262195
									],
									[
										262818,
										262824
									],
									[
										263447,
										263453
									],
									[
										263705,
										263711
									],
									[
										263963,
										263969
									],
									[
										264092,
										264098
									],
									[
										264221,
										264227
									],
									[
										264350,
										264356
									],
									[
										264608,
										264614
									],
									[
										265253,
										265259
									],
									[
										265539,
										265545
									],
									[
										266182,
										266188
									],
									[
										266807,
										266813
									],
									[
										267093,
										267099
									],
									[
										267710,
										267716
									],
									[
										267996,
										268002
									],
									[
										268613,
										268619
									],
									[
										268899,
										268905
									],
									[
										269028,
										269034
									],
									[
										269157,
										269163
									],
									[
										269808,
										269814
									],
									[
										270453,
										270459
									],
									[
										271082,
										271088
									],
									[
										271733,
										271739
									],
									[
										272396,
										272402
									],
									[
										272525,
										272531
									],
									[
										273177,
										273183
									],
									[
										273308,
										273314
									],
									[
										273709,
										273715
									],
									[
										274107,
										274113
									],
									[
										274752,
										274758
									],
									[
										275369,
										275375
									],
									[
										275912,
										275918
									],
									[
										276041,
										276047
									],
									[
										276423,
										276429
									],
									[
										277046,
										277052
									],
									[
										277332,
										277338
									],
									[
										277590,
										277596
									],
									[
										278213,
										278219
									],
									[
										278886,
										278892
									],
									[
										278893,
										278899
									],
									[
										279541,
										279547
									],
									[
										280191,
										280197
									],
									[
										280843,
										280849
									],
									[
										280850,
										280856
									],
									[
										281489,
										281495
									],
									[
										282147,
										282153
									],
									[
										282798,
										282804
									],
									[
										283447,
										283453
									],
									[
										284098,
										284104
									],
									[
										284769,
										284775
									],
									[
										285374,
										285380
									],
									[
										286053,
										286059
									],
									[
										286195,
										286201
									],
									[
										286446,
										286452
									],
									[
										286859,
										286865
									],
									[
										287474,
										287480
									],
									[
										287481,
										287487
									],
									[
										288141,
										288147
									],
									[
										288774,
										288780
									],
									[
										288781,
										288787
									],
									[
										289441,
										289447
									],
									[
										290091,
										290097
									],
									[
										290740,
										290746
									],
									[
										291361,
										291367
									],
									[
										291877,
										291883
									],
									[
										292547,
										292553
									],
									[
										292786,
										292792
									],
									[
										292824,
										292830
									],
									[
										293308,
										293314
									],
									[
										293339,
										293345
									],
									[
										293967,
										293973
									],
									[
										294577,
										294583
									],
									[
										294604,
										294610
									],
									[
										295249,
										295255
									],
									[
										295856,
										295862
									],
									[
										296550,
										296556
									],
									[
										297177,
										297183
									],
									[
										297294,
										297300
									],
									[
										297555,
										297561
									],
									[
										297935,
										297941
									],
									[
										297944,
										297950
									],
									[
										298570,
										298576
									],
									[
										298604,
										298610
									],
									[
										298845,
										298851
									],
									[
										298972,
										298978
									],
									[
										298985,
										298991
									],
									[
										299107,
										299113
									],
									[
										299747,
										299753
									],
									[
										300349,
										300355
									],
									[
										300510,
										300516
									],
									[
										301130,
										301136
									],
									[
										301144,
										301150
									],
									[
										301775,
										301781
									],
									[
										301906,
										301912
									],
									[
										301931,
										301937
									],
									[
										302536,
										302542
									],
									[
										302592,
										302598
									],
									[
										303178,
										303184
									],
									[
										303202,
										303208
									],
									[
										303828,
										303834
									],
									[
										303862,
										303868
									],
									[
										304336,
										304342
									],
									[
										304372,
										304378
									],
									[
										339785,
										339791
									],
									[
										339822,
										339828
									],
									[
										344354,
										344360
									],
									[
										349948,
										349954
									],
									[
										349955,
										349961
									],
									[
										352687,
										352693
									],
									[
										352795,
										352801
									],
									[
										361398,
										361404
									],
									[
										361446,
										361452
									],
									[
										363302,
										363308
									],
									[
										375433,
										375439
									],
									[
										375607,
										375613
									],
									[
										375693,
										375699
									],
									[
										375757,
										375763
									],
									[
										376991,
										376997
									],
									[
										377109,
										377115
									],
									[
										377771,
										377777
									],
									[
										377813,
										377819
									],
									[
										377844,
										377850
									],
									[
										377868,
										377874
									],
									[
										377886,
										377892
									],
									[
										377907,
										377913
									],
									[
										377929,
										377935
									],
									[
										378049,
										378055
									],
									[
										378146,
										378152
									],
									[
										378333,
										378339
									],
									[
										378582,
										378588
									],
									[
										378686,
										378692
									],
									[
										378796,
										378802
									],
									[
										378902,
										378908
									],
									[
										378998,
										379004
									],
									[
										379110,
										379116
									],
									[
										379160,
										379166
									],
									[
										379204,
										379210
									],
									[
										379673,
										379679
									],
									[
										380108,
										380114
									],
									[
										380236,
										380242
									],
									[
										380969,
										380975
									],
									[
										381567,
										381573
									],
									[
										381600,
										381606
									],
									[
										382052,
										382058
									],
									[
										382088,
										382094
									],
									[
										382238,
										382244
									],
									[
										382449,
										382455
									],
									[
										383070,
										383076
									],
									[
										383224,
										383230
									],
									[
										383417,
										383423
									],
									[
										383466,
										383472
									],
									[
										383534,
										383540
									],
									[
										383640,
										383646
									],
									[
										383732,
										383738
									],
									[
										383827,
										383833
									],
									[
										383931,
										383937
									],
									[
										384618,
										384624
									],
									[
										384625,
										384631
									],
									[
										384962,
										384968
									],
									[
										385210,
										385216
									],
									[
										385967,
										385973
									],
									[
										385974,
										385980
									],
									[
										397079,
										397085
									],
									[
										400683,
										400689
									],
									[
										401675,
										401681
									],
									[
										402069,
										402075
									],
									[
										402423,
										402429
									],
									[
										405209,
										405215
									],
									[
										407013,
										407019
									],
									[
										407779,
										407785
									],
									[
										407840,
										407846
									],
									[
										407980,
										407986
									],
									[
										408160,
										408166
									],
									[
										409831,
										409837
									],
									[
										409838,
										409844
									],
									[
										412250,
										412256
									],
									[
										412637,
										412643
									],
									[
										412644,
										412650
									],
									[
										413852,
										413858
									],
									[
										414912,
										414918
									],
									[
										416177,
										416183
									],
									[
										423301,
										423307
									],
									[
										423357,
										423363
									],
									[
										423499,
										423505
									],
									[
										423531,
										423537
									],
									[
										423569,
										423575
									],
									[
										423673,
										423679
									],
									[
										423704,
										423710
									],
									[
										423886,
										423892
									],
									[
										423913,
										423919
									],
									[
										427191,
										427197
									],
									[
										427753,
										427759
									],
									[
										428264,
										428270
									],
									[
										428795,
										428801
									],
									[
										428844,
										428850
									],
									[
										428889,
										428895
									],
									[
										429065,
										429071
									],
									[
										429074,
										429080
									],
									[
										430536,
										430542
									],
									[
										430570,
										430576
									],
									[
										430702,
										430708
									],
									[
										430747,
										430753
									],
									[
										430762,
										430768
									],
									[
										430815,
										430821
									],
									[
										430992,
										430998
									],
									[
										433001,
										433007
									],
									[
										433070,
										433076
									],
									[
										433214,
										433220
									],
									[
										433228,
										433234
									],
									[
										434657,
										434663
									],
									[
										434695,
										434701
									],
									[
										434720,
										434726
									],
									[
										451549,
										451555
									],
									[
										451605,
										451611
									],
									[
										453270,
										453276
									],
									[
										453294,
										453300
									],
									[
										513425,
										513431
									],
									[
										513459,
										513465
									],
									[
										517242,
										517250
									],
									[
										517370,
										517378
									],
									[
										517774,
										517782
									],
									[
										518263,
										518271
									],
									[
										518702,
										518710
									],
									[
										519166,
										519174
									],
									[
										519400,
										519408
									],
									[
										519636,
										519644
									],
									[
										519958,
										519973
									],
									[
										520149,
										520164
									],
									[
										520288,
										520303
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								519965,
								519965
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content"
							],
							"color_scheme": "Packages/User/Color Highlighter/themes/Monokai.tmTheme",
							"default_dir": "C:\\socialite",
							"detect_indentation": false,
							"line_numbers": false,
							"output_tag": 3,
							"result_base_dir": "",
							"result_file_regex": "^([A-Za-z\\\\/<].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 107715.0,
						"zoom_level": 1.0
					},
					"stack_index": 12,
					"type": "text"
				},
				{
					"buffer": 13,
					"file": ".meteor/local/build/programs/server/packages/ddp.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 586070,
						"regions":
						{
						},
						"selection":
						[
							[
								4309,
								4315
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content"
							],
							"color_scheme": "Packages/User/Color Highlighter/themes/Monokai.tmTheme",
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 490.0,
						"zoom_level": 1.0
					},
					"stack_index": 13,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 23.0
	},
	"input":
	{
		"height": 31.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"output.git":
	{
		"height": 100.0
	},
	"output.sftp":
	{
		"height": 124.0
	},
	"pinned_build_system": "",
	"project": "socialite.sublime-project",
	"replace":
	{
		"height": 62.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 430.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
